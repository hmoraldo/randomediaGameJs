{"version":3,"file":"randomedia.html","sources":["bullets.cpp","./vectorlist.h","carriersai.cpp","collisions.cpp","con-logger.cpp","console.cpp","ddwrap.cpp","./ddwrap.h","diwrap.cpp","enemyai.cpp","fileString.cpp","./fileString.h","fixedfontwrap.cpp","./fixedfontwrap.h","gamecode.cpp","gamedata.cpp","gameglobals.cpp","./scriptman.h","./optionsfile.h","./resobjects.h","genericunits.cpp","globals.cpp","./diwrap.h","./console.h","./con-logger.h","./timewrap.h","./mainloop.h","./loopwrap.h","./scrolltext.h","humanheadai.cpp","introcode.cpp","loopwrap.cpp","main.cpp","mainloop.cpp","massDeallocator.cpp","./massDeallocator.h","menucode.cpp","optionsfile.cpp","players.cpp","postinstall.cpp","programzones.cpp","resfonts.cpp","resinfoman.cpp","resmanager.cpp","resobjects.cpp","scriptman.cpp","scrolltext.cpp","sheepai.cpp","staging.cpp","timewrap.cpp","virtualwalls.cpp","wavegens.cpp","lib/lua-5.2.3/src/lapi.c","lib/lua-5.2.3/src/ldump.c","lib/lua-5.2.3/src/llex.c","lib/lua-5.2.3/src/lstrlib.c","lib/lua-5.2.3/src/lauxlib.c","lib/lua-5.2.3/src/lfunc.c","lib/lua-5.2.3/src/lmathlib.c","lib/lua-5.2.3/src/ltable.c","lib/lua-5.2.3/src/lundump.c","lib/lua-5.2.3/src/lbaselib.c","lib/lua-5.2.3/src/lgc.c","lib/lua-5.2.3/src/lmem.c","lib/lua-5.2.3/src/lparser.c","lib/lua-5.2.3/src/ltablib.c","lib/lua-5.2.3/src/lvm.c","lib/lua-5.2.3/src/ldebug.c","lib/lua-5.2.3/src/lstate.c","lib/lua-5.2.3/src/ltm.c","lib/lua-5.2.3/src/lzio.c","lib/lua-5.2.3/src/lcode.c","lib/lua-5.2.3/src/ldo.c","lib/lua-5.2.3/src/lobject.c","lib/lua-5.2.3/src/lstring.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAIA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;AAKA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;ACyGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AArMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ADgEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AANA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;ACgJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzTA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;;AAEA;AACA;;;AAEA;;AAEA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEA;;AA/BA;AAAA;AAAA;AAAA;;AAoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEA;;AAzBA;AAAA;AAAA;AAAA;;AA2BA;;AAzIA;AAAA;AAAA;AAAA;;AA6IA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AA3BA;AAAA;AAAA;AAAA;;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;;;;;;;;ADlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AApCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;ACmCA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;;ADZA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AErTA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAEA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AFlEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AEsFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AACA;;AATA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAIA;;AAIA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;AAMA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAUA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AAIA;;AAGA;;AAGA;;AAMA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAtCA;AAAA;AAAA;AAAA;;AA2CA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAtCA;AAAA;AAAA;AAAA;;AAuCA;;AA/FA;AAAA;AAAA;AAAA;;AAmGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAxCA;AAAA;AAAA;AAAA;;AAyCA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AA3CA;AAAA;AAAA;AAAA;;AA4CA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAtCA;AAAA;AAAA;AAAA;;AAuCA;;AACA;;AArJA;AAAA;AAAA;AAAA;;AAuJA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AFplBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AG/CA;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;AAgGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AA0CA;;;;;;;;;;;;;;;;;ACpKA;;;;;;;;;;;AAYA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAcA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;;;;;;;;;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A;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAIA;AAAA;AACA;AAAA;;AAEA;;AACA;;AA9CA;AAAA;AAAA;AAAA;;AAgDA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;ARiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA5DA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAgDA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AQ5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAIA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;;;AAsBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAEA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAMA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;AAKA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AANA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACjfA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AChJA;AAAA;;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AACA;;AAAA;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AA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AACA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AACA;;AACA;;AAEA;;AACA;;AAIA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;;AACA;AACA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;AerJA;AAAA;AAAA;;;;;;;;;;;ACmBA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;ADVA;AAAA;AAAA;;;;;;;;;;;AEmEA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AF5CA;AAAA;AAAA;;;;;;;;;;;AfwCA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AexCA;AAAA;AAAA;;;;;;;;;;;AfuCA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AevCA;AAAA;AAAA;;;;;;;;;;;AfsCA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AetCA;AAAA;AAAA;;;;;;;;;;;AfqCA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;Ae0cA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;AAmtCA;AAAA;AAAA;;;;;;;;;;;AH5qDA;AAAA;;;;;;;;AG6qDA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAiRA;AAAA;;AACA;AACA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;;AAEA;;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAZA;AAAA;AAAA;AAAA;;AAaA;;AAlCA;AAAA;AAAA;AAAA;;AAsCA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAAA;;AAIA;AAAA;;AAEA;AACA;AAAA;;AAIA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAYA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAubA;AAGA;AAAA;AAAA;;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;;AAPA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AA1FA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;Afj4EA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AArBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AArBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AArBA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AiBOA;AAAA;AAAA;;;;;;;;;;;;AF+/DA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAKA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AASA;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AnB3OA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;AmB0RA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAQA;AAAA;;;;;;;;;;;;;;;;;;AnBxVA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;AoBnDA;AAAA;AAAA;;;;;;;;;;;AdsKA;AAAA;;;;;;;;AcnKA;AAAA;AAAA;;;;;;;;;;;ACkFA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;ADlFA;AAAA;AAAA;;;;;;;;;;;ACsHA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;ADpHA;AAAA;AAAA;;;;;;;;;;;AEQA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AFRA;AAAA;AAAA;;;;;;;;;;;AGNA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AH0BA;AAAA;AAAA;;;;;;;;;;;AIlBA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;AJ4CA;AAAA;AAAA;;;;;;;;;;;AK7DA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;AL8EA;AACA;AACA;AAEA;AAIA;AAIA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAMA;AAAA;;AACA;AACA;AAAA;;AAMA;AAAA;;AACA;AACA;AAAA;;AAcA;AAGA;AAAA;;AAEA;AACA;AAAA;;AAKA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;;AAEA;AACA;AAAA;;AA0BA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAAA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAAA;;AAIA;AAAA;;AAEA;AACA;AAAA;;AAqCA;AAAA;;AACA;AACA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AA8IA;AACA;AAAA;AAEA;;;;;;;;;;;;;AAtGA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAGA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAEA;;;;;;;;;;;AAlDA;;;;;;;;;;;AItQA;AAAA;AAAA;AAAA;;;;;;;;AJgVA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;AKpWA;AAAA;AAAA;;;;;;;;;;;;;;;ACQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;ADTA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ACQA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AFSA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ADRA;AAAA;;;;;;;;;;;AADA;AAAA;AAAA;;;;;;;;;;;;;;;ADcA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AKhBA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;ALeA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AKhBA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AN4HA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAhEA;;;;;;;;;;;;;;;AAgEA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAhEA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;AA2BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;Af+EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;AAhGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AcAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AQxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;ACyBA;AAAA;AAqBA;;;AAIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;;;AAUA;;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAGA;AACA;AAAA;AACA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAGA;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAGA;AACA;AAAA;AACA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAEA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AACA;AAAA;;AACA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAOA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;AAA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AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAfA;AAAA;AAAA;;AAmBA;AAAA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;;;;;;;;;;ACnIA;AAAA;;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;;AACA;AAGA;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;AA+BA;;;;;;;;;;AAgBA;;;;;;;;;;AAkBA;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAIA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;;AAdA;AAAA;AAAA;AAAA;;AAoCA;AAAA;AAEA;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;;;;;AAKA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AAGA;AAAA;AAGA;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAEA;AAAA;;AACA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AnBxOA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AmBgPA;AAAA;AAAA;AAOA;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;;;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;;;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAEA;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;;AAKA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AA0BA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;AACA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAEA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;AAEA;AAAA;;AACA;AAAA;;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;A7BzXA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;A6BwYA;AAAA;AAAA;AAAA;AAAA;AAEA;A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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;;AACA;AACA;AAAA;;AAMA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;ArCsIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AqC5IA;AAAA;AAAA;;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAIA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAIA;;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AACA;;AATA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;;AAGA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;ArClWA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AqCmUA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AANA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;ArCpbA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAEA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAnDA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAEA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AsClKA;;;;;;;;;;;;;;;;;;;;;AC9CA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAIA;AAIA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAEA;AAAA;;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;AAQA;AAAA;;;;;;;;;;;;;;AC5EA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;;AAKA;AAAA;;AAKA;AAAA;;AAMA;AACA;AACA;AACA;AAAA;;AAEA;;AACA;;AAEA;AACA;AACA;;;AAIA;AAAA;;AACA;AAAA;;;;;;;;;;;AC1CA;AAAA;AAAA;;;;;;;;;;;AP2BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOfA;AAGA;AAAA;AAGA;AAAA;;AACA;AACA;AAAA;;AAKA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAKA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAgBA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAcA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;ACjHA;AAIA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;AAAA;;AAKA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;AAAA;;AAKA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;AAAA;;AAKA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;AA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AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAEA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAnDA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAEA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AmD5JA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AAr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AA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;AAiBA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAKA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AA/CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAcA;AAGA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AACA;;AAEA;AACA;;AAEA;AAAA;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAGA;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAA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A;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAsVA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;;;;AAxHA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;;AAGA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;;AACA;AAAA;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AA3XA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;AAsGA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;AA0CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAzVA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AA4HA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AA2CA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;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AA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;AA+bA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuQA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;;AACA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;AAlTA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AA+DA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AACA;AAAA;AAAA;;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAjuBA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AA0CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;;;;;;;;;;;;AAmiBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA7gBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA5DA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AApBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;;AAiCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAtDA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAihBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AA3DA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AA1DA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA1HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAEA;;AAEA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;;;AACA;;AAEA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAgDA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AA/KA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AApEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AApGA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AA+FA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAhGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAKA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAvGA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAxDA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAmdA;AAAA;AAAA;AAAA;AACA;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAnDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;AAGA;;AAlBA;AAAA;AAAA;AAAA;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;AA3DA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAXA;AAAA;AAAA;AAAA;;AAYA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAiMA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAtDA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AA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;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAiIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA3EA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAzDA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAqGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAdA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AA6FA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAsFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;;;;;;;;;;;;;;AApBA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AApBA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;AAhVA;AAEA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAnjBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA;;AACA;AAAA;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AASA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;;AACA;AAAA;;;;;;;;;;;;;ACgHA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AA1PA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAcA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AArCA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAsGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AArDA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AA6DA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA9CA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAwDA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAvBA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAhFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAmCA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAkDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAhMA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AA0EA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAnDA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACqHA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AANA;AAAA;AAAA;AAAA;;AAOA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAxCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4IA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAtVA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AA4QA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA9CA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAyFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AA1XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AA2XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;AA0DA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA3CA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAjUA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AA/CA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA3BA;AACA;AACA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAtFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC0EA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;;;;;;;;;;;;;;;AAtCA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AA3BA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;AAgEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;AAtMA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;AATA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AAkCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AAGA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AACA;;AApBA;AAAA;AAAA;AAAA;;AAqBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AA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AAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;AA3IA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA2oBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AA1IA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AA2LA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;AA+IA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;AAjLA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;;AAtJA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;;AACA;;;;;;;;;;;;;;;;;;AA6GA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AApQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAiSA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;AA6DA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;AArDA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3VA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;;;;;;;;;;;;;;;;AAoVA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;AA7SA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAnIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AApdA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AAmLA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;AAqbA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAjQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;AAneA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAA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AAA;AAAA;AAAA;AACA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AACA;;AAbA;AAAA;AAAA;AAAA;;AAcA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;AAiKA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;AA3IA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAEA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAoCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAVA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAaA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAvDA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAlHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;;AAVA;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;;AA0CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AATA;AAAA;AAAA;AAAA;;AAUA;;;;;;;;;;;;;;;;;AAyOA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;;AACA;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/oBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACq/CA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;;;;;;;;;;;;;;;;;AA7BA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AA/jCA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAnZA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAgFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AA4WA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;AAtfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;AA2bA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;AA1GA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;;;;;;;;;;;;;;AA7aA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;AAmYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAlPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;AA2MA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA7YA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAoSA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AATA;AAAA;AAAA;AAAA;;AAUA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAvCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AA/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAyLA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AACA;;AACA;;;;;;;;;;;;;;;;AA7UA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAkgBA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AAi6BA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAhvCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAqjCA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAzLA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AArKA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAl8BA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;AAssCA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AApHA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;AA2MA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA/1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;AAsyCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAKA;AAGA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AA1OA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAjkCA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AA00CA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AA1VA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAmSA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;;;;AA/kBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AA6MA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAzDA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AAdA;AAAA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;AA5gCA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAqrBA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA5fA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAEA;;;;;;;;;;;;;;;AAquBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AA7BA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AA3EA;;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAtDA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;AAcA;;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;AA51BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAgkBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAnTA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AA/TA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;AAsiBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAxQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAzVA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AArBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAofA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;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AA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;AAqtBA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAwIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA/BA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;AAkGA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;AC3mCA;AAAA;AAAA;AAAA;AAMA;;;;;;;;;;;;;;;;;AAxLA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAuDA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAhFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAwKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AArEA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;AA3EA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAjBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAlFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AACA;;AAnBA;AAAA;AAAA;AAAA;;AAoBA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AACA;;AAhCA;AAAA;AAAA;AAAA;;AAiCA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;AA6DA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA9BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAtGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkGA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AA3JA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AA0JA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoKA;AAAA;AAAA;AAAA;AAGA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAmBA;;AAIA;;;;;;;;;;;;;;;;;;;;;AApyBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAkSA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3UA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AA+KA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA5EA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AA3DA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AAzBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;AA5gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwSA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AA1CA;AAAA;AAAA;AAAA;;AA2CA;AAAA;;;;;;;;;;;;;;;;;;;AA9RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AA+MA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAIA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AA3JA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AA8PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAKA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;ACtXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;AA2EA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AApFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AA2GA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AA7GA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AA+GA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA/NA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAsFA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;AA2BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAoFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;AAzJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACxIA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAKA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAgLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA5KA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AA+KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAzCA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;;AA3IA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AA0EA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;AAiBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AA3CA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;AAxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AA8HA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;AACA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AACA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;AAtIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;;;;;;;;;;;;;;AAmNA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAnNA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;AAqLA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AA3MA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAqNA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;;AAGA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AA3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AA6BA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAwCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAsDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;;AACA;;;;;;;;;;;;;;;AA9uBA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAorBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;;;;AA1EA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAIA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAuFA;;;AAEA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAG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;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAMA;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;;;AAlBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAHA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AA5HA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;;;;;;AAzBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA6GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAhUA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkfA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAoDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAnCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;;AA3BA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;ACxlBA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAcA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAsEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAlDA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AA6DA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;AA3LA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AA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;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxCrBA;AWqFA","sourcesContent":["/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"bullets.h\"// for managing the bullets\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"collisions.h\"// for functions related to the collisions of units\r\n\r\n// moveBulletUnit *****\r\n// This method moves an individual bullet unit.\r\nbool moveBulletUnit(\r\n\tDWORD frameNumber,// current frame\r\n\tvectorListNodeStruct<bulletUnitStruct>& unit)// bullet unit to move\r\n{\r\n\tgenericUnitTypeDataStruct* myType=&(bulletType[unit.data.unitType]);\r\n\tframeDataStruct* myUnitFrame=&(myType->frames[unit.data.currentFrame]);\r\n\r\n\t// we use this to know if the unit was going to a given point\r\n\t// before executing the unintelligent lineal movement\r\n\tbool wasGoingToPoint=unit.data.goingToPoint;\r\n\r\n\t// AUTOFRAMING BEGIN\r\n\t// auto frame it\r\n\tif (!autoFrameUnit(&(unit.data))) return false;\r\n\r\n\t// check for negative frame numbers (they use to have a meaning,\r\n\t// attached)\r\n\tswitch(unit.data.currentFrame){\r\n\t// BULLET SPECIFIC CODE BEGIN\r\n\tcase -1:\r\n\t\t// frame -1 means: this unit should stop existing!\r\n\t\t// free the slaves of this unit\r\n\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t// remove the unit\r\n\t\tif (!bulletList.removeNode(bulletList.getIndex(&unit)))\r\n\t\t\treturn false;\r\n\t\t// the unit has been removed, we cannot continue here\r\n\t\treturn true;\r\n\t// BULLET SPECIFIC CODE END\r\n\tdefault:\r\n\t\t// no problem here...\r\n\t\tbreak;\r\n\t}// switch\r\n\t// AUTOFRAMING END\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\t// if this unit is a slave of any other, no more work should be\r\n\t// done here\r\n\tif (unit.data.slaveOf.objectType!=FILE_GAMEDATA_GAMEOBJECT_EMPTY)\r\n\t\treturn true;\r\n\r\n\t// move the unit with the camera if it's necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.x=gameWorld.xCamera+unit.data.xFromCamera;\r\n\t\tunit.data.y=gameWorld.yCamera+unit.data.yFromCamera;\r\n\t}// if\r\n\r\n\t// should we move the unit to some specific point?\r\n\t// that is, unintelligent movement vs. intelligent movement\r\n\tif (unit.data.goingToPoint){\r\n\t\tif (!unintelligentLinealMove(&unit.data))\r\n\t\t\treturn false;// failed!\r\n\t}else{\r\n\t\t// typical ai\r\n\t\t// move it\r\n\t\tswitch (unit.data.unitType){\r\n\t\tcase FILE_GAMEDATA_BULLET_PLAYERFLAME:\r\n\t\t\t// move always\r\n\t\t\tunit.data.x+=unit.data.speedX;\r\n\t\t\tunit.data.y+=unit.data.speedY;\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t}// if\r\n\r\n\t// check if it has just stopped going to a point\r\n\tif (wasGoingToPoint && !unit.data.goingToPoint){\r\n\t\tgameObjectPointerStruct objPointer;\r\n\r\n\t\t// kill the bullet\r\n\t\tobjPointer.id=FILE_GAMEDATA_SOMEWALL_ID;\r\n\t\tobjPointer.listIndex=0;// it's not in any list\r\n\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_VIRTUALWALL;\r\n\r\n\t\t// collided!\r\n\t\tbulletUnitHit(unit, objPointer);\r\n\t}// if\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\t// update the *FromCamera variables if necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.xFromCamera=unit.data.x-gameWorld.xCamera;\r\n\t\tunit.data.yFromCamera=unit.data.y-gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// let's move the unit with the owner unit, if any\r\n\tif (!moveWithOwner(&unit.data)) return false;\r\n\t\r\n\t// VISIBILITY CHECK BEGIN\r\n\t// Checks for visibility after the unit moved...\r\n\tif (isUnitInsideTheScreen(&unit.data)){\r\n\r\n\t\t// It's inside the screen, zero the counter\r\n\t\tunit.data.timeOutsideTheScreenLeft=0;\r\n\t}else{\r\n\t\t// The unit is outside the screen.\r\n\t\tif (unit.data.timeOutsideTheScreenLeft<=0){\r\n\t\t\t// That's the first time now, set to the max\r\n\t\t\tunit.data.timeOutsideTheScreenLeft=\r\n\t\t\t\tunit.data.timeOutsideTheScreenMax;\r\n\t\t}else{\r\n\t\t\t// It's not the first time, decrement the counter first\r\n\t\t\tunit.data.timeOutsideTheScreenLeft--;\r\n\t\t}// if\r\n\r\n\t\t// Now see if it hasn't been too much time out there\r\n\t\tif (unit.data.timeOutsideTheScreenLeft<=0){\r\n\t\t\t// It's been too much time out there, remove it.\r\n\t\t\t// free the slaves of this unit\r\n\t\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t\t// remove the unit\r\n\t\t\tif (!bulletList.removeNode(bulletList.getIndex(&unit)))\r\n\t\t\t\treturn false;\r\n\t\t\t// the unit has been removed, we cannot continue here\r\n\t\t\treturn true;\r\n\t\t}// if\r\n\t}// if\r\n\t// END VISIBILITY CHECK\r\n\r\n\treturn true;// all ok\r\n}// moveBulletUnit\r\n\r\n// moveBullets ********\r\n// This method moves every bullet in the game world (executed once\r\n// per game frame).\r\nbool moveBullets(DWORD frameNumber)\r\n{\r\n\tvectorListNodeStruct<bulletUnitStruct> *unit;\r\n\r\n\t// Manage the AI of all the bullets on screen...\r\n\tfor (unit=bulletList.getFirstNode(); unit!=NULL; unit=bulletList.getNextNode(unit)){\r\n\t\t// don't move this unit if it's not active now\r\n\t\tif (!unit->data.nowActive) continue;\r\n\r\n\t\t// move this unit\r\n\t\tif (!moveBulletUnit(frameNumber, *unit)) return false;\r\n\t}// for unit\r\n\r\n\treturn true;// all ok\r\n}// moveBullets\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n/*\r\nVECTORLIST.*:\r\n\r\n\r\nThese files set up a template for managing dynamics lists of objects\r\nwith no special order, by using the once-allocated memory of a vector.\r\nIt's somewhat a mix between a vector and a linked list, though the order\r\nin the objects should not be important here.\r\n\r\nThis vector list is optimized both for adding and traversing the nodes.\r\n\r\n*/\r\n\r\n#ifndef FILE_VECTORLIST_INCLUDED\r\n#define FILE_VECTORLIST_INCLUDED\r\n\r\n#define FILE_VECTORLIST_VERSION \"19-12-2002-H\"// last modification: dd/mm/yy\r\n\r\n#include \"win-constants.h\"// for defining those common types, like DWORD, etc\r\n\r\n// This is the template which defines a node.\r\ntemplate <class T>\r\nstruct vectorListNodeStruct {\r\n\t// here is stored the real data...\r\n\tT data;\r\n\r\n\t// here is stored the condition of this node\r\n\tbool empty;\r\n};\r\n\r\n// This is the main template, which manages the lists.\r\ntemplate <class T>\r\nclass vectorListClass{\r\nprivate:\r\n\t// Some useful variables:\r\n\t// this variable tells whether the list was already initialized or not\r\n\tbool initialized;\r\n\t// this variable tells how many nodes there are in the list.\r\n\tDWORD nodesInList;\r\n\t// this variable points to the last active mode... thanks to this\r\n\t// info the iterator can know where to stop when looking for active\r\n\t// nodes.\r\n\t// lastActiveNode=nodesInList if no one is active.\r\n\tDWORD lastActiveNode;\r\n\t// this variable points to the first inactive node... it's very\r\n\t// helpful when adding an active node, as it already tells what's the\r\n\t// first empty node to use.\r\n\t// firstEmptyNode=nodesInList if no one is empty.\r\n\tDWORD firstEmptyNode;\r\n\t// this variable is used for statistical purposes only (and for\r\n\t// checking the overall use). It tells what's been the maximum amount\r\n\t// of enemies in the list ever.\r\n\tDWORD maxNodesUntilNow;\r\n\t// And here is the list itself, which actually is a vector...\r\n\tvectorListNodeStruct<T> *nodesList;\r\n\r\n\t// Some private methods...\r\n\tbool activateNode(DWORD nodeNumber);\r\npublic:\r\n\t// Some useful methods...\r\n\tbool initialize(DWORD size);\r\n\tbool end();\r\n\tbool resetList();\r\n\tbool removeNode(DWORD nodeNumber);\r\n\tDWORD addNode(T& data);\r\n\r\n\t// Methods used for traversing the list\r\n\tDWORD getIndexFirstNode();\r\n\tDWORD getNextNode(DWORD since);\r\n\tvectorListNodeStruct<T> *getFirstNode();\r\n\tvectorListNodeStruct<T> *getNextNode(vectorListNodeStruct<T> *since);\r\n\r\n\t// Some inlined methods:\r\n\t// Used for getting a node from its number... returns null if the\r\n\t// index isn't allowed\r\n\tvectorListNodeStruct<T> *getNode(DWORD nodeNumber){\r\n\t\treturn (isValidIndex(nodeNumber)?nodesList+nodeNumber:NULL);}\r\n\tDWORD getIndex(vectorListNodeStruct<T> *node){return (node-nodesList);}\r\n\r\n\t// Some simple methods...\r\n\tDWORD getMaxNodesUntilNow(){return maxNodesUntilNow;}\r\n\tDWORD vectorSize(){return nodesInList;}\r\n\tbool isValidIndex(DWORD index){return index>=0 && index<vectorSize();}\r\n\tbool isReady(){return initialized;}\r\n\r\n\t// constructor / destructor\r\n\tvectorListClass():initialized(false),nodesList(NULL){}\r\n\t~vectorListClass(){end();}\r\n};// vectorListClass\r\n\r\n// VECTORLISTCLASS methods\r\n// This method initializes the list, by allocating memory and resetting\r\n// it.\r\ntemplate <class T>\r\nbool vectorListClass<T>::initialize(DWORD size)\r\n{\r\n\tif (initialized) return false;// error!\r\n\r\n\t// allocate the memory needed\r\n\tnodesList=new vectorListNodeStruct<T>[size];\r\n\tif (nodesList==NULL) return false;// memory couldn't be allocated\r\n\tnodesInList=size;\r\n\r\n\t// set the statistic to zero\r\n\tmaxNodesUntilNow=0;\r\n\r\n\t// change the flag\r\n\tinitialized=true;\r\n\r\n\t// go reset the list\r\n\tif (!resetList()){\r\n\t\t// it's been an error\r\n\t\tinitialized=false;\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// initialize\r\n\r\n// Free the memory in use and terminate the list system.\r\ntemplate <class T>\r\nbool vectorListClass<T>::end()\r\n{\r\n\tif (!initialized) return false;// error!\r\n\r\n\t// free the memory in use\r\n\tdelete[] nodesList;\r\n\tnodesList=NULL;\r\n\r\n\t// change the flag\r\n\tinitialized=false;\r\n\r\n\treturn true;// all ok\r\n}// end\r\n\r\n// Reset the contents of the list...\r\ntemplate <class T>\r\nbool vectorListClass<T>::resetList()\r\n{\r\n\tDWORD i;\r\n\tvectorListNodeStruct<T>* node;\r\n\r\n\tif (!initialized) return false;// error!\r\n\r\n\t// go for the first node\r\n\tnode=nodesList;\r\n\r\n\t// iterate the entire list to empty it\r\n\tfor (i=0; i<nodesInList; i++){\r\n\t\t// place a void node\r\n\t\tnode->empty=true;\r\n\r\n\t\t// go for the next one\r\n\t\tnode++;\r\n\t}// for i\r\n\r\n\t// set some extra variables\r\n\tlastActiveNode=nodesInList;// no one is active\r\n\tfirstEmptyNode=0;// the first node is empty (and all of them are)\r\n\r\n\treturn true;// all ok\r\n}// resetList\r\n\r\n// Activate a node and check for other changes that are needed when some\r\n// nodes are activated.\r\n// This method VERY important for the correct working of this class.\r\n// Hence, this method has to be called every time a node is activated.\r\ntemplate <class T>\r\nbool vectorListClass<T>::activateNode(DWORD nodeNumber)\r\n{\r\n\tDWORD i;\r\n\tvectorListNodeStruct<T>* node;\r\n\r\n\tif (!initialized) return false;// error!\r\n\r\n\t// activate the node\r\n\tnodesList[nodeNumber].empty=false;\r\n\r\n\t// check for our special case: if we activate a node which is\r\n\t// after the lastActiveNode, we need to update that variable...\r\n\t// If no nodes are active, it has to be updated too.\r\n\tif (nodeNumber>lastActiveNode || lastActiveNode==nodesInList){\r\n\t\t// now it's the last active node!\r\n\t\tlastActiveNode=nodeNumber;\r\n\t}// if\r\n\r\n\t// second special case: we are activating the first empty node...\r\n\tif (nodeNumber==firstEmptyNode){\r\n\t\t// in such a case, we have to look for the next empty node...\r\n\t\t// which is also supposed to be the first of course\r\n\r\n\t\t// go from the next node\r\n\t\tnode=nodesList+firstEmptyNode+1;\r\n\r\n\t\t// iterate the entire list until we find the first empty node\r\n\t\tfor (i=firstEmptyNode+1; i<nodesInList; i++){\r\n\t\t\t// if this one is empty, go break\r\n\t\t\tif (node->empty) break;\r\n\r\n\t\t\t// go for the next one\r\n\t\t\tnode++;\r\n\t\t}// for i\r\n\r\n\t\t// it's very nice, as it easily sets the variable with the\r\n\t\t// right number, and if the list is entirely occupied, it's\r\n\t\t// set equal to nodesInList, which is the value used for\r\n\t\t// telling that there are no empty nodes.\r\n\t\tfirstEmptyNode=i;\r\n\t\t// mission complete!\r\n\t}// if\r\n\r\n\t// at last, let's update the statistic...\r\n\t// This statistic works with the supposition that nodes are always\r\n\t// added in the first empty node which can be found in the list.\r\n\t// This way, if lastActiveNode is incremented somewhere, it's so\r\n\t// because there are currently no gaps in the list, and so\r\n\t// lastActiveNode+1 is, at that moment only, the current amount of\r\n\t// nodes in the list. Later as we delete nodes in the middle of the\r\n\t// list, that value will only be meaningful as the maximum of\r\n\t// nodes until now, and that's exactly the way we use it.\r\n\tif (lastActiveNode!=nodesInList && lastActiveNode+1>maxNodesUntilNow)\r\n\t\tmaxNodesUntilNow=lastActiveNode+1;\r\n\r\n\treturn true;// all ok\r\n}// activateNode\r\n\r\n// This method empties a node, and also checks for other changes that\r\n// are needed when some special nodes are emptied.\r\n// Because of this, it's VERY important for the correct working of this\r\n// class.  Hence, this method has to be called every time a node is\r\n// removed.\r\ntemplate <class T>\r\nbool vectorListClass<T>::removeNode(DWORD nodeNumber)\r\n{\r\n\tvectorListNodeStruct<T>* node;\r\n\r\n\tif (!initialized) return false;// error!\r\n\r\n\t// empty the node\r\n\tnodesList[nodeNumber].empty=true;\r\n\r\n\t// now check for our special case: if we remove a node which is\r\n\t// before the firstEmptyNode, we need to update that variable...\r\n\tif (nodeNumber<firstEmptyNode){\r\n\t\t// now it's the first empty node\r\n\t\tfirstEmptyNode=nodeNumber;\r\n\t}// if\r\n\r\n\t// special case two: we are removing the lastActiveNode!\r\n\tif (nodeNumber==lastActiveNode){\r\n\t\t// in such a case, we have to look for the first active node\r\n\t\t// before it... (that is, the first backwards!)\r\n\t\t// which is also supposed to be the last in the list of course\r\n\r\n\t\t// iterate the entire list until we find the first active node\r\n\t\t// backwards...\r\n\t\tfor (node=nodesList+lastActiveNode-1;node>=nodesList; node--){\r\n\r\n\t\t\t// if this one is active, go break\r\n\t\t\tif (!(node->empty)) break;\r\n\t\t}// for node\r\n\r\n\t\t// now it's time to check what has happened\r\n\t\tif (node<nodesList){\r\n\t\t\t// no more active nodes...\r\n\t\t\tlastActiveNode=nodesInList;// means no one is active now\r\n\t\t}else{\r\n\t\t\t// set the right active node\r\n\t\t\tlastActiveNode=(node-nodesList);\r\n\t\t}// if\r\n\t\t// mission complete!\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// removeNode\r\n\r\n// Used for starting a list traversal. Use together with getNode and\r\n// getNextNode.\r\n// It returns \"nodesInList\" if no more nodes can be found (to check with\r\n// isValidIndex).\r\ntemplate <class T>\r\nDWORD vectorListClass<T>::getIndexFirstNode()\r\n{\r\n\t// if the first node is empty, check for the next ones...\r\n\tif (!(nodesList[0].empty)) return 0;\r\n\treturn getNextNode(0);\r\n}// getIndexFirstNode\r\n\r\n// Used for starting a list traversal. Use together with getNextNode.\r\n// It returns NULL if no more nodes can be found.\r\ntemplate <class T>\r\nvectorListNodeStruct<T>* vectorListClass<T>::getFirstNode()\r\n{\r\n\t// if the first node is empty, check for the next ones...\r\n\tif (!(nodesList[0].empty)) return nodesList;\r\n\treturn getNextNode(nodesList);\r\n}// getFirstNode\r\n\r\n// Used for traversing the list, it just tells what's the next active\r\n// node... use together with getNode and getIndexFirstNode.\r\n// It returns \"nodesInList\" if no more nodes can be found (to check with\r\n// isValidIndex).\r\ntemplate <class T>\r\nDWORD vectorListClass<T>::getNextNode(DWORD since)\r\n{\r\n\tvectorListNodeStruct<T> *node;\r\n\r\n\tfor (node=nodesList+since+1;node<nodesList+nodesInList; node++){\r\n\r\n\t\t// if this one is active, go break\r\n\t\tif (!(node->empty)) break;\r\n\t}// for node\r\n\r\n\treturn node-nodesInList;\r\n}// getNextNode\r\n\r\n// Used for traversing the list, it just tells what's the next active\r\n// node... use together getFirstNode.\r\n// It returns NULL if no more nodes can be found.\r\ntemplate <class T>\r\nvectorListNodeStruct<T>* vectorListClass<T>::getNextNode(vectorListNodeStruct<T> *since)\r\n{\r\n\tfor (since++;since<nodesList+nodesInList; since++){\r\n\r\n\t\t// if this one is active, go break\r\n\t\tif (!(since->empty)) break;\r\n\t}// for node\r\n\r\n\tif (since>=nodesList+nodesInList) return NULL;\r\n\treturn since;\r\n}// getNextNode\r\n\r\n// This method is used for adding a node to the list. Returns\r\n// \"nodesInList\" if the node can't be added, otherwise it returns\r\n// the index of the added node (which later can be used together with\r\n// getNode)... The returned value can be checked with isValidIndex\r\n// for error checking.\r\ntemplate <class T>\r\nDWORD vectorListClass<T>::addNode(T& data)\r\n{\r\n\tDWORD index;\r\n\r\n\t// remember it before the value changes\r\n\tindex=firstEmptyNode;\r\n\r\n\t// return error if there is no more space in the list\r\n\tif (firstEmptyNode>=nodesInList) return nodesInList;\r\n\r\n\t// add the node...\r\n\tnodesList[firstEmptyNode].data=data;\r\n\tif (!activateNode(firstEmptyNode)) return nodesInList;// check for errors\r\n\r\n\t// return the index where the node was stored\r\n\treturn index;\r\n}// addNode\r\n\r\n#endif// FILE_VECTORLIST_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"carriersai.h\"// for managing the AI of a specific type of enemies, the carriers\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n// carrierLinearMovementDoneEvent *******\r\n// This is the code to be executed when a carrier finishes with the\r\n// execution of a linear movement.\r\nbool carrierLinearMovementDoneEvent(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)\r\n{\r\n\t// Pseudo Flocking variables\r\n\t// these are used for calculating the positions to use\r\n\tconst int desiredNum=15;\r\n\tint desiredX[desiredNum], desiredY[desiredNum];\r\n\r\n\tdouble minDistanceEnemy[desiredNum];\r\n\tdouble minDistanceBullet[desiredNum];\r\n\r\n\tint maxDistanceDesiredNum;\r\n\tdouble tempMinDistance;\r\n\r\n\tint i;\r\n\r\n\tvectorListNodeStruct<enemyUnitStruct>* otherU;\r\n\tvectorListNodeStruct<bulletUnitStruct>* otherB;\r\n\tvectorListNodeStruct<playerUnitStruct>* onePlayer;\r\n\r\n\tdouble otherUX, otherUY;\r\n\tregister double distance;\r\n\r\n\t// first of all, check whether we should enable the collision\r\n\t// of this object with other ones or not\r\n\tif (unit.data.justGoingOut){\r\n\t\t// now it can collide with both bullets and players\r\n\t\tunit.data.justGoingOut=false;// you are not new anymore\r\n\t\tunit.data.canBeHitByBullets=true;\r\n\t\tunit.data.canBeHitByPlayers=true;\r\n\t}// if\r\n\r\n\t// calculate some desired coordinates\r\n\tfor (i=0; i<desiredNum; i++){\r\n\t\tint l;\r\n\r\n\t\t// for i, calculate these coordinates\r\n\t\tif (unit.data.x<160){\r\n\t\t\t// [0,160)\r\n\t\t\t// go high, escape from the screen!\r\n\t\t\tdesiredX[i]=0-\r\n\t\t\t\t(constructContainerFrame(&unit.data).w\r\n\t\t\t\t-constructContainerFrame(&unit.data).handlerX);\r\n\t\t\tdesiredY[i]=(rand()%300)-250;\r\n\t\t}else{\r\n\t\t\t// [160, screenWidth)\r\n\t\t\tint minY, maxY;\r\n\r\n\t\t\t// calculate the limits for our guy\r\n\t\t\tif (unit.data.x<270){\r\n\t\t\t\t// check if it has any slave units\r\n\t\t\t\tif (unit.data.slaveUnit.objectType!=\r\n\t\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t\t\t\t// go very high! don't let the slave unit\r\n\t\t\t\t\t// touch the anti wave generator\r\n\t\t\t\t\tminY=38;\r\n\t\t\t\t\tmaxY=350;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// don't care too much... go slightly higher\r\n\t\t\t\t\tminY=38;\r\n\t\t\t\t\tmaxY=400;\r\n\t\t\t\t}// if\r\n\t\t\t}else{\r\n\t\t\t\t// go anywhere\r\n\t\t\t\tminY=38;\r\n\t\t\t\tmaxY=462;\r\n\t\t\t}// if\r\n\r\n\t\t\t// go somewhere in the middle\r\n\t\t\tdesiredX[i]=int(unit.data.x)-10-(rand()%60);\r\n\t\t\tdesiredY[i]=int(unit.data.y)-(rand()%200)+100;\r\n\r\n\t\t\t// we try not to choose values over the limits, for Y\r\n\t\t\tfor (l=0; l<20 &&\r\n\t\t\t\t(desiredY[i]<minY || desiredY[i]>maxY); l++){\r\n\r\n\t\t\t\tdesiredY[i]=int(unit.data.y)-(rand()%200)+100;\r\n\t\t\t}// for\r\n\t\t\t// over the limits: we have no choice now\r\n\t\t\tdesiredY[i]=desiredY[i]<minY?minY:desiredY[i];\r\n\t\t\tdesiredY[i]=desiredY[i]>maxY?maxY:desiredY[i];\r\n\t\t}// if\r\n\r\n\t\t// changing the resolution of the Y coordinate\r\n\r\n\t\t// don't let the distance to travel get too high\r\n\t\t// Rather, set desiredX and desiredY so that they\r\n\t\t// always make the unit travel some fixed distance.\r\n\t\tdistance=\r\n\t\t\tsqrt(SQUARE(unit.data.x-desiredX[i])+\r\n\t\t\tSQUARE(unit.data.y-desiredY[i]));\r\n\t\tif (distance!=0){\r\n\t\t\tdesiredX[i]=int(unit.data.x+\r\n\t\t\t\t((desiredX[i]-unit.data.x)/(distance/60.0)));\r\n\t\t\tdesiredY[i]=int(unit.data.y+\r\n\t\t\t\t((desiredY[i]-unit.data.y)/(distance/60.0)));\r\n\t\t}// if\r\n\r\n\t\t// now check the minimum distance between the choosen\r\n\t\t// point and the goingTo point of some other unit\r\n\t\tminDistanceBullet[i]=SQUARE(gameWorld.wCamera)+\r\n\t\t\tSQUARE(gameWorld.hCamera);\r\n\t\tfor (otherU=enemyList.getFirstNode(); otherU!=NULL;\r\n\t\totherU=enemyList.getNextNode(otherU)){\r\n\r\n\t\t\t// never mind about this unit if it's not active, or\r\n\t\t\t// if it's the same as the one being moved now\r\n\t\t\tif (!otherU->data.nowActive ||\r\n\t\t\t\totherU->data.id==unit.data.id) continue;\r\n\r\n\t\t\t// never mind about the carried unit either\r\n\t\t\tif (otherU->data.id==unit.data.slaveUnit.id)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// calculate the pseudo distance\r\n\t\t\t// AI REVISE LATER BEGIN: here I remove goingtopoint\r\n\t\t\tif (false && otherU->data.goingToPoint){\r\n\t\t\t\totherUX=otherU->data.goingToPointX;\r\n\t\t\t\totherUY=otherU->data.goingToPointY;\r\n\t\t\t\tif (otherU->data.isPosRelative){\r\n\t\t\t\t\totherUX-=gameWorld.xCamera;\r\n\t\t\t\t\totherUY-=gameWorld.xCamera;\r\n\t\t\t\t}// if\r\n\t\t\t}else{\r\n\t\t\t\totherUX=otherU->data.x;\r\n\t\t\t\totherUY=otherU->data.y;\r\n\t\t\t}// if\r\n\t\t\t// AI REVISE LATER END\r\n\t\t\ttempMinDistance=\r\n\t\t\t\tSQUARE(desiredX[i]-otherUX)\r\n\t\t\t\t+SQUARE(desiredY[i]-otherUY);\r\n\r\n\t\t\tminDistanceEnemy[i]=\r\n\t\t\t\tMIN(tempMinDistance, minDistanceEnemy[i]);\r\n\t\t}// for otherU\r\n\r\n\r\n\t\t// now check the minimum distance between the choosen\r\n\t\t// point and the place some near bullet is\r\n\t\tminDistanceBullet[i]=SQUARE(gameWorld.wCamera)+\r\n\t\t\tSQUARE(gameWorld.hCamera);\r\n\t\tfor (otherB=bulletList.getFirstNode(); otherB!=NULL;\r\n\t\totherB=bulletList.getNextNode(otherB)){\r\n\r\n\t\t\t// never mind about this bullet if it's not active, or\r\n\t\t\t// if it's the same as the one being moved now\r\n\t\t\tif (!otherB->data.nowActive) continue;\r\n\r\n\t\t\t// get the coordinates...\r\n\t\t\totherUX=otherB->data.x;\r\n\t\t\totherUY=otherB->data.y;\r\n\r\n\t\t\t// AI REVISE LATER BEGIN\r\n\t\t\t// never mind about this bullet if it's farther than 160\r\n\t\t\t// pixels\r\n\t\t\tif (SQUARE(unit.data.x-otherUX)\r\n\t\t\t\t+SQUARE(unit.data.y-otherUY)>(160*160))\r\n\t\t\t\tcontinue;\r\n\t\t\t// AI REVISE LATER END\r\n\r\n\t\t\t// calculate the pseudo distance\r\n\t\t\ttempMinDistance=\r\n\t\t\t\tSQUARE(desiredX[i]-otherUX)\r\n\t\t\t\t+SQUARE(desiredY[i]-otherUY);\r\n\r\n\t\t\tminDistanceBullet[i]=\r\n\t\t\t\tMIN(tempMinDistance, minDistanceBullet[i]);\r\n\t\t}// for otherB\r\n\r\n\t}// for\r\n\r\n\t// now choose, between those, the one that is less\r\n\t// full of enemies and bullets\r\n\tmaxDistanceDesiredNum=0;\r\n\tfor (i=0; i<desiredNum; i++){\r\n\t\tbool r;// for the inlined function\r\n\r\n\t\t// INLINE_FUNCTION_1 BEGIN\r\n\t\t// this is like a function we call, and it returns a bool in a\r\n\t\t// variable named r\r\n\t\t// bool isThisPositionBetter(int thisOne, int theOtherOne){\r\n\t\t//\tint i=thisOne;\r\n\t\t//\tint maxDistanceDesiredNum=theOtherOne;\r\n\t\t\tdouble value1, value2;\r\n\r\n\t\t\tvalue1=\r\n\t\t\t\tminDistanceEnemy[i]*0.8+\r\n\t\t\t\tminDistanceBullet[i]*0.2;\r\n\t\t\tvalue2=\r\n\t\t\t\tminDistanceEnemy[maxDistanceDesiredNum]*0.8+\r\n\t\t\t\tminDistanceBullet[maxDistanceDesiredNum]*0.2;\r\n\r\n\t\t\tr=value1>value2;\r\n\r\n\t\t//\treturn r;\r\n\t\t// }// isThisPositionBetter\r\n\t\t// INLINE_FUNCTION_1 END\r\n\r\n\t\t// if (isThisPositionBetter(i, maxDistanceDesiredNum)\r\n\t\tif (r)\r\n\t\t\tmaxDistanceDesiredNum=i;\r\n\t}// for\r\n\r\n\t// calculate the final data\r\n\tunit.data.goingToPointX=desiredX[maxDistanceDesiredNum];\r\n\tunit.data.goingToPointY=desiredY[maxDistanceDesiredNum];\r\n\r\n\t// sometimes, go to the player pos (direct attack!), but\r\n\t// only if the attacking unit has a slave\r\n\t// (but let's get it deactivated for a while)\r\n\t{// block begin\r\n\tint x, y;\r\n\tonePlayer=playerList.getFirstNode();\r\n\tx=int(onePlayer->data.x); y=int(onePlayer->data.y);\r\n\tdistance=\r\n\t\tSQUARE(x-unit.data.x)\r\n\t\t+SQUARE(y-unit.data.y);\r\n\tif (rand()%10==0 &&\tdistance<SQUARE(200)\r\n\t\t&& (\r\n\t\tABS(x-getLeftWall(y))<100 ||\r\n\t\tABS(x-getRightWall(y))<100 ||\r\n\t\tABS(y-getGroundWall(x))<100)\r\n\t\t){\r\n\r\n\t\t// too near to the borders\r\n\t\t// attack the player directly!\r\n\t\tunit.data.goingToPointX=onePlayer->data.x;\r\n\t\tunit.data.goingToPointY=onePlayer->data.y;\r\n\t}// if\r\n\t}// end block\r\n\r\n\t// FOLLOWERS_TEST_BEGIN\r\n\t// check if it's a follower\r\n\t{\r\n\tenemyUnitStruct* followMe=(enemyUnitStruct*)getUnitPointer(\r\n\t\tunit.data.aiSpecific.flockerData.unitToFollow);\r\n\r\n\tif (followMe!=NULL){\r\n\t\tdouble goX, goY;\r\n\t\tdouble tmpGoX=unit.data.goingToPointX;\r\n\t\tdouble tmpGoY=unit.data.goingToPointY;\r\n\r\n\t\tif (followMe->goingToPoint){\r\n\t\t\tgoX=followMe->goingToPointX;\r\n\t\t\tgoY=followMe->goingToPointY;\r\n\t\t}else{\r\n\t\t\tgoX=followMe->x;\r\n\t\t\tgoY=followMe->y;\r\n\t\t}// if\r\n\r\n\t\t// if we aren't too near, set us to go where our followed wants\r\n\t\t// to be\r\n\t\t// OJO!!! a veces los going to son distintos, relativos o no\r\n\t\tdistance=\r\n\t\t\tsqrt(SQUARE(unit.data.x-goX)+\r\n\t\t\tSQUARE(unit.data.y-goY));\r\n\t\tif (distance>125){\r\n\t\t\t// now let's go where our friend is going to...\r\n\t\t\tunit.data.goingToPoint=true;\r\n\t\t\tunit.data.goingToPointX=goX;\r\n\t\t\tunit.data.goingToPointY=goY;\r\n\r\n\t\t\t// don't let the distance to travel get too high\r\n\t\t\t// Rather, set desiredX and desiredY so that they\r\n\t\t\t// always make the unit travel some fixed distance.\r\n\t\t\tdistance=\r\n\t\t\t\tsqrt(SQUARE(unit.data.x-unit.data.goingToPointY)+\r\n\t\t\t\tSQUARE(unit.data.y-unit.data.goingToPointY));\r\n\t\t\tif (distance!=0){\r\n\t\t\t\tunit.data.goingToPointX=int(unit.data.x+\r\n\t\t\t\t\t((unit.data.goingToPointX-unit.data.x)\r\n\t\t\t\t\t/(distance/80.0)));\r\n\t\t\t\tunit.data.goingToPointY=int(unit.data.y+\r\n\t\t\t\t\t((unit.data.goingToPointY-unit.data.y)\r\n\t\t\t\t\t/(distance/80.0)));\r\n\t\t\t}// if\r\n\r\n\t\t\t// now mix our going to with the latest one\r\n\t\t\tunit.data.goingToPointX=(tmpGoX+unit.data.goingToPointX)/2;\r\n\t\t\tunit.data.goingToPointY=(tmpGoY+unit.data.goingToPointY)/2;\r\n\t\t}// if\r\n\t}// if\r\n\t}\r\n\t// FOLLOWERS_TEST_END\r\n\r\n\t// set the rest of the goingToPoint stuff\r\n\tunit.data.goingToPoint=true;\r\n\tif (unit.data.isPosRelative){\r\n\t\t// correct the coordinates to be relative\r\n\t\tunit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\tunit.data.goingToPointY-=gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// set the speed for going to such point\r\n\tsetSpeedForLinealMove(&unit.data,\r\n\t\tunit.data.goingToPointX, unit.data.goingToPointY,\r\n\t\tunit.data.linearSpeed*0.8);\r\n\t\r\n\t// all ok\r\n\treturn true;\r\n}// carrierLinearMovementDoneEvent \r\n\r\n\r\n\r\n// carrierFinishUntouchabilityEvent *******\r\n// This is the code that carriers execute when they finish being\r\n// untouchable, while still being alive.\r\nbool carrierFinishUntouchabilityEvent(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)\r\n{\r\n\t// we used to change the frame at this place...\r\n\t// we don't do it anymore\r\n\t//genericUnitTypeDataStruct* myType=&(enemyType[unit.data.unitType]);\r\n\t//unit.data.currentFrame=myType->firstFrame;// normal frame\r\n\t// continue auto framing\r\n\t//unit.data.vFramesPassed=0;\r\n\r\n\t// do what's needed\r\n\tunit.data.trembling=false;// don't tremble anymore\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// carrierFinishUntouchabilityEvent\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"collisions.h\"// for functions related to the collisions of units\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"players.h\"// for managing the players\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n/*#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions*/\r\n\r\n// enemyUnitHit *******\r\n// This method is called every time an enemy unit is hit by anything.\r\n// Then, it's responsible of making all the necessary changes in the\r\n// touched enemy unit.\r\nbool enemyUnitHit(\r\n\tvectorListNodeStruct<enemyUnitStruct>& eUnit,// enemy unit which was hit\r\n\tgameObjectPointerStruct& toucher)// the one who touched the enemy unit\r\n{\r\n\tvectorListNodeStruct<playerUnitStruct>* player;\r\n\tvectorListNodeStruct<bulletUnitStruct>* bullet;\r\n\r\n\t// if this unit is in untouchable or dead state,\r\n\t// nothing can affect it now...\r\n\tif (eUnit.data.untouchableTimeLeft>0 || eUnit.data.energyLeft<=0)\r\n\t\treturn true;\r\n\r\n\t// first change the unit to untouchable state.\r\n\teUnit.data.untouchableTimeLeft=eUnit.data.untouchableTimeMax;\r\n\r\n\t// COLLISION REVISE LATER BEGIN\r\n\t// don't let it collide anymore\r\n\teUnit.data.canBeHitByBullets=false;\r\n\teUnit.data.canBeHitByPlayers=false;\r\n\t// COLLISION REVISE LATER END\r\n\r\n\tswitch (toucher.objectType){\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_PLAYER:\r\n\t\t// it's a player unit\r\n\t\tplayer=playerList.getNode(toucher.listIndex);\r\n\r\n\t\t// SCORING\r\n\t\t// increment the player score\r\n\t\tplayerIncrementScoreForHit(toucher, eUnit.data.scoreToGivePerHit);\r\n\r\n\t\t// ENERGY\r\n\t\t// Hurt the enemy unit\r\n\t\tif (eUnit.data.decrementableEnergy)\r\n\t\t\teUnit.data.energyLeft-=player->data.energyToDrop;\r\n\t\tif (eUnit.data.energyLeft<0) eUnit.data.energyLeft=0;\r\n\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_BULLET:\r\n\t\t// it's a bullet unit\r\n\t\tbullet=bulletList.getNode(toucher.listIndex);\r\n\r\n\t\t// SCORING\r\n\t\t// Increment the toucher player score\r\n\t\tif (bullet->data.owner.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_PLAYER){\r\n\r\n\t\t\t// increment the score of the player\r\n\t\t\t// who dropped the bullet\r\n\t\t\tif (!playerIncrementScoreForHit(\r\n\t\t\t\tbullet->data.owner,\r\n\t\t\t\teUnit.data.scoreToGivePerHit)) return false;\r\n\t\t}// if\r\n\r\n\t\t// ENERGY\r\n\t\t// Hurt the enemy unit\r\n\t\tif (eUnit.data.decrementableEnergy)\r\n\t\t\teUnit.data.energyLeft-=bullet->data.energyToDrop;\r\n\t\tif (eUnit.data.energyLeft<0) eUnit.data.energyLeft=0;\r\n\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// we aren't dead, but have been touched\r\n\tif (eUnit.data.untouchableTimeLeft>0){\r\n\t\tswitch(eUnit.data.unitType){\r\n\t\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\t\t\tswitch (eUnit.data.unitType){\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\t\t\teUnit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"headCarrierTouched\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\t\t\t\t// frame of touched\r\n\t\t\t\teUnit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"sheepCarrierTouched\");\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\r\n\t\t\teUnit.data.trembling=true;// and go tremble\r\n\t\t\t// continue auto framing\r\n\t\t\teUnit.data.vFramesPassed=0;\r\n\r\n\t\t\t// FREE SHEEPS (or heads)!\r\n\t\t\t// and it's time to let sheeps / heads go away\r\n\t\t\tif (eUnit.data.slaveUnit.objectType!=\r\n\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t\t\t// carried unit\r\n\t\t\t\tvectorListNodeStruct<enemyUnitStruct> *cunit;\r\n\r\n\t\t\t\t// we only know how to let enemies go away\r\n\t\t\t\tif (eUnit.data.slaveUnit.objectType!=\r\n\t\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_ENEMY) return false;\r\n\r\n\t\t\t\t// obtain the unit and check that's the one we need\r\n\t\t\t\tcunit=enemyList.getNode(\r\n\t\t\t\t\teUnit.data.slaveUnit.listIndex);\r\n\t\t\t\tif (cunit==NULL ||\r\n\t\t\t\t\tcunit->data.id!=eUnit.data.slaveUnit.id)\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t// free that unit\r\n\t\t\t\tif (!freeSlavesOf(&eUnit.data)) return false;\r\n\r\n\t\t\t\t// let the sheep fall\r\n\t\t\t\tif (!unitStartFalling(cunit->data)) return false;\r\n\t\t\t}// if\r\n\r\n\t\t\t// also, the touched unit now wants to escape fast!\r\n\t\t\teUnit.data.goingToPointX=eUnit.data.x-50;\r\n\t\t\teUnit.data.goingToPointY=0-\r\n\t\t\t\t\t(constructContainerFrame(&eUnit.data).h\r\n\t\t\t\t\t-constructContainerFrame(&eUnit.data).handlerY);\r\n\t\t\teUnit.data.goingToPoint=true;\r\n\t\t\tif (eUnit.data.isPosRelative){\r\n\t\t\t\t// correct the coordinates to be relative\r\n\t\t\t\teUnit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\t\t\teUnit.data.goingToPointY-=gameWorld.yCamera;\r\n\t\t\t}// if\r\n\t\t\t// set the speed for going to such point\r\n\t\t\tsetSpeedForLinealMove(&eUnit.data,\r\n\t\t\t\teUnit.data.goingToPointX, eUnit.data.goingToPointY,\r\n\t\t\t\teUnit.data.linearSpeed*1.5);\r\n\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// enemyUnitHit\r\n\r\n// playerUnitHit ******\r\n// This method is called every time a player unit is hit by anything.\r\n// Then, it's responsible of making all the necessary changes in the\r\n// touched player.\r\nbool playerUnitHit(\r\n\tvectorListNodeStruct<playerUnitStruct>& pUnit,// player unit which was hit\r\n\tgameObjectPointerStruct& toucher)// the one who touched the player unit\r\n{\r\n\tvectorListNodeStruct<enemyUnitStruct>* enemy;\r\n\tvectorListNodeStruct<playerUnitStruct>* player2;\r\n\tvectorListNodeStruct<bulletUnitStruct>* bullet;\r\n\r\n\t// for counting other players\r\n\tint counter;\r\n\tvectorListNodeStruct<playerUnitStruct> *extraPlayer;\r\n\r\n\t// if this unit is in untouchable or dead state,\r\n\t// nothing can affect it now...\r\n\tif (pUnit.data.untouchableTimeLeft>0 || pUnit.data.energyLeft<=0)\r\n\t\treturn true;\r\n\r\n\t// first change the unit to untouchable state.\r\n\tpUnit.data.untouchableTimeLeft=pUnit.data.untouchableTimeMax;\r\n\r\n\t// What kind of thing has hit against the player?\r\n\tswitch(toucher.objectType){\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_ENEMY:\r\n\t\t// it's an enemy unit\r\n\t\tenemy=enemyList.getNode(toucher.listIndex);\r\n\r\n\t\t// ENERGY\r\n\t\t// Hurt the player\r\n\t\t// calculate the damage\r\n\t\tif (pUnit.data.decrementableEnergy)\r\n\t\t\tpUnit.data.energyLeft-=enemy->data.energyToDrop;\r\n\t\tif (pUnit.data.energyLeft<0) pUnit.data.energyLeft=0;\r\n\r\n\t\tbreak;// toucher type\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_PLAYER:\r\n\t\t// it's a player unit\r\n\t\tplayer2=playerList.getNode(toucher.listIndex);\r\n\r\n\t\t// SCORING\r\n\t\t// Increment the toucher player score\r\n\t\tplayerIncrementScoreForHit(\r\n\t\t\ttoucher, pUnit.data.scoreToGivePerHit);\r\n\r\n\t\t// ENERGY\r\n\t\t// Hurt the player\r\n\t\t// calculate the damage\r\n\t\tif (pUnit.data.decrementableEnergy)\r\n\t\t\tpUnit.data.energyLeft-=player2->data.energyToDrop;\r\n\t\tif (pUnit.data.energyLeft<0) pUnit.data.energyLeft=0;\r\n\r\n\t\tbreak;// toucher type\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_BULLET:\r\n\t\t// it's a bullet unit\r\n\t\tbullet=bulletList.getNode(toucher.listIndex);\r\n\r\n\t\t// SCORING\r\n\t\t// Increment the toucher player score\r\n\t\tif (bullet->data.owner.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_PLAYER){\r\n\r\n\t\t\t// increment the score of the player\r\n\t\t\t// who dropped the bullet\r\n\t\t\tif (!playerIncrementScoreForHit(\r\n\t\t\t\tbullet->data.owner,\r\n\t\t\t\tpUnit.data.scoreToGivePerHit)) return false;\r\n\t\t}// if\r\n\r\n\t\t// ENERGY\r\n\t\t// Hurt the player\r\n\t\tif (pUnit.data.decrementableEnergy)\r\n\t\t\tpUnit.data.energyLeft-=bullet->data.energyToDrop;\r\n\t\tif (pUnit.data.energyLeft<0) pUnit.data.energyLeft=0;\r\n\r\n\t\tbreak;// toucher type\r\n\t}// switch unit type\r\n\r\n\t// check for death...\r\n\tif (pUnit.data.energyLeft<=0){\r\n\t\t// DEAD PLAYER\r\n\t\t// we are dead now...\r\n\r\n\t\t// set the player information for death\r\n\t\tswitch(pUnit.data.unitType){\r\n\t\tcase FILE_GAMEDATA_PLAYER_JAVATAR:\r\n\t\t\tpUnit.data.currentFrame=\r\n\t\t\t\tgetFrameIndexAndListByName(\"javatarDeath\");\r\n\t\t\t// continue auto framing\r\n\t\t\tpUnit.data.vFramesPassed=0;\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\r\n\t\t// dead people isn't untouchable neither unarmed\r\n\t\tpUnit.data.untouchableTimeLeft=0;\r\n\t\tpUnit.data.unarmedTimeLeft=0;\r\n\t\tpUnit.data.trembling=false;\r\n\r\n\t\t// dead players are supposed to fall\r\n\t\tpUnit.data.goingToPoint=true;\r\n\t\tpUnit.data.goingToPointX=110;\r\n\t\tpUnit.data.goingToPointY=\r\n\t\t\tgameWorld.yCamera-\r\n\t\t\t(20+constructContainerFrame(&pUnit.data).h)+\r\n\t\t\tconstructContainerFrame(&pUnit.data).handlerY;\r\n\t\tif (pUnit.data.isPosRelative){\r\n\t\t\t// correct the coordinates to be relative\r\n\t\t\tpUnit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\t\tpUnit.data.goingToPointY-=gameWorld.yCamera;\r\n\t\t}// if\r\n\t\tsetSpeedForLinealMove(\r\n\t\t\t&pUnit.data,// player unit\r\n\t\t\tpUnit.data.goingToPointX, pUnit.data.goingToPointY,// dest pos\r\n\t\t\t160/double(desiredFramesPerSecond));// linear speed\r\n\r\n\t\t// EXTRA STUFF FOR DEAD PLAYER\r\n\t\t// set some extra stuff, interesting for dead players\r\n\t\t// firstly check it's the only player\r\n\t\t// Count the active players\r\n\t\tfor (extraPlayer=playerList.getFirstNode(), counter=0;\r\n\t\textraPlayer!=NULL;\r\n\t\textraPlayer=playerList.getNextNode(extraPlayer)){\r\n\t\t\t// don't count inactive units, neither this unit, neither\r\n\t\t\t// those that haven't any more energy (so they are dying\r\n\t\t\t// right now)\r\n\t\t\tif (!extraPlayer->data.nowActive ||\r\n\t\t\t\textraPlayer->data.id==pUnit.data.id ||\r\n\t\t\t\textraPlayer->data.energyLeft<=0)\r\n\t\t\t\tcontinue;\r\n\t\t\tcounter++;\r\n\t\t}// for\r\n\t\tif (counter<=0 && !gameWorld.showGameOverMessage){\r\n\t\t\t// there are no other alive players, do what's needed\r\n\r\n\t\t\t// A game over message should be shown\r\n\t\t\tgameWorld.showGameOverMessage=true;\r\n\r\n\t\t\t// Scream the game over thing\r\n/*\t\t\tmakeSoundGameOver();*/\r\n\t\t}// if\r\n\r\n\t\t// Execute the sound of the player being death...\r\n/*\t\tmakeSoundProtagKilled();*/\r\n\t}else{\r\n\t\t// PLAYER TOUCHED (not dead)\r\n\t\t// we aren't dead, but have been touched\r\n\t\tif (pUnit.data.untouchableTimeLeft>0){\r\n\t\t\tswitch(pUnit.data.unitType){\r\n\t\t\tcase FILE_GAMEDATA_PLAYER_JAVATAR:\r\n\t\t\t\tpUnit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"javatarTouched\");\r\n\t\t\t\tpUnit.data.trembling=true;// and go tremble\r\n\t\t\t\t// continue auto framing\r\n\t\t\t\tpUnit.data.vFramesPassed=0;\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\t\t}// if\r\n\r\n/*\t\t// Execute the sound of the player being touched...\r\n\t\tmakeSoundProtagTouched();*/\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// playerUnitHit\r\n\r\n// bulletUnitHit *******\r\n// This method is called every time a bullet unit is hit by anything.\r\n// Then, it's responsible of making all the necessary changes in the\r\n// touched bullet unit.\r\nbool bulletUnitHit(\r\n\tvectorListNodeStruct<bulletUnitStruct>& bUnit,// enemy unit which was hit\r\n\tgameObjectPointerStruct& toucher)// the one who touched the enemy unit\r\n{\r\n\tbool wasToucherAWall=false;\r\n\r\n\tif (bUnit.data.nowExploding){\r\n\t\t// it's already exploding, it hasn't to do anything different\r\n\t\t// once it's touched\r\n\t\treturn true;\r\n\t}// if\r\n\r\n\tswitch (toucher.objectType){\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_ENEMY:\r\n\t\t// do the sound of the bullet hitting an enemy\r\n/*\t\tmakeSoundFlameBulletHitEnemy();*/\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_PLAYER:\r\n\t\t// There is nothing to do here\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_BULLET:\r\n\t\t// There is nothing to do here\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_VIRTUALWALL:\r\n\t\t// do the sound of the bullet hitting a wall\r\n/*\t\tmakeSoundFlameBulletHitWall();*/\r\n\r\n\t\t// remember it was a wall\r\n\t\twasToucherAWall=true;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// Now it's time for this bullet to start his explosion.\r\n\tbUnit.data.currentFrame=\r\n\t\tgetFrameIndexAndListByName(\"flameBulletExploding\");\r\n\t// continue auto framing\r\n\tbUnit.data.vFramesPassed=0;\r\n\r\n\tif (false){\r\n\t\t// The exploding bullet can't move but can keep colliding\r\n\t\tbUnit.data.speedX=0;\r\n\t\tbUnit.data.speedY=0;\r\n\t\tbUnit.data.goingToPoint=false;\r\n\t\t// the unit is now marked as 'exploding'\r\n\t\tbUnit.data.nowExploding=true;\r\n\t}else{\r\n\t\t// we want the bullet to stop colliding with other units\r\n\t\tbUnit.data.canCollideWithBullets=false;\r\n\t\tbUnit.data.canCollideWithEnemies=false;\r\n\t\tbUnit.data.canCollideWithPlayers=false;\r\n\r\n\t\t// the bullet now goes away\r\n\t\tbUnit.data.goingToPointX=bUnit.data.x\r\n\t\t\t-(wasToucherAWall?200:70);\r\n\t\tbUnit.data.goingToPointY=0-\r\n\t\t\t(constructContainerFrame(&bUnit.data).h\r\n\t\t\t-constructContainerFrame(&bUnit.data).handlerY);\r\n\t\tbUnit.data.goingToPoint=true;\r\n\t\tif (bUnit.data.isPosRelative){\r\n\t\t\t// correct the coordinates to be relative\r\n\t\t\tbUnit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\t\tbUnit.data.goingToPointY-=gameWorld.yCamera;\r\n\t\t}// if\r\n\t\t// set the speed for going to such point\r\n\t\tsetSpeedForLinealMove(&bUnit.data,\r\n\t\t\tbUnit.data.goingToPointX, bUnit.data.goingToPointY,\r\n\t\t\t260/double(desiredFramesPerSecond));\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// bulletUnitHit\r\n\r\n// checkCollisions *******\r\n// Check the collisions between all the game objects..\r\nbool checkCollisions()\r\n{\r\n\t// Nodes lists\r\n\tvectorListNodeStruct<enemyUnitStruct>* node;\r\n\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\tvectorListNodeStruct<playerUnitStruct>* nodeP2;\r\n\tvectorListNodeStruct<bulletUnitStruct>* nodeB;\r\n\tvectorListNodeStruct<bulletUnitStruct>* nodeB2;\r\n\t\r\n\t// Unit types\r\n\tgenericUnitTypeDataStruct* myEnemyType;\r\n\tgenericUnitTypeDataStruct* myPlayerType;\r\n\tgenericUnitTypeDataStruct* myPlayerType2;\r\n\tgenericUnitTypeDataStruct* myBulletType;\r\n\tgenericUnitTypeDataStruct* myBulletType2;\r\n\r\n\t// Unit frames\r\n\tframeDataStruct* myEnemyFrame;\r\n\tframeDataStruct* myPlayerFrame;\r\n\tframeDataStruct* myPlayerFrame2;\r\n\tframeDataStruct* myBulletFrame;\r\n\tframeDataStruct* myBulletFrame2;\r\n\r\n\t// the rectangles of collision\r\n\tint pX, pY, pX2, pY2;// player unit, or rather first unit\r\n\tint eX, eY, eX2, eY2;// enemy unit, or rather second unit\r\n\r\n\t// other stuff\r\n\tgameObjectPointerStruct objPointer;\r\n\r\n\r\n\t// COLLISIONS PLAYER vs. ENEMIES and PLAYERS\r\n\t// for every player\r\n\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t// don't check this unit if it's not active now\r\n\t\tif (!nodeP->data.nowActive) continue;\r\n\r\n\t\t// load the player data\r\n\t\tmyPlayerType=&(playerType[nodeP->data.unitType]);\r\n\t\tmyPlayerFrame=&(myPlayerType->frames[nodeP->data.currentFrame]);\r\n\t\tpX=myPlayerFrame->cX-myPlayerFrame->handlerX+(int)(nodeP->data.x);\r\n\t\tpY=myPlayerFrame->cY-myPlayerFrame->handlerY+(int)(nodeP->data.y);\r\n\t\tpX2=pX+myPlayerFrame->cW-1; pY2=pY+myPlayerFrame->cH-1;\r\n\r\n\t\t// COLLISIONS PLAYER vs. ENEMIES\r\n\t\t// for every enemy\r\n\t\tfor (node=enemyList.getFirstNode(); node!=NULL; node=enemyList.getNextNode(node)){\r\n\t\t\t// don't check this unit if it's not active now\r\n\t\t\tif (!node->data.nowActive) continue;\r\n\r\n\t\t\t// check for the validity of such collision\r\n\t\t\tif (!node->data.canBeHitByPlayers) continue;\r\n\r\n\t\t\t// load the enemy data\r\n\t\t\tmyEnemyType=&(enemyType[node->data.unitType]);\r\n\t\t\tmyEnemyFrame=&(myEnemyType->frames[node->data.currentFrame]);\r\n\t\t\teX=myEnemyFrame->cX-myEnemyFrame->handlerX+(int)(node->data.x);\r\n\t\t\teY=myEnemyFrame->cY-myEnemyFrame->handlerY+(int)(node->data.y);\r\n\t\t\teX2=eX+myEnemyFrame->cW-1; eY2=eY+myEnemyFrame->cH-1;\r\n\r\n\t\t\t// check for intersecting rectangles\r\n\t\t\tif (INTERSECTING_NOTNULL_RECTANGLES\r\n\t\t\t\t(pX, pY, pX2, pY2, eX, eY, eX2, eY2)){\r\n\r\n\t\t\t\t// Notify both the enemy and the player unit...\r\n\r\n\t\t\t\t// Enemy\r\n\t\t\t\t// Load objPointer with info about the player\r\n\t\t\t\tobjPointer.id=nodeP->data.id;\r\n\t\t\t\tobjPointer.listIndex=playerList.getIndex(nodeP);\r\n\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;\r\n\t\t\t\t// Notice the enemy unit\r\n\t\t\t\tif (!enemyUnitHit(*node, objPointer))\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t// Player\r\n\t\t\t\t// Load objPointer with info about the enemy\r\n\t\t\t\tobjPointer.id=node->data.id;\r\n\t\t\t\tobjPointer.listIndex=enemyList.getIndex(node);\r\n\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_ENEMY;\r\n\t\t\t\t// Notice the player unit\r\n\t\t\t\tif (!playerUnitHit(*nodeP, objPointer))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// for node\r\n\r\n\t\t// COLLISIONS PLAYER vs. PLAYERS\r\n\t\t// for every player\r\n\r\n\t\tfor (nodeP2=playerList.getFirstNode(); nodeP2!=NULL; nodeP2=playerList.getNextNode(nodeP2)){\r\n\t\t\t// don't check this unit if it's not active now\r\n\t\t\tif (!nodeP2->data.nowActive) continue;\r\n\r\n\t\t\t// don't check it either if it's the same that nodeP\r\n\t\t\tif (nodeP==nodeP2) continue;\r\n\r\n\t\t\t// load the player data\r\n\t\t\tmyPlayerType2=&(playerType[nodeP2->data.unitType]);\r\n\t\t\tmyPlayerFrame2=&(myPlayerType2->frames[nodeP2->data.currentFrame]);\r\n\t\t\teX=myPlayerFrame2->cX-myPlayerFrame2->handlerX+(int)(nodeP2->data.x);\r\n\t\t\teY=myPlayerFrame2->cY-myPlayerFrame2->handlerY+(int)(nodeP2->data.y);\r\n\t\t\teX2=eX+myPlayerFrame2->cW-1; eY2=eY+myPlayerFrame2->cH-1;\r\n\r\n\t\t\t// check for intersecting rectangles\r\n\t\t\tif (INTERSECTING_NOTNULL_RECTANGLES\r\n\t\t\t\t(pX, pY, pX2, pY2, eX, eY, eX2, eY2)){\r\n\r\n\t\t\t\t// Notify both player units...\r\n\r\n\t\t\t\t// Player 1\r\n\t\t\t\t// Load objPointer with info about the player 2\r\n\t\t\t\tobjPointer.id=nodeP2->data.id;\r\n\t\t\t\tobjPointer.listIndex=playerList.getIndex(nodeP2);\r\n\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;\r\n\t\t\t\t// Notice the first player unit\r\n\t\t\t\tif (!playerUnitHit(*nodeP, objPointer))\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t// Player 2\r\n\t\t\t\t// Load objPointer with info about the player 1\r\n\t\t\t\tobjPointer.id=nodeP->data.id;\r\n\t\t\t\tobjPointer.listIndex=playerList.getIndex(nodeP);\r\n\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;\r\n\t\t\t\t// Notice the second player unit\r\n\t\t\t\tif (!playerUnitHit(*nodeP2, objPointer))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// for nodeP2\r\n\t}// for nodeP\r\n\r\n\t// COLLISIONS BULLETS vs. ENEMIES, PLAYERS and BULLETS\r\n\t// for every bullet\r\n\tfor (nodeB=bulletList.getFirstNode(); nodeB!=NULL; nodeB=bulletList.getNextNode(nodeB)){\r\n\t\t// don't check this unit if it's not active now\r\n\t\tif (!nodeB->data.nowActive) continue;\r\n\r\n\t\t// load the bullet data\r\n\t\tmyBulletType=&(bulletType[nodeB->data.unitType]);\r\n\t\tmyBulletFrame=&(myBulletType->frames[nodeB->data.currentFrame]);\r\n\t\tpX=myBulletFrame->cX-myBulletFrame->handlerX+(int)(nodeB->data.x);\r\n\t\tpY=myBulletFrame->cY-myBulletFrame->handlerY+(int)(nodeB->data.y);\r\n\t\tpX2=pX+myBulletFrame->cW-1; pY2=pY+myBulletFrame->cH-1;\r\n\r\n\t\t// COLLISIONS BULLET vs. PLAYERS\r\n\t\tif (nodeB->data.canCollideWithPlayers){\r\n\t\t\t// for every player\r\n\t\t\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t\t\t// don't check this unit if it's not active now\r\n\t\t\t\tif (!nodeP->data.nowActive) continue;\r\n\r\n\t\t\t\t// load the player data\r\n\t\t\t\tmyPlayerType=&(playerType[nodeP->data.unitType]);\r\n\t\t\t\tmyPlayerFrame=&(myPlayerType->frames[nodeP->data.currentFrame]);\r\n\t\t\t\teX=myPlayerFrame->cX-myPlayerFrame->handlerX+(int)(nodeP->data.x);\r\n\t\t\t\teY=myPlayerFrame->cY-myPlayerFrame->handlerY+(int)(nodeP->data.y);\r\n\t\t\t\teX2=eX+myPlayerFrame->cW-1; eY2=eY+myPlayerFrame->cH-1;\r\n\r\n\t\t\t\t// check for intersecting rectangles\r\n\t\t\t\tif (INTERSECTING_NOTNULL_RECTANGLES\r\n\t\t\t\t\t(pX, pY, pX2, pY2, eX, eY, eX2, eY2)){\r\n\r\n\t\t\t\t\t// Check for collisions with the owner\r\n\t\t\t\t\tif (!nodeB->data.canCollideWithTheOwner &&\r\n\t\t\t\t\t\tnodeB->data.owner.id==nodeP->data.id)\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t// Notify both units...\r\n\r\n\t\t\t\t\t// Bullet\r\n\t\t\t\t\t// Load objPointer with info about the player\r\n\t\t\t\t\tobjPointer.id=nodeP->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=playerList.getIndex(nodeP);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;\r\n\t\t\t\t\t// Notice the bullet unit\r\n\t\t\t\t\tif (!bulletUnitHit(*nodeB, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t// Player\r\n\t\t\t\t\t// Load objPointer with info about the bullet\r\n\t\t\t\t\tobjPointer.id=nodeB->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=bulletList.getIndex(nodeB);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_BULLET;\r\n\t\t\t\t\t// Notice the player unit\r\n\t\t\t\t\tif (!playerUnitHit(*nodeP, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}// if\r\n\t\t\t}// for nodeP\r\n\t\t}// if\r\n\r\n\t\t// COLLISIONS BULLET vs. ENEMIES\r\n\t\tif (nodeB->data.canCollideWithEnemies){\r\n\t\t\t// for every enemy\r\n\t\t\tfor (node=enemyList.getFirstNode(); node!=NULL; node=enemyList.getNextNode(node)){\r\n\t\t\t\t// don't check this unit if it's not active now\r\n\t\t\t\tif (!node->data.nowActive) continue;\r\n\r\n\t\t\t\t// check for the validity of such collision\r\n\t\t\t\tif (!node->data.canBeHitByBullets) continue;\r\n\r\n\t\t\t\t// load the enemy data\r\n\t\t\t\tmyEnemyType=&(enemyType[node->data.unitType]);\r\n\t\t\t\tmyEnemyFrame=&(myEnemyType->frames[node->data.currentFrame]);\r\n\t\t\t\teX=myEnemyFrame->cX-myEnemyFrame->handlerX+(int)(node->data.x);\r\n\t\t\t\teY=myEnemyFrame->cY-myEnemyFrame->handlerY+(int)(node->data.y);\r\n\t\t\t\teX2=eX+myEnemyFrame->cW-1; eY2=eY+myEnemyFrame->cH-1;\r\n\r\n\t\t\t\t// check for intersecting rectangles\r\n\t\t\t\tif (INTERSECTING_NOTNULL_RECTANGLES\r\n\t\t\t\t\t(pX, pY, pX2, pY2, eX, eY, eX2, eY2)){\r\n\r\n\t\t\t\t\t// Check for collisions with the owner\r\n\t\t\t\t\tif (!nodeB->data.canCollideWithTheOwner &&\r\n\t\t\t\t\t\tnodeB->data.owner.id==node->data.id)\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t// Notify both units...\r\n\r\n\t\t\t\t\t// Bullet\r\n\t\t\t\t\t// Load objPointer with info about the enemy\r\n\t\t\t\t\tobjPointer.id=node->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=enemyList.getIndex(node);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_ENEMY;\r\n\t\t\t\t\t// Notice the bullet unit\r\n\t\t\t\t\tif (!bulletUnitHit(*nodeB, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t// Enemy\r\n\t\t\t\t\t// Load objPointer with info about the bullet\r\n\t\t\t\t\tobjPointer.id=nodeB->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=bulletList.getIndex(nodeB);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_BULLET;\r\n\t\t\t\t\t// Notice the enemy unit\r\n\t\t\t\t\tif (!enemyUnitHit(*node, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}// if\r\n\t\t\t}// for node\r\n\t\t}// if\r\n\r\n\t\t// COLLISIONS BULLET vs. BULLETS\r\n\t\tif (nodeB->data.canCollideWithBullets){\r\n\t\t\t// for every bullet\r\n\t\t\tfor (nodeB2=bulletList.getFirstNode(); nodeB2!=NULL; nodeB2=bulletList.getNextNode(nodeB2)){\r\n\t\t\t\t// don't check this unit if it's not active now\r\n\t\t\t\tif (!nodeB2->data.nowActive) continue;\r\n\r\n\t\t\t\t// don't check it if it's the same that nodeB\r\n\t\t\t\tif (nodeB==nodeB2) continue;\r\n\r\n\t\t\t\t// load the bullet data\r\n\t\t\t\tmyBulletType2=&(bulletType[nodeB2->data.unitType]);\r\n\t\t\t\tmyBulletFrame2=&(myBulletType2->frames[nodeB2->data.currentFrame]);\r\n\t\t\t\teX=myBulletFrame2->cX-myBulletFrame2->handlerX+(int)(nodeB2->data.x);\r\n\t\t\t\teY=myBulletFrame2->cY-myBulletFrame2->handlerY+(int)(nodeB2->data.y);\r\n\t\t\t\teX2=eX+myBulletFrame2->cW-1; eY2=eY+myBulletFrame2->cH-1;\r\n\r\n\t\t\t\t// check for intersecting rectangles\r\n\t\t\t\tif (INTERSECTING_NOTNULL_RECTANGLES\r\n\t\t\t\t\t(pX, pY, pX2, pY2, eX, eY, eX2, eY2)){\r\n\r\n\t\t\t\t\t// Notify both units...\r\n\r\n\t\t\t\t\t// Bullet 1\r\n\t\t\t\t\t// Load objPointer with info about second bullet\r\n\t\t\t\t\tobjPointer.id=nodeB2->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=bulletList.getIndex(nodeB2);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_BULLET;\r\n\t\t\t\t\t// Notice the bullet unit\r\n\t\t\t\t\tif (!bulletUnitHit(*nodeB, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t// Bullet 2\r\n\t\t\t\t\t// Load objPointer with info about the first bullet\r\n\t\t\t\t\tobjPointer.id=nodeB->data.id;\r\n\t\t\t\t\tobjPointer.listIndex=bulletList.getIndex(nodeB);\r\n\t\t\t\t\tobjPointer.objectType=FILE_GAMEDATA_GAMEOBJECT_BULLET;\r\n\t\t\t\t\t// Notice the bullet unit\r\n\t\t\t\t\tif (!bulletUnitHit(*nodeB2, objPointer))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}// if\r\n\t\t\t}// for nodeB2\r\n\t\t}// if\r\n\t}// for nodeB\r\n\r\n\treturn true;// all ok\r\n}// checkCollisions\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n// Con-logger is used for logging, both to a file and to a \"console.*\"\r\n// console (if there is any).\r\n\r\n#include \"con-logger.h\"\r\n#include <string.h>// for strcpy\r\n#include <stdio.h>// for files\r\n#include <stdarg.h>// for multiple arguments and _vsnprintf\r\n\r\n// initializes the conLogger object\r\nbool conLoggerClass::init(\r\n\tchar* name,// name of the file to select, null for no one yet\r\n\tconsoleClass* console,// pointer to the console object, null for no one yet\r\n\tint bytesBufferName,// amount of bytes to be reserved for the file name\r\n\tint bytesStrBuffer)// amount of bytes to be reserved for the string buffer\r\n{\r\n/*\tif (initialized) return false;\r\n\r\n\t// initialize the data\r\n\tfileReady=false;\r\n\tfileName=new char[bytesBufferName];\r\n\tstrBufferSize=bytesStrBuffer;\r\n\tstrBuffer=new char[strBufferSize];\r\n\r\n\t// set the flag before using selectFile and attachConsole\r\n\tinitialized=true;\r\n\r\n\tif (!selectFile(name) || !attachConsole(console)){\r\n\t\t// something failed\r\n\t\tdelete[] fileName;\r\n\t\tdelete[] strBuffer;\r\n\t\tinitialized=false;\r\n\t\treturn false;\r\n\t}// if\r\n*/\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// end the use of this object\r\nbool conLoggerClass::end()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// time to free this\r\n\tdelete[] fileName;\r\n\tdelete[] strBuffer;\r\n\tinitialized=false;\r\n*/\r\n\treturn true;// all ok\r\n}// end\r\n\r\n// attaches a console for logging\r\nbool conLoggerClass::attachConsole(consoleClass* console)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// attach the console itself\r\n\tconPtr=console;\r\n*/\r\n\treturn true;// all ok\r\n}// attachConsole\r\n\r\n// select a file where to log in\r\n// if name is NULL, it selects nothing\r\nbool conLoggerClass::selectFile(char* name)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\tif (name!=NULL){\r\n\t\tstrcpy(fileName, name);\r\n\t\tfileReady=true;\r\n\t}else\r\n\t\tfileReady=false;// select nothing\r\n*/\r\n\treturn true;// all ok\r\n}// selectFile\r\n\r\n// Log a text line to the selected file.\r\n// If there is no selected file, return error only if noUnselError\r\n// is false (meaning it has to be seen as an error).\r\nbool conLoggerClass::logToFile(char* text, bool noUnselError)\r\n{\r\n/*\tFILE* file;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// is a file selected\r\n\tif (!fileReady){\r\n\t\t// we won't be able to write anything...\r\n\t\t// should we return an error code?\r\n\t\tif (noUnselError) return true;// no\r\n\t\treturn false;// yes\r\n\t}// if\r\n\r\n\t// open for writing, binary appending\r\n\tfile=fopen(fileName, \"a+b\");\r\n\tif (file==NULL){\r\n\t\treturn false;// failed the opening\r\n\t}\r\n\r\n\t// write the text...\r\n\tfwrite(text, 1, strlen(text), file);\r\n\r\n\t// write the newline\r\n\tfwrite(\"\\x00D\\x00A\", 1, 2, file);\r\n\r\n\t// time to close the file\r\n\tfclose(file);\r\n*/\r\n\treturn true;// all ok\r\n}// logToFile\r\n\r\n// Log a text line to the selected console.\r\n// If there is no selected console, return error only if noUnselError\r\n// is false (meaning it has to be seen as an error).\r\nbool conLoggerClass::logToConsole(char* text, bool noUnselError)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// is a console attached?\r\n\tif (conPtr==NULL){\r\n\t\t// we won't be able to write anything...\r\n\t\t// should we return an error code?\r\n\t\tif (noUnselError) return true;// no\r\n\t\treturn false;// yes\r\n\t}// if\r\n\r\n\t// now log our text\r\n\tif (!conPtr->writeLine(text)) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// logToConsole\r\n\r\n// Log a text line to the selected console or file (or both, or no one).\r\n// If there is no selected console or file, return error only if\r\n// noUnselError is false (meaning it has to be seen as an error).\r\nbool conLoggerClass::logLine(\r\n\tchar* text,// text to log\r\n\tbool file,// log to file?\r\n\tbool console,// log to console?\r\n\tbool noUnselError,// return an error if those are unselected?\r\n\t...// that's for the printf like params\r\n){\r\n\tva_list paramList;\r\n\tva_start(paramList, noUnselError);\r\n\tvprintf(text, paramList);// NEW 2010\r\n\tprintf(\"\\n\");\r\n\tva_end(paramList);\r\n\r\n/*\tbool failed=false;\r\n\tva_list paramList;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// get the first param of the list\r\n\tva_start(paramList, noUnselError);\r\n\r\n\t// let's compose the string\r\n\t// We decrement strBufferSize in one, because\r\n\t// we want _vsnprintf to keep a byte for the 0.\r\n\t// I guess it happens because, for vsnprintf, the last zero is\r\n\t// wrote only if it's able to, without taking it as an error if it's\r\n\t// not able to do it.\r\n\tif (_vsnprintf(\r\n\t\tstrBuffer,// storage for the final string\r\n\t\tstrBufferSize-1,// size of the buffer (keeping a space for the 0)\r\n\t\ttext,// format string\r\n\t\tparamList// list of parameters\r\n\t\t)<0) return false;// it means error\r\n\r\n\t// add the zero if necessary\r\n\tstrBuffer[strBufferSize-1]=0;\r\n\r\n\t// we won't use the param list anymore\r\n\tva_end(paramList);\r\n\r\n\t// log to console first\r\n\tif (console){\r\n\t\tif (!logToConsole(strBuffer, noUnselError)) failed=true;\r\n\t}// if\r\n\r\n\t// log to file\r\n\tif (file){\r\n\t\tif (!logToFile(strBuffer, noUnselError)) failed=true;\r\n\t}// if\r\n\r\n\t// did it fail?\r\n\tif (failed) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// logLine\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n// Console.* uses \"scrollTextClass\" to make a very useful console\r\n// work.\r\n\r\n#include \"console.h\"\r\n#include <string.h>\r\n\r\n// Set up the console for this program\r\nbool consoleClass::init(int width, int height, int maxLetters)\r\n{\r\n/*\tif (initialized) return false;\r\n\r\n\tif (!scroll.init(width, height, 255, 255, 255, 100, 100, 100))\r\n\t\treturn false;\r\n\r\n\t// initialize all the variables involved\r\n\tmaxChars=maxLetters;\r\n\tlastLine=new char[maxChars];// used for storing the command line\r\n\ttextParam=new char[maxChars];// used for getting text params\r\n\tlastLine[0]=0;\r\n\tcurrentLetter=0;\r\n\tnextParam=0;\r\n\tlastLineBuffered=false;// there is no text to be buffered there\r\n\tinitialized=true;\r\n*/\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// Ends the use of the console\r\nbool consoleClass::end()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\tdelete[] lastLine;\r\n\tdelete[] textParam;\r\n\tinitialized=false;\r\n*/\r\n\treturn scroll.end();\r\n}// end\r\n\r\n// Used when a key is pressed\r\nbool consoleClass::keyUp(char key)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// reset the address of the next param to be read\r\n\tnextParam=0;\r\n\r\n\t// every time a key is pressed, it means the buffer is working\r\n\t// with the current text line... so, the last one is no more\r\n\t// buffered\r\n\tlastLineBuffered=false;\r\n\r\n\tswitch(key){\r\n\tcase '\\r':// line break\r\n\t\t// let's see if this line isn't a blank one\r\n\t\tif (currentLetter==0){\r\n\t\t\t// it's blank, then let's clear the buffer by\r\n\t\t\t// putting the zero to the string\r\n\t\t\tlastLine[currentLetter]=0;\r\n\t\t}// if\r\n\r\n\t\t// we change it because the buffer (lastLine) currently contains\r\n\t\t// the oldest line, and not the void one that appears when\r\n\t\t// you press enter.\r\n\t\tlastLineBuffered=true;\r\n\r\n\t\t// scroll once\r\n\t\tif (!scroll.scrollLines(1)) return false;\r\n\r\n\t\t// go back to the beginning of the line\r\n\t\tcurrentLetter=0;\r\n\r\n\t\tbreak;\r\n\tcase '\\b':// backspace\r\n\t\tif (currentLetter>0) currentLetter--;\r\n\r\n\t\tbreak;\r\n\tdefault:// some common letter\r\n\t\tif (currentLetter<maxChars-1){\r\n\t\t\t// it's a common letter, add it to the latest line\r\n\t\t\tlastLine[currentLetter]=key;\r\n\t\t\tcurrentLetter++;\r\n\t\t}// if\r\n\r\n\t\tbreak;\r\n\t}// switch\r\n\t\r\n\t// check... it's not supposed to change a buffered old line\r\n\t// anyway, when there is a buffered old line, it means current one\r\n\t// is empty.\r\n\tif (!lastLineBuffered){\r\n\t\t// put the zero to the string\r\n\t\tlastLine[currentLetter]=0;\r\n\r\n\t\t// write the latest line\r\n\t\tif (!scroll.writeLatestLine(lastLine)) return false;\r\n\t}// if\r\n*/\r\n\treturn true;// all ok\r\n}// keyUp\r\n\r\n\r\n// Draws the console in a surface\r\nbool consoleClass::draw(ddSurfaceClass& srf, int x, int y)\r\n{\r\n\tif (!initialized) return false;\r\n\r\n\tif (!scroll.blt(srf, x, y)) return false;\r\n\r\n\treturn true;// all ok\r\n}// draw\r\n\r\n// Writes a line of text on the scrolling surface.\r\n// It doesn't modify the command line at all, and writes it (the\r\n// command line) again as the last line.\r\n// It helps keep the text typed by the user, always as the last line.\r\nbool consoleClass::writeLine(char* text)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// write the line (only if it's not void), and then scroll up\r\n\t// once\r\n\tif (text[0]!=0)\r\n\t\tif (!scroll.writeLatestLine(text)) return false;\r\n\r\n\tif (!scroll.scrollLines(1)) return false;\r\n\r\n\t// update the last line, with the text typed by the user until now,\r\n\t// only if it contains useful info\r\n\tif (lastLine[0]!=0 && lastLineBuffered==false)\r\n\t\tif (!scroll.writeLatestLine(lastLine)) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// writeLine\r\n\r\n// Skip all the spaces between params, and make the nextParam point\r\n// to the next non-space character. If it finds any zero there, it\r\n// makes nextParam point to the zero, and returns false (error).\r\n// It's a private method.\r\nbool consoleClass::skipSpaces()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// we only can work with params if the text in lastText is the\r\n\t// latest text typed (meaning a break line has just been pressed)\r\n\tif (!lastLineBuffered) return false;\r\n\r\n\t// skip the spaces\r\n\twhile (lastLine[nextParam]==' ') nextParam++;\r\n\r\n\t// error if the string ends there\r\n\tif (lastLine[nextParam]==0) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// skipSpaces\r\n\r\n// Points char* param to a zero ended string containing the name of\r\n// the first parameter (since the latest one read)... If no more params\r\n// are available, returns false (error). Spaces are skipped.\r\n// Integers are also parsed into a string.\r\n//\r\n// This stringZ is very volatile, it could become garbage as soon as\r\n// another method of consoleClass is executed. That is, if you need to\r\n// save this string somewhere, you have to copy it anywhere else to be\r\n// sure it will last.\r\nbool consoleClass::getTextParam(char* &param)\r\n{\r\n/*\tchar *src, *dst;// source and destine strings\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// we only can work with params if the text in lastText is the\r\n\t// latest text typed (meaning a break line has just been pressed)\r\n\tif (!lastLineBuffered) return false;\r\n\r\n\t// skip the spaces, and check for zero.\r\n\tif (!skipSpaces()) return false;\r\n\r\n\t// reset the pointers\r\n\tsrc=lastLine+nextParam;\r\n\tdst=textParam;\r\n\r\n\t// copy the param to its temp location\r\n\twhile (*src!=' ' && *src!=0){\r\n\t\t*dst=*src;\r\n\t\tdst++; src++; nextParam++;\r\n\t}// while\r\n\r\n\t// return the string\r\n\t*dst=0;\r\n\tparam=textParam;\r\n*/\r\n\treturn true;// all ok\r\n}// getTextParam\r\n\r\n// Changes int param to have the value of the first parameter (since\r\n// the latest one read)... If no more integer params\r\n// are available, returns false (error). Spaces are skipped.\r\nbool consoleClass::getIntegerParam(int &param)\r\n{\r\n/*\tint number=0;\r\n\tchar* src;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// we only can work with params if the text in lastText is the\r\n\t// latest text typed (meaning a break line has just been pressed)\r\n\tif (!lastLineBuffered) return false;\r\n\r\n\t// skip the spaces, and check for zero.\r\n\tif (!skipSpaces()) return false;\r\n\r\n\t// reset the pointer\r\n\tsrc=lastLine+nextParam;\r\n\r\n\t// read the number\r\n\twhile (*src!=' ' && *src!=0){\r\n\t\t// fail if it's not a digit\r\n\t\tif (*src<'0' || *src>'9') return false;\r\n\r\n\t\t// add it to the number\r\n\t\tnumber=number*10+(*src-'0');\r\n\r\n\t\tsrc++; nextParam++;\r\n\t}// while\r\n\r\n\t// return the right number\r\n\tparam=number;\r\n*/\r\n\treturn true;// all ok\r\n}// getIntegerParam\r\n\r\n// Points char* param to a zero ended string containing the name of\r\n// the first parameter (since the latest one read)... If no more params\r\n// are available, returns false (error). Spaces are skipped.\r\n// Integers are also parsed into a string.\r\n// IMPORTANT:\r\n// This method does only get a 0 char as an indicator of param\r\n// finalization, if you want to finish reading a param when a\r\n// space character is encountered, use getTextParam instead.\r\n//\r\n// This stringZ is very volatile, it could become garbage as soon as\r\n// another method of consoleClass is executed. That is, if you need to\r\n// save this string somewhere, you have to copy it anywhere else to be\r\n// sure it will last.\r\nbool consoleClass::getNoSpacedTextParam(char* &param)\r\n{\r\n/*\tchar *src, *dst;// source and destine strings\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// we only can work with params if the text in lastText is the\r\n\t// latest text typed (meaning a break line has just been pressed)\r\n\tif (!lastLineBuffered) return false;\r\n\r\n\t// skip the spaces, and check for zero.\r\n\tif (!skipSpaces()) return false;\r\n\r\n\t// reset the pointers\r\n\tsrc=lastLine+nextParam;\r\n\tdst=textParam;\r\n\r\n\t// copy the param to its temp location\r\n\twhile (*src!=0){\r\n\t\t*dst=*src;\r\n\t\tdst++; src++; nextParam++;\r\n\t}// while\r\n\r\n\t// return the string\r\n\t*dst=0;\r\n\tparam=textParam;\r\n*/\r\n\treturn true;// all ok\r\n}// getNoSpacedTextParam\r\n\r\n// It sets the param pointer to zero, useful for reading the param\r\n// line more than once.\r\nbool consoleClass::resetParamPointer()\r\n{\r\n\t// do it\r\n//\tnextParam=0;\r\n\r\n\treturn true;// all ok, always\r\n}// resetParamPointer\r\n\r\n// It clears the surface of the console (as if there is no text there)\r\nbool consoleClass::clear()\r\n{\r\n\t// clear the surface\r\n\treturn scroll.clearSurface();\r\n}// clear\r\n\r\n// Tell us if the surface where we store the console graphics\r\n// is lost (meaning it has to be restored)\r\nbool consoleClass::isLost(bool* errorCode)\r\n{\r\n\t// check if it's lost or not\r\n\treturn scroll.isLost(errorCode);\r\n}// isLost\r\n\r\n// Restore the surface where we use to draw the console graphics\r\n// The surface obtained could not keep the text, as it could have been\r\n// lost together with the surface.\r\nbool consoleClass::restore()\r\n{\r\n\t// restore it\r\n\treturn scroll.restore();\r\n}// restore\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#include \"ddwrap.h\"\r\n#include <SDL.h>\r\n#include <SDL_image.h>\r\n\r\n#define RectToSDLRect(r,rsdl) {(rsdl).x=(r).left; (rsdl).y=(r).top; (rsdl).w=(r).right-(r).left; (rsdl).h=(r).bottom-(r).top;}\r\n\r\n// some static members definition (ddSurfaceClass)\r\nSDL_Surface* ddSurfaceClass::screenSurface=NULL;// used to be lpDD\r\n\r\nbool ddSurfaceClass::isDDReady=false;\r\nint ddSurfaceClass::bpp=0;// screen bpp\r\ndirectDrawClass* ddSurfaceClass::DDObject=NULL;// pointer to our DD object\r\n\r\n// Methods of ddSurfaceClass\r\n// may return error when one of the surfaces is lost\r\nbool ddSurfaceClass::bltFrom(\r\n\tddSurfaceClass& srf,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tbool clip,// clip before blt? true by default\r\n\tbool transparent)// transparent blt? false by default\r\n{\r\n\treturn this->bltFrom(\r\n\t\tsrf,// src surface\r\n\t\txD, yD,// dest coordinates\r\n\t\t0, 0, srf.xRes, srf.yRes,// src coordinates\r\n\t\tclip, transparent// some flags\r\n\t\t);\r\n}\r\n\r\n// may return error when one of the surfaces is lost\r\nbool ddSurfaceClass::bltFrom(\r\n\tddSurfaceClass& srf,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tint xS, int yS,// src coordinates\r\n\tint wS, int hS,// src size ([w]idth, [h]eight)\r\n\tbool clip,// clip before blt? true by default\r\n\tbool transparent)// transparent blt? false by default\r\n{\r\n\treturn this->bltFrom(\r\n\t\tsrf,// src surface\r\n\t\txD, yD,// dest coordinates\r\n\t\txS, yS, wS, hS,// src coordinates\r\n\t\t0, 0, xRes, yRes,// clip values for the entire destination surface\r\n\t\tclip, transparent// some flags\r\n\t\t);\r\n}\r\n\r\n// That's the most complete version of bltFrom\r\n// may return error when one of the surfaces is lost\r\nbool ddSurfaceClass::bltFrom(\r\n\tddSurfaceClass& srf,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tint xS, int yS,// src coordinates\r\n\tint wS, int hS,// src size ([w]idth, [h]eight)\r\n\tint xClip, int yClip,// these four numbers are the clipping rectangle\r\n\tint wClip, int hClip,\r\n\tbool clip,// clip before blt? true by default\r\n\tbool transparent)// transparent blt? false by default\r\n{\r\n\tRECT rectS;\r\n\r\n\tif (!isReady() || !srf.isReady()) return false;\r\n\r\n\trectS.left=xS;\r\n\trectS.top=yS;\r\n\trectS.right=xS+wS;\r\n\trectS.bottom=yS+hS;\r\n\r\n\tif (clip){\r\n\t\t// is the blit necessary?\r\n\t\tif (xD+wS<=xClip || yD+hS<=yClip ||\r\n\t\t\txD>=xClip+wClip || yD>=yClip+hClip)\r\n\t\t\treturn true;// it's not\r\n\r\n\t\t// make the clip\r\n\t\tif (xD<xClip){\r\n\t\t\t// clip left\r\n\t\t\trectS.left=rectS.left-xD+xClip;\r\n\t\t\txD=xClip;\r\n\t\t}\r\n\r\n\t\tif (yD<yClip){\r\n\t\t\t// clip top\r\n\t\t\trectS.top=rectS.top-yD+yClip;\r\n\t\t\tyD=yClip;\r\n\t\t}\r\n\r\n\t\tif (xD+wS>xClip+wClip){\r\n\t\t\t// clip right\r\n\t\t\trectS.right=rectS.left+xClip+wClip-xD;\r\n\t\t}\r\n\r\n\t\tif (yD+hS>yClip+hClip){\r\n\t\t\t// clip bottom\r\n\t\t\trectS.bottom=rectS.top+yClip+hClip-yD;\r\n\t\t}\r\n\t}// if clip\r\n\r\n/*\tif (FAILED(srfOffScreen->BltFast(\r\n\t\txD, yD,// dest coordinates\r\n\t\tsrf.srfOffScreen,// src surface\r\n\t\t&rectS,// src rect\r\n\t\tDDBLTFAST_WAIT |// options\r\n\t\t(transparent?DDBLTFAST_SRCCOLORKEY: DDBLTFAST_NOCOLORKEY)\r\n\t\t))){\r\n\r\n\t\treturn false;\r\n\t}\r\n*/\r\n\tRECT rectD;\r\n\trectD.left=xD;\r\n\trectD.top=yD;\r\n\trectD.bottom=rectD.top+rectS.bottom-rectS.top;\r\n\trectD.right=rectD.left+rectS.right-rectS.left;\r\n\r\n\tSDL_Rect rectS2;\r\n\tSDL_Rect rectD2;\r\n\r\n\tRectToSDLRect(rectS, rectS2);\r\n\tRectToSDLRect(rectD, rectD2);\r\n\r\n\tif (SDL_BlitSurface(\r\n\t\tsrf.srfOffScreen,// src surface\r\n\t\t&rectS2,// src rect\r\n\t\tsrfOffScreen,// dest surface\r\n\t\t&rectD2// dest coordinates\r\n\t\t)){\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;// all ok\r\n}// bltFrom\r\n\r\n// This method executes blts a stretched copy of the source image.\r\n// Dimensions are then different for the source and destination images,\r\n// and mirroring capabilities are also available in this method.\r\n// Clipping is not implemented, as no algorithm was proven to work\r\n// correctly and quickly through DX.\r\n// It might return error when one of the surfaces is lost\r\nbool ddSurfaceClass::stretchBltFrom(\r\n\tddSurfaceClass& srf,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tint wD, int hD,// dest size ([w]idth, [h]eight)\r\n\tint xS, int yS,// src coordinates\r\n\tint wS, int hS,// src size ([w]idth, [h]eight)\r\n\tbool mirrorX, bool mirrorY,// mirror horizontally / vertically? false by default\r\n\tbool transparent)// transparent blt? false by default\r\n{\r\n\tRECT rectS;\r\n\tRECT rectD;\r\n/*\tDDBLTFX bltFx={sizeof(bltFx)};\r\n\r\n\tif (!isReady() || !srf.isReady()) return false;\r\n\r\n\trectD.left=xD;\r\n\trectD.top=yD;\r\n\trectD.right=xD+wD;\r\n\trectD.bottom=yD+hD;\r\n\r\n\trectS.left=xS;\r\n\trectS.top=yS;\r\n\trectS.right=xS+wS;\r\n\trectS.bottom=yS+hS;\r\n\r\n\t// Check for mirroring...\r\n\tif (mirrorX){\r\n\t\tbltFx.dwDDFX|=DDBLTFX_MIRRORLEFTRIGHT;\r\n\t}// if\r\n\tif (mirrorY){\r\n\t\tbltFx.dwDDFX|=DDBLTFX_MIRRORUPDOWN;\r\n\t}// if\r\n\r\n\tif (FAILED(srfOffScreen->Blt(\r\n\t\t&rectD,// dest rect\r\n\t\tsrf.srfOffScreen,// src surface\r\n\t\t&rectS,// src rect\r\n\t\tDDBLT_WAIT |// options\r\n\t\tDDBLT_DDFX |// for ensuring mirrorX and mirrorY work properly if selected\r\n\t\t(transparent?DDBLT_KEYSRC: 0),\r\n\t\t&bltFx// ddBltFx for extra data...\r\n\t\t))){\r\n\r\n\t\treturn false;\r\n\t}\r\n*/\r\n\treturn true;// all ok\r\n}// stretchBltFrom\r\n\r\n// This method blts an image with an obscuring factor, in a given\r\n// position of the surface. The obscuring factor (lightness) ranges from\r\n// 0 to 255, 0 being a black image (too much dark), 255 a full lighted\r\n// one (equal to the original one), and all the values in-between\r\n// meaning a given amount of lightness / darkness.\r\n// Clipping is not implemented in this method, for optimization (this\r\n// method runs through software, it's only hardware accelerated when\r\n// 'lightness' is 0 or 255), so this method returns error when the\r\n// blitting would require clipping to be well done (that is, every time\r\n// one tries to draw outside the destination surface).\r\nbool ddSurfaceClass::obscuredBltFrom(\r\n\tddSurfaceClass& srfSrc,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tint lightness,// value of lightness, ranging from 0 to 255, 0 being the darkest\r\n\tbool transparent)// transparent background? false by default... that is: do we use the transparent color?\r\n{\r\n\treturn bltFrom(srfSrc, xD, yD, true, transparent);\r\n/*\tDWORD pitchDest, pitchSrc;// pitch of the surfaces in bytes\r\n\tWORD* ptrDest;// pointers to the surfaces\r\n\tWORD* ptrSrc;\r\n\tddSurfaceClass& srfDest=(*this);// it isn't necessary at all\r\n\tregister int heightSrc, widthSrc;// size of the source surface\r\n\tregister int x, y;// temporary variables for our calculations\r\n\tregister int rr, gg, bb;// temporary variables for our color calculations\r\n\t// Some variables used for optimization\r\n\t// First, the numbers to increment when going to pass to the next\r\n\t// line\r\n\tregister int distBetweenLinesDest, distBetweenLinesSrc;\r\n\t// This value is used for obscuring every color component.\r\n\tregister float colorMultiplier;\r\n\t// Used for cacheing the latest colors modified, so we can avoid\r\n\t// calculating all again.\r\n\t// cachedColor: original color\r\n\t// modifiedColor: cachedColor after light is applied\r\n\tregister WORD cachedColor1, modifiedColor1;\r\n\tregister WORD cachedColor2, modifiedColor2;\r\n\tregister WORD wordForSwapping;\r\n\r\n\tif (!srfDest.isReady() || !srfSrc.isReady()) return false;\r\n\r\n\t// check that transparent blt isn't selected when a transparent\r\n\t// color hasn't already been selected\r\n\tif (transparent && !srfSrc.transparent) return false;\r\n\r\n\t// check the bits per pixel, this method only works in 16 bits\r\n\tif (bpp!=16) return false;\r\n\r\n\t// load the size of the source surface\r\n\twidthSrc=srfSrc.getWidth();\r\n\theightSrc=srfSrc.getHeight();\r\n\r\n\t// do some checks\r\n\t// If we are out of the drawing area, don't ever try drawing\r\n\t// the image\r\n\tif (xD<0 || yD<0 ||\r\n\t\txD+widthSrc>srfDest.getWidth() ||\r\n\t\tyD+heightSrc>srfDest.getHeight()){\r\n\t\t// failed! tried to draw outside the destination rectangle\r\n\t\treturn false;\r\n\t}// if\r\n\t// If lightness=0, just draw a blank rectangle, but only if we\r\n\t// haven't to consider transparency\r\n\tif (lightness==0 && !transparent){\r\n\t\tsrfDest.fillRect(0, 0, 0, xD, yD, widthSrc, heightSrc);\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\t// If lightness=255, just draw the image normally\r\n\tif (lightness==255){\r\n\t\tsrfDest.bltFrom(srfSrc, xD, yD, false, transparent);\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// lock the destination surface, as write only\r\n\tif (!srfDest.lock(false, true, &pitchDest, (LPVOID*)(&ptrDest))){\r\n\t\t// it failed...\r\n\t\treturn false;\r\n\t}// if\r\n\t// lock the source surface, as read only\r\n\tif (!srfSrc.lock(true, false, &pitchSrc, (LPVOID*)(&ptrSrc))){\r\n\t\t// it failed...\r\n\t\tsrfDest.unlock();// unlock the other one before going away\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Displace ptrDest to make it be in the selected position.\r\n\t// In bytes, that'd be ptrDest+=((pitchDest*yD)+(2*xD)).\r\n\tptrDest=(WORD*)(((BYTE*)(ptrDest))+(pitchDest*yD)+(2*xD));\r\n\r\n\t// load some values used for optimization\r\n\t// Optimization: increment for next line\r\n\tdistBetweenLinesDest=pitchDest-(widthSrc*2);\r\n\tdistBetweenLinesSrc=pitchSrc-(widthSrc*2);\r\n\t// Optimization: factor for all the color components\r\n\tcolorMultiplier=(float)(lightness<=255?lightness:255)/float(255);\r\n\t// Optimization: load default values for the cached colors.\r\n\tcachedColor1=0; modifiedColor1=0;\r\n\tcachedColor2=0; modifiedColor2=0;\r\n\r\n\tfor (y=0; y<heightSrc; y++){\r\n\t\tfor (x=0; x<widthSrc; x++){\r\n\t\t\tif (transparent && (*ptrSrc)==srfSrc.transparentDword){\r\n\t\t\t\t// transparent color... do nothing\r\n\t\t\t}else{\r\n\t\t\t\t// non transparent color, obscure this pixel color.\r\n\t\t\t\t// look for this color in our first cache\r\n\t\t\t\tif ((*ptrSrc)==cachedColor1){\r\n\t\t\t\t\t(*ptrDest)=modifiedColor1;// it worked\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// it wasn't there, look for the color in our second\r\n\t\t\t\t\t// cache\r\n\t\t\t\t\tif ((*ptrSrc)==cachedColor2){\r\n\t\t\t\t\t\t(*ptrDest)=modifiedColor2;// it worked\r\n\r\n\t\t\t\t\t\t// now swap colors, let the latest color used be\r\n\t\t\t\t\t\t// in the first cache\r\n\t\t\t\t\t\t// SWAP(cachedColor1, cachedColor2)\r\n\t\t\t\t\t\twordForSwapping=cachedColor1;\r\n\t\t\t\t\t\tcachedColor1=cachedColor2;\r\n\t\t\t\t\t\tcachedColor2=wordForSwapping;\r\n\t\t\t\t\t\t// SWAP(modifiedColor1, modifiedColor2)\r\n\t\t\t\t\t\twordForSwapping=modifiedColor1;\r\n\t\t\t\t\t\tmodifiedColor1=modifiedColor2;\r\n\t\t\t\t\t\tmodifiedColor2=wordForSwapping;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// color is not in cache memories\r\n\t\t\t\t\t\t// Get the three color components\r\n\t\t\t\t\t\trr=getRedFromDword((*DDObject), (*ptrSrc));\r\n\t\t\t\t\t\tgg=getGreenFromDword((*DDObject), (*ptrSrc));\r\n\t\t\t\t\t\tbb=getBlueFromDword((*DDObject), (*ptrSrc));\r\n\r\n\t\t\t\t\t\t// Modify every color component\r\n\t\t\t\t\t\trr=int(rr*colorMultiplier);\r\n\t\t\t\t\t\tgg=int(gg*colorMultiplier);\r\n\t\t\t\t\t\tbb=int(bb*colorMultiplier);\r\n\r\n\t\t\t\t\t\t// Move cache 1 to cache 2\r\n\t\t\t\t\t\tcachedColor2=cachedColor1;\r\n\t\t\t\t\t\tmodifiedColor2=modifiedColor1;\r\n\r\n\t\t\t\t\t\t// Compose the color back, directly to the cache\r\n\t\t\t\t\t\tcachedColor1=(*ptrSrc);\r\n\t\t\t\t\t\tmodifiedColor1=\r\n\t\t\t\t\t\t\tgetDwordFromRGBFast((*DDObject), rr, gg, bb);\r\n\r\n\t\t\t\t\t\t(*ptrDest)=modifiedColor1;\r\n\t\t\t\t\t}// if cache 2\r\n\t\t\t\t}// if cache 1\r\n\t\t\t}// if transparent\r\n\r\n\t\t\t// go to the next pixel\r\n\t\t\t// let's increment both pointers\r\n\t\t\tptrSrc++;\r\n\t\t\tptrDest++;\r\n\t\t}// for x\r\n\r\n\t\t// advance to the next line\r\n\t\tptrSrc=(WORD*)(((BYTE*)(ptrSrc))+distBetweenLinesSrc);\r\n\t\tptrDest=(WORD*)(((BYTE*)(ptrDest))+distBetweenLinesDest);\r\n\t}// for y\r\n\r\n\t// it's ready, unlock both surfaces and go away\r\n\tsrfDest.unlock();\r\n\tsrfSrc.unlock();\r\n*/\r\n\treturn true;// all ok\r\n}// obscuredBltFrom\r\n\r\n// This method blts an image blended with the destination surface,\r\n// using an alpha value which indicates the level of opacity of the\r\n// source image (ranging from 0 to 255, being 0 the most transparent\r\n// value, and 255 the fully opaque image).\r\n// Clipping is not implemented in this method, for optimization (this\r\n// method runs through software, it's only hardware accelerated when\r\n// 'lightness' is 0 or 255), so this method returns error when the\r\n// blitting would require clipping to be well done (that is, every time\r\n// one tries to draw outside the destination surface).\r\nbool ddSurfaceClass::alphaBltFrom(\r\n\tddSurfaceClass& srfSrc,// src surface\r\n\tint xD, int yD,// dest coordinates\r\n\tint alphaValue,// value of alpha blending, between 0 and 255, 0 being totally transparent and 255 being opaque\r\n\tbool transparent)// transparent background? false by default... that is: do we use the transparent color?\r\n{\r\n/*\tDWORD pitchDest, pitchSrc;// pitch of the surfaces in bytes\r\n\tWORD* ptrDest;// pointers to the surfaces\r\n\tWORD* ptrSrc;\r\n\tddSurfaceClass& srfDest=(*this);// it isn't necessary at all\r\n\tregister int heightSrc, widthSrc;// size of the source surface\r\n\t// temporary variables for our color calculations\r\n\tregister int x, y;// coordinates\r\n\tregister int rrS, ggS, bbS;// source color components\r\n\tregister int rrD, ggD, bbD;// destination color components\r\n\tregister int rr, gg, bb;// definitive color components\r\n\t// Some variables used for optimization\r\n\t// First, the numbers to increment when going to pass to the next\r\n\t// line\r\n\tregister int distBetweenLinesDest, distBetweenLinesSrc;\r\n\t// Precalculated floats telling the factor we multiply the source\r\n\t// and destination colors to get the blended color\r\n\tregister float srcColorMultiplier;\r\n\tregister float destColorMultiplier;\r\n\t// Used for cacheing the latest colors modified, so we can avoid\r\n\t// calculating all again.\r\n\t// cachedColor: original color\r\n\t// modifiedColor: cachedColor after alpha is applied\r\n\tregister WORD cachedSrcColor1;\r\n\tregister WORD modifiedSrcR1, modifiedSrcG1, modifiedSrcB1;\r\n\tregister WORD cachedSrcColor2;\r\n\tregister WORD modifiedSrcR2, modifiedSrcG2, modifiedSrcB2;\r\n\tregister WORD cachedDestColor1;\r\n\tregister WORD modifiedDestR1, modifiedDestG1, modifiedDestB1;\r\n\tregister WORD cachedDestColor2;\r\n\tregister WORD modifiedDestR2, modifiedDestG2, modifiedDestB2;\r\n\tregister WORD modifiedSrcR, modifiedSrcG, modifiedSrcB;\r\n\tregister WORD modifiedDestR, modifiedDestG, modifiedDestB;\r\n\r\n\tif (!srfDest.isReady() || !srfSrc.isReady()) return false;\r\n\r\n\t// check that transparent blt isn't selected when a transparent\r\n\t// color hasn't already been selected\r\n\tif (transparent && !srfSrc.transparent) return false;\r\n\r\n\t// check the bits per pixel, this method only works in 16 bits\r\n\tif (bpp!=16) return false;\r\n\r\n\t// load the size of the source surface\r\n\twidthSrc=srfSrc.getWidth();\r\n\theightSrc=srfSrc.getHeight();\r\n\r\n\t// do some checks\r\n\t// If we are out of the drawing area, don't ever try drawing\r\n\t// the image\r\n\tif (xD<0 || yD<0 ||\r\n\t\txD+widthSrc>srfDest.getWidth() ||\r\n\t\tyD+heightSrc>srfDest.getHeight()){\r\n\t\t// failed! tried to draw outside the destination rectangle\r\n\t\treturn false;\r\n\t}// if\r\n\t// If alphaValue=0, do nothing\r\n\tif (alphaValue==0){\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\t// If alphaValue=255, just draw the image normally\r\n\tif (alphaValue==255){\r\n\t\tsrfDest.bltFrom(srfSrc, xD, yD, false, transparent);\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// lock the destination surface, as read and write\r\n\tif (!srfDest.lock(true, true, &pitchDest, (LPVOID*)(&ptrDest))){\r\n\t\t// it failed...\r\n\t\treturn false;\r\n\t}// if\r\n\t// lock the source surface, as read only\r\n\tif (!srfSrc.lock(true, false, &pitchSrc, (LPVOID*)(&ptrSrc))){\r\n\t\t// it failed...\r\n\t\tsrfDest.unlock();// unlock the other one before going away\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Displace ptrDest to make it be in the selected position.\r\n\t// In bytes, that'd be ptrDest+=((pitchDest*yD)+(2*xD)).\r\n\tptrDest=(WORD*)(((BYTE*)(ptrDest))+(pitchDest*yD)+(2*xD));\r\n\r\n\t// load some values used for optimization\r\n\t// Optimization: increment for next line\r\n\tdistBetweenLinesDest=pitchDest-(widthSrc*2);\r\n\tdistBetweenLinesSrc=pitchSrc-(widthSrc*2);\r\n\t// Optimization: factors for all the color components\r\n\tsrcColorMultiplier=(float)(alphaValue<=255?alphaValue:255)/float(255);\r\n\tdestColorMultiplier=float(1)-srcColorMultiplier;\r\n\t// Optimization: load default values for the cached colors.\r\n\tcachedSrcColor1=0;\r\n\tmodifiedSrcR1=0; modifiedSrcG1=0; modifiedSrcB1=0;\r\n\tcachedSrcColor2=0;\r\n\tmodifiedSrcR2=0; modifiedSrcG2=0; modifiedSrcB2=0;\r\n\tcachedDestColor1=0;\r\n\tmodifiedDestR1=0; modifiedDestG1=0; modifiedDestB1=0;\r\n\tcachedDestColor2=0;\r\n\tmodifiedDestR2=0; modifiedDestG2=0; modifiedDestB2=0;\r\n\r\n\tfor (y=0; y<heightSrc; y++){\r\n\t\tfor (x=0; x<widthSrc; x++){\r\n\t\t\tif (transparent && (*ptrSrc)==srfSrc.transparentDword){\r\n\t\t\t\t// transparent color... do nothing\r\n\t\t\t}else{\r\n\t\t\t\t// non transparent color, alpha blend this color\r\n\r\n\t\t\t\t// SOURCE color\r\n\t\t\t\tif ((*ptrSrc)==cachedSrcColor1){\r\n\t\t\t\t\t// let's use the values in the first cache\r\n\t\t\t\t\tmodifiedSrcR=modifiedSrcR1;\r\n\t\t\t\t\tmodifiedSrcG=modifiedSrcG1;\r\n\t\t\t\t\tmodifiedSrcB=modifiedSrcB1;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif ((*ptrSrc)==cachedSrcColor2){\r\n\t\t\t\t\t\t// let's use the values in the second cache.\r\n\t\t\t\t\t\tmodifiedSrcR=modifiedSrcR2;\r\n\t\t\t\t\t\tmodifiedSrcG=modifiedSrcG2;\r\n\t\t\t\t\t\tmodifiedSrcB=modifiedSrcB2;\r\n\t\t\t\t\t\t// for extra optimization, we could swap the\r\n\t\t\t\t\t\t// caches, but we won't do it this time...\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// color is not in cache! calculate it\r\n\t\t\t\t\t\t// separate the source color in its three components\r\n\t\t\t\t\t\trrS=getRedFromDword((*DDObject), (*ptrSrc));\r\n\t\t\t\t\t\tggS=getGreenFromDword((*DDObject), (*ptrSrc));\r\n\t\t\t\t\t\tbbS=getBlueFromDword((*DDObject), (*ptrSrc));\r\n\r\n\t\t\t\t\t\t// compute the source new components\r\n\t\t\t\t\t\tmodifiedSrcR=(WORD)(rrS*srcColorMultiplier);\r\n\t\t\t\t\t\tmodifiedSrcG=(WORD)(ggS*srcColorMultiplier);\r\n\t\t\t\t\t\tmodifiedSrcB=(WORD)(bbS*srcColorMultiplier);\r\n\r\n\t\t\t\t\t\t// move the first cache to the second cache\r\n\t\t\t\t\t\tcachedSrcColor2=cachedSrcColor1;\r\n\t\t\t\t\t\tmodifiedSrcR2=modifiedSrcR1;\r\n\t\t\t\t\t\tmodifiedSrcG2=modifiedSrcG1;\r\n\t\t\t\t\t\tmodifiedSrcB2=modifiedSrcB1;\r\n\t\t\t\t\t\t// now save it in the first cache\r\n\t\t\t\t\t\tcachedSrcColor1=(*ptrSrc);\r\n\t\t\t\t\t\tmodifiedSrcR1=modifiedSrcR;\r\n\t\t\t\t\t\tmodifiedSrcG1=modifiedSrcG;\r\n\t\t\t\t\t\tmodifiedSrcB1=modifiedSrcB;\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// DESTINATION color\r\n\t\t\t\tif ((*ptrDest)==cachedDestColor1){\r\n\t\t\t\t\t// let's use the values in the first cache\r\n\t\t\t\t\tmodifiedDestR=modifiedDestR1;\r\n\t\t\t\t\tmodifiedDestG=modifiedDestG1;\r\n\t\t\t\t\tmodifiedDestB=modifiedDestB1;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif ((*ptrDest)==cachedDestColor2){\r\n\t\t\t\t\t\t// let's use the values in the second cache.\r\n\t\t\t\t\t\tmodifiedDestR=modifiedDestR2;\r\n\t\t\t\t\t\tmodifiedDestG=modifiedDestG2;\r\n\t\t\t\t\t\tmodifiedDestB=modifiedDestB2;\r\n\t\t\t\t\t\t// for extra optimization, we could swap the\r\n\t\t\t\t\t\t// caches, but we won't do it this time...\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// color is not in cache! calculate it\r\n\t\t\t\t\t\t// separate the destination color in its three components\r\n\t\t\t\t\t\trrD=getRedFromDword((*DDObject), (*ptrDest));\r\n\t\t\t\t\t\tggD=getGreenFromDword((*DDObject), (*ptrDest));\r\n\t\t\t\t\t\tbbD=getBlueFromDword((*DDObject), (*ptrDest));\r\n\r\n\t\t\t\t\t\t// compute the destination new components\r\n\t\t\t\t\t\tmodifiedDestR=(WORD)(rrD*destColorMultiplier);\r\n\t\t\t\t\t\tmodifiedDestG=(WORD)(ggD*destColorMultiplier);\r\n\t\t\t\t\t\tmodifiedDestB=(WORD)(bbD*destColorMultiplier);\r\n\r\n\t\t\t\t\t\t// move the first cache to the second cache\r\n\t\t\t\t\t\tcachedDestColor2=cachedDestColor1;\r\n\t\t\t\t\t\tmodifiedDestR2=modifiedDestR1;\r\n\t\t\t\t\t\tmodifiedDestG2=modifiedDestG1;\r\n\t\t\t\t\t\tmodifiedDestB2=modifiedDestB1;\r\n\t\t\t\t\t\t// now save it in the first cache\r\n\t\t\t\t\t\tcachedDestColor1=(*ptrDest);\r\n\t\t\t\t\t\tmodifiedDestR1=modifiedDestR;\r\n\t\t\t\t\t\tmodifiedDestG1=modifiedDestG;\r\n\t\t\t\t\t\tmodifiedDestB1=modifiedDestB;\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// calculate the three components of the definitive color\r\n\t\t\t\trr=modifiedSrcR+modifiedDestR;\r\n\t\t\t\tgg=modifiedSrcG+modifiedDestG;\r\n\t\t\t\tbb=modifiedSrcB+modifiedDestB;\r\n\r\n\t\t\t\t// save the color in the destination surface\r\n\t\t\t\t(*ptrDest)=getDwordFromRGBFast((*DDObject), rr, gg, bb);\r\n\t\t\t}// if transparent\r\n\r\n\t\t\t// go to the next pixel\r\n\t\t\t// let's increment both pointers\r\n\t\t\tptrSrc++;\r\n\t\t\tptrDest++;\r\n\t\t}// for x\r\n\r\n\t\t// advance to the next line\r\n\t\tptrSrc=(WORD*)(((BYTE*)(ptrSrc))+distBetweenLinesSrc);\r\n\t\tptrDest=(WORD*)(((BYTE*)(ptrDest))+distBetweenLinesDest);\r\n\t}// for y\r\n\r\n\t// it's ready, unlock both surfaces and go away\r\n\tsrfDest.unlock();\r\n\tsrfSrc.unlock();\r\n*/\r\n\treturn true;// all ok\r\n}// alphaBltFrom\r\n\r\n// This method sets the color of a given pixel, using the GDI functions\r\n// for that (so it's supposed to be extremely slow!).\r\nbool ddSurfaceClass::putPixel(\r\n\tint x, int y,// pixel coordinates\r\n\tint r, int g, int b)// components of the color to use, from 0 to 255 each\r\n{\r\n/*\tHDC hdc;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the dc handle, if error is WasStillDrawing, try again\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\tif (SetPixel(hdc, x, y, RGB(r, g, b))==-1){\r\n\t\t// failed\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// bye bye dc\r\n\treleaseDC(hdc);\r\n*/\r\n\treturn true;// all ok\r\n}// putPixel\r\n\r\n// This method draws a line, using the GDI functions for that (so it's\r\n// supposed to be very slow).\r\nbool ddSurfaceClass::drawLine(\r\n\tint x, int y,// coordinates of the first point of the line\r\n\tint x2, int y2,// coordinates of the last point of the line\r\n\tint r, int g, int b)// components of the color to fill with\r\n{\r\n/*\tHDC hdc;\r\n\tHPEN pen, oldpen;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the dc handle, if error is WasStillDrawing, try again\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\t// create the pen\r\n\tif ((pen=CreatePen(PS_SOLID, 0, RGB(r, g, b)))==NULL){\r\n\t\t// failed\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// select the pen\r\n\tif ((oldpen=(HPEN)SelectObject(hdc, pen))==NULL){\r\n\t\t// failed\r\n\t\tDeleteObject(pen);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// move to the line start\r\n\tif (MoveToEx(hdc, x, y, NULL)==0){\r\n\t\t// failed\r\n\t\tSelectObject(hdc, oldpen);\r\n\t\tDeleteObject(pen);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// draw the line\r\n\tif (LineTo(hdc, x2, y2)==FALSE){\r\n\t\t// failed\r\n\t\tSelectObject(hdc, oldpen);\r\n\t\tDeleteObject(pen);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// bye bye pen\r\n\tSelectObject(hdc, oldpen);\r\n\tDeleteObject(pen);\r\n\r\n\t// bye bye dc\r\n\treleaseDC(hdc);\r\n\r\n\t// draw the last pixel (otherwise it isn't drawn by the GDI)\r\n\tif (!putPixel(x2, y2, r, g, b)){\r\n\t\treturn false;\r\n\t}// if\r\n*/\r\n\treturn true;// all ok\r\n}// drawLine\r\n\r\n// This method fills a rectangle with a color, using the GDI functions\r\n// for that (so it's supposed to be very slow).\r\nbool ddSurfaceClass::fillRect(\r\n\tint r, int g, int b,// components of the color to fill with\r\n\tint x, int y,// where to start filling\r\n\tint width, int height)// if any of both is zero, fill until the end\r\n{\r\n/*\tHDC hdc;\r\n\tRECT box;\r\n\tHBRUSH brush;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the dc handle, if error is WasStillDrawing, try again\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\t// now make the rect box\r\n\tbox.left=x;\r\n\tbox.top=y;\r\n\tif (width==0){\r\n\t\tbox.right=xRes;\r\n\t}else{\r\n\t\tbox.right=x+width;\r\n\t}// if\r\n\tif (height==0){\r\n\t\tbox.bottom=yRes;\r\n\t}else{\r\n\t\tbox.bottom=y+height;\r\n\t}// if\r\n\r\n\t// now fill the box\r\n\tif ((brush=CreateSolidBrush(RGB(r, g, b)))==NULL){\r\n\t\t// failed\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\tif (FillRect(hdc, &box, brush)==FALSE){\r\n\t\t// failed\r\n\t\tDeleteObject(brush);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// bye bye brush\r\n\tDeleteObject(brush);\r\n\r\n\t// bye bye dc\r\n\treleaseDC(hdc);\r\n*/\r\n\treturn true;// all ok\r\n}// fillRect\r\n\r\n// Fill the entire surface with a color, by using a hardware blt,\r\n// or a software blt if it's not possible. Very fast compared to fillRect\r\nbool ddSurfaceClass::fillAllDword(DWORD color)\r\n{\r\n/*\tHRESULT res;\r\n\tDDBLTFX fx={sizeof(fx)};// used to pass the fill color\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// the color...\r\n\tfx.dwFillColor=color;\r\n\r\n\t// try filling the surface until it can be done\r\n\tdo {\r\n\t\t// fill the surface if possible\r\n\t\tres=srfOffScreen->Blt(\r\n\t\t\tNULL, NULL, NULL,// used for blittings only\r\n\t\t\tDDBLT_COLORFILL,// it's a filler\r\n\t\t\t&fx);// extra data\r\n\t}while(res==DDERR_WASSTILLDRAWING);\r\n\r\n\t// check for errors\r\n\tif (FAILED(res)) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// fillAllDword\r\n\r\n// Writes a text to the surface.\r\n// may return error if the surface is lost\r\n// Be careful, if width wasn't initialized with some meaningful value,\r\n// height will go to infinite (as chances are, width is a big number).\r\nbool ddSurfaceClass::writeText(\r\n\tchar* text,// text to print out, might include \\n's meaning line breaks\r\n\tint r, int g, int b,// color of the text\r\n\talignEnum align,// alignment for the text, might be any of the following: FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER, FILE_DDWRAP_ALIGN_RIGHT\r\n\tint x, int y,// coordinates for the text to be wrote\r\n\tint width, int height)// if any of both is zero, set it to the max in the surface\r\n{\r\n/*\tHDC hdc;\r\n\tRECT box;\r\n\tHFONT font, oldFont;\r\n\tUINT alignFlag;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the DC\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\t// adjust transparency and color\r\n\tif (SetBkMode(hdc, TRANSPARENT)==0 ||\r\n\t\tSetTextColor(hdc, RGB(r, g, b))==CLR_INVALID){\r\n\r\n\t\t// error!\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// select the desired font\r\n\tfont=(HFONT)GetStockObject(ANSI_FIXED_FONT);\r\n\tif ((oldFont=(HFONT)SelectObject(hdc, font))==NULL){\r\n\t\t// error!\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// check the text alignment\r\n\tswitch (align){\r\n\tcase FILE_DDWRAP_ALIGN_LEFT:\r\n\t\talignFlag=DT_LEFT;\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_ALIGN_CENTER:\r\n\t\talignFlag=DT_CENTER;\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_ALIGN_RIGHT:\r\n\t\talignFlag=DT_RIGHT;\r\n\t\tbreak;\r\n\t}//switch\r\n\r\n\t// time to draw the text\r\n\tbox.left=x;\r\n\tbox.top=y;\r\n\tif (width==0){\r\n\t\tbox.right=xRes;// set it to the max\r\n\t}else{\r\n\t\tbox.right=x+width;\r\n\t}// if\r\n\tif (height==0){\r\n\t\tbox.bottom=yRes;// set it to the max\r\n\t}else{\r\n\t\tbox.bottom=y+height;\r\n\t}// if\r\n\tDrawText(\r\n\t\thdc,// hdc where to tdraw\r\n\t\ttext, -1,// text, and size of the text\r\n\t\t&box,// pos and dimensions of the text box\r\n\t\talignFlag | DT_WORDBREAK\r\n\t\t| DT_NOPREFIX);// some extra data\r\n\r\n\t// back to the old font\r\n\tSelectObject(hdc, oldFont);\r\n\r\n\t// bye bye dc\r\n\treleaseDC(hdc);\r\n*/\r\n\treturn true;// all ok\r\n}// writeText\r\n\r\n// Calculates the size a text would have, if drawn using the writeText\r\n// method.\r\n// width and heigh are used to pass the same values that for\r\n// writeText, and calculateText will change those for the real values\r\n// that make the box where the text is.\r\n// may return error if the surface is lost\r\nbool ddSurfaceClass::calculateText(\r\n\tchar* text,// text to print out, might include \\n's meaning line breaks\r\n\talignEnum align,// alignment for the text, might be any of the following: FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER, FILE_DDWRAP_ALIGN_RIGHT\r\n\tint &width, int &height)// if any of both is zero, set it to the max in the surface\r\n{\r\n/*\tHDC hdc;\r\n\tRECT box;\r\n\tHFONT font, oldFont;\r\n\tUINT alignFlag;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the DC\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\t// adjust transparency only (it could not be necessary)\r\n\tif (SetBkMode(hdc, TRANSPARENT)==0){\r\n\r\n\t\t// error!\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// select the desired font\r\n\tfont=(HFONT)GetStockObject(ANSI_FIXED_FONT);\r\n\tif ((oldFont=(HFONT)SelectObject(hdc, font))==NULL){\r\n\t\t// error!\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// check the text alignment\r\n\tswitch (align){\r\n\tcase FILE_DDWRAP_ALIGN_LEFT:\r\n\t\talignFlag=DT_LEFT;\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_ALIGN_CENTER:\r\n\t\talignFlag=DT_CENTER;\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_ALIGN_RIGHT:\r\n\t\talignFlag=DT_RIGHT;\r\n\t\tbreak;\r\n\t}//switch\r\n\r\n\t// fill the box rect\r\n\tbox.left=0;\r\n\tbox.top=0;\r\n\tif (width==0){\r\n\t\tbox.right=xRes;// set it to the max\r\n\t}else{\r\n\t\tbox.right=width;\r\n\t}// if\r\n\tif (height==0){\r\n\t\tbox.bottom=yRes;// set it to the max\r\n\t}else{\r\n\t\tbox.bottom=height;\r\n\t}// if\r\n\r\n\t// now calcule the values\r\n\tDrawText(\r\n\t\thdc,// hdc where to tdraw\r\n\t\ttext, -1,// text, and size of the text\r\n\t\t&box,// pos and dimensions of the text box\r\n\t\talignFlag | DT_WORDBREAK\r\n\t\t| DT_NOPREFIX | DT_CALCRECT);// some extra data\r\n\r\n\t// now change the coordinates to the real values\r\n\twidth=box.right;\r\n\theight=box.bottom;\r\n\r\n\t// back to the old font\r\n\tSelectObject(hdc, oldFont);\r\n\r\n\t// bye bye dc\r\n\treleaseDC(hdc);\r\n*/\r\n\treturn true;// all ok\r\n}// calculateText\r\n\r\n// This method saves a surface to a file, in the BMP format. Sure it's\r\n// very strange reading, but it works...\r\nbool ddSurfaceClass::saveAsBmpFile(\r\n\tchar* filename,// path and name of the file to save\r\n\tbool overwrite)// boolean telling whether we are allowed to overwrite existing files\r\n{\r\n/*\tHDC hdc;\r\n\tHBITMAP hbitmap;// a bitmap object\r\n\tHDC tempHdc;// for loading the right data in the bitmap object\r\n\tHBITMAP tempOldBm;// to be used together with tempHdc\r\n\tBITMAP bm;// an object containing information about a bitmap\r\n\tPBITMAPINFO bitmapInfo;\r\n\tBITMAPFILEHEADER header;// two variables for the header data\r\n\tPBITMAPINFOHEADER hdrInfo;\r\n\tWORD clrBits;// bits per pixel\r\n\tBYTE* imgMem;// memory for the bitmap itself\r\n\r\n\t// file stuff\r\n\tHANDLE file;\r\n\tDWORD toWrite, written, totalWritten;\r\n\r\n\t// let's get the dc first\r\n\tif (!getDC(&hdc)) return false;\r\n\r\n\t// create a compatible bitmap from where to take all the\r\n\t// information\r\n\tif ((hbitmap=CreateCompatibleBitmap(hdc, getWidth(), getHeight()))\r\n\t\t==NULL){\r\n\r\n\t\t// failed, go out!\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// create a compatible DC, which we'll use to load the bitmap\r\n\t// object with the right information\r\n\tif ((tempHdc=CreateCompatibleDC(hdc))==NULL){\r\n\t\t// failed, go out!\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// select the bitmap in the temporary DC\r\n\tif ((tempOldBm=(HBITMAP)SelectObject(tempHdc, hbitmap))==NULL){\r\n\t\t// failed, go out!\r\n\t\tDeleteDC(tempHdc);\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// now load the data of our surface to the new bitmap\r\n\tif (BitBlt(\r\n\t\ttempHdc,// destination dc\r\n\t\t0, 0, getWidth(), getHeight(),// destination coordinates\r\n\t\thdc,// source dc\r\n\t\t0, 0,// source coordinates\r\n\t\tSRCCOPY)// blt mode, copy the pixels\r\n\t\t==0){\r\n\r\n\t\t// failed, go out!\r\n\t\tSelectObject(tempHdc, tempOldBm);\r\n\t\tDeleteDC(tempHdc);\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// deselect and delete our temporary DC, its time is over now\r\n\tSelectObject(tempHdc, tempOldBm);\r\n\tDeleteDC(tempHdc);\r\n\r\n\t// get some information from the bitmap...\r\n\tif (GetObject(hbitmap, sizeof(BITMAP), (LPVOID)&bm)==NULL){\r\n\t\t// failed, go out!\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// calculate the bits per pixel... and make the value be one of the\r\n\t// most used formats\r\n\tclrBits=(WORD)(bm.bmPlanes*bm.bmBitsPixel);\r\n\tif (clrBits!=1 && clrBits<=4) clrBits=4;\r\n\t\telse if (clrBits<=8) clrBits=8;\r\n\t\telse if (clrBits<=16) clrBits=16;\r\n\t\telse if (clrBits<=24) clrBits=24;\r\n\t\telse clrBits=32;;\r\n\r\n\t// allocate memory for bitmapInfo\r\n\tif (clrBits!=24){\r\n\t\t// allocate for bitmap info header + color info\r\n\t\tbitmapInfo=(PBITMAPINFO)\r\n\t\t\t(new BYTE[sizeof(BITMAPINFOHEADER)+\r\n\t\t\tsizeof(RGBQUAD)*(2^clrBits)]);\r\n\t}else{\r\n\t\t// allocate for bitmap info header only\r\n\t\tbitmapInfo=(PBITMAPINFO)\r\n\t\t\t(new BYTE[sizeof(BITMAPINFOHEADER)]);\r\n\t}// if\r\n\thdrInfo=(PBITMAPINFOHEADER)bitmapInfo;\r\n\t\r\n\t// load all the data of bitmapInfo\r\n\tbitmapInfo->bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\r\n\r\n\t// fill the info from the bm structure\r\n\tbitmapInfo->bmiHeader.biWidth=bm.bmWidth;\r\n\tbitmapInfo->bmiHeader.biHeight=bm.bmHeight;\r\n\tbitmapInfo->bmiHeader.biPlanes=bm.bmPlanes;\r\n\tbitmapInfo->bmiHeader.biBitCount=bm.bmBitsPixel;\r\n\t// why this check is done, I'm not sure\r\n\tif (clrBits<24) bitmapInfo->bmiHeader.biClrUsed=2^clrBits;\r\n\r\n\t// some other info\r\n\tbitmapInfo->bmiHeader.biCompression=BI_RGB;\r\n\tbitmapInfo->bmiHeader.biSizeImage=\r\n\t\t(bm.bmWidth+7)/8*bm.bmHeight*clrBits;\r\n\tbitmapInfo->bmiHeader.biClrImportant=0;\r\n\r\n\t// fill the info for the header\r\n\theader.bfType=0x4d42;// \"BM\"\r\n\theader.bfSize=(DWORD)(sizeof(BITMAPFILEHEADER)+\r\n\t\thdrInfo->biSize+\r\n\t\thdrInfo->biClrUsed*sizeof(RGBQUAD)+\r\n\t\thdrInfo->biSizeImage);\r\n\theader.bfReserved1=0;\r\n\theader.bfReserved2=0;\r\n\theader.bfOffBits=(DWORD)(sizeof(BITMAPFILEHEADER)+\r\n\t\thdrInfo->biSize+\r\n\t\thdrInfo->biClrUsed*sizeof(RGBQUAD));\r\n\r\n\t// now allocate memory for the bitmap itself\r\n\timgMem=new BYTE[bitmapInfo->bmiHeader.biSizeImage];\r\n\r\n\t// obtain the bitmap memory\r\n\tif (GetDIBits(\r\n\t\thdc,// hdc of the image to take the memory\r\n\t\thbitmap,// our bitmap handle\r\n\t\t0,// first scan\r\n\t\tbitmapInfo->bmiHeader.biHeight,// scan lines\r\n\t\timgMem,// bitmap bits\r\n\t\tbitmapInfo,// bitmap data structure\r\n\t\tDIB_RGB_COLORS)// RGB or palette index\r\n\t\t==NULL){\r\n\r\n\t\t// failed, go out\r\n\t\tdelete[] imgMem;\r\n\t\tdelete[] bitmapInfo;\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t}// if\r\n\r\n\t// Now save all that information to the disk...\r\n\t// open the file\r\n\tif ((file=CreateFile(\r\n\t\tfilename,// file name\r\n\t\tGENERIC_WRITE,// desired access\r\n\r\n\t\t0,// share mode, don't share it\r\n\t\tNULL,// security attributes, don't care\r\n\t\t(overwrite?CREATE_ALWAYS:CREATE_NEW),// creation distribution\r\n\t\tFILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,// flags\r\n\t\tNULL))// template file\r\n\t\t==INVALID_HANDLE_VALUE){\r\n\r\n\t\t// failed, go out\r\n\t\tdelete[] imgMem;\r\n\t\tdelete[] bitmapInfo;\r\n\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\treleaseDC(hdc);\r\n\t}// if\r\n\r\n\t// save the header\r\n\twritten=0;\r\n\ttoWrite=sizeof(header);\r\n\ttotalWritten=0;\r\n\twhile (toWrite>0){\r\n\t\tif (WriteFile(\r\n\t\t\tfile,// file to write to\r\n\t\t\t(&header)+totalWritten,// buffer\r\n\t\t\ttoWrite,// bytes to write\r\n\t\t\t&written,// bytes written, to be returned...\r\n\t\t\tNULL)// overlapped stuff\r\n\t\t\t==0){\r\n\r\n\t\t\t// failed, go out\r\n\t\t\tCloseHandle(file);\r\n\t\t\tdelete[] imgMem;\r\n\t\t\tdelete[] bitmapInfo;\r\n\t\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\t\treleaseDC(hdc);\r\n\t\t}// if\r\n\r\n\t\ttoWrite-=written;\r\n\t\ttotalWritten+=written;\r\n\t\twritten=0;\r\n\t}// if\r\n\r\n\t// save the bitmapInfoHeader and RGBQUAD\r\n\ttotalWritten=0;\r\n\twritten=0;\r\n\ttoWrite=sizeof(BITMAPINFOHEADER)+hdrInfo->biClrUsed*sizeof(RGBQUAD);\r\n\twhile (toWrite>0){\r\n\t\tif (WriteFile(\r\n\t\t\tfile,// file to write to\r\n\t\t\thdrInfo+totalWritten,// buffer\r\n\t\t\ttoWrite,// bytes to write\r\n\t\t\t&written,// bytes written, to be returned...\r\n\t\t\tNULL)// overlapped stuff\r\n\t\t\t==0){\r\n\r\n\t\t\t// failed, go out\r\n\t\t\tCloseHandle(file);\r\n\t\t\tdelete[] imgMem;\r\n\t\t\tdelete[] bitmapInfo;\r\n\t\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\t\treleaseDC(hdc);\r\n\t\t}// if\r\n\r\n\t\ttoWrite-=written;\r\n\t\ttotalWritten+=written;\r\n\t\twritten=0;\r\n\t}// if\r\n\r\n\t// save the color indices\r\n\ttotalWritten=0;\r\n\twritten=0;\r\n\ttoWrite=hdrInfo->biSizeImage;\r\n\twhile (toWrite>0){\r\n\t\tif (WriteFile(\r\n\t\t\tfile,// file to write to\r\n\t\t\timgMem+totalWritten,// buffer\r\n\t\t\ttoWrite,// bytes to write\r\n\t\t\t&written,// bytes written, to be returned...\r\n\t\t\tNULL)// overlapped stuff\r\n\t\t\t==0){\r\n\r\n\t\t\t// failed, go out\r\n\t\t\tCloseHandle(file);\r\n\t\t\tdelete[] imgMem;\r\n\t\t\tdelete[] bitmapInfo;\r\n\t\t\tDeleteObject((HGDIOBJ)hbitmap);\r\n\t\t\treleaseDC(hdc);\r\n\t\t}// if\r\n\r\n\t\ttoWrite-=written;\r\n\t\twritten=0;\r\n\t}// if\r\n\r\n\t// time to release all the resources allocated until now\r\n\tCloseHandle(file);\r\n\tdelete[] imgMem;\r\n\tdelete[] bitmapInfo;\r\n\tDeleteObject((HGDIOBJ)hbitmap);\r\n\treleaseDC(hdc);\r\n*/\r\n\treturn true;// all ok\r\n}// saveAsBmpFile\r\n/*\r\n// getDC obtains the DC attached to the surface. It also locks the surface,\r\n// so it cannot be used for anything until it's released with releaseDC.\r\n// getDC has to be used quite carefully, and the obtained DC has to be\r\n// released as soon as possible (look at the getDC documentation in the DX\r\n// SDK for more info).\r\nbool ddSurfaceClass::getDC(HDC* hdc)\r\n{\r\n\tHRESULT err;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// get the dc handle, if error is WasStillDrawing, try again\r\n\tdo {\r\n\t\terr=srfOffScreen->GetDC(hdc);\r\n\t}while(err==DDERR_WASSTILLDRAWING);\r\n\tif (FAILED(err)) return false;\r\n\r\n\treturn true;// all ok\r\n}// getDC\r\n\r\nbool ddSurfaceClass::releaseDC(HDC hdc)\r\n{\r\n\tif (!isReady()) return false;\r\n\r\n\tif (FAILED(srfOffScreen->ReleaseDC(hdc))) return false;\r\n\r\n\treturn true;// all ok\r\n}// releaseDC\r\n*/\r\n\r\n// Don't lock your surfaces unless you really know what you are doing!\r\n// While a surface is locked, it cannot be used for anything until it's\r\n// unlocked... You should unlock a locked surface as soon as possible,\r\n// to avoid problems with system halts and stuff (if missused)\r\n// (Look at the getDC documentation in the DX SDK for more info).\r\nbool ddSurfaceClass::lock(bool onlyRead, bool onlyWrite, DWORD* pitch, LPVOID* pointer)\r\n{\r\n/*#if DIRECTDRAW_VERSION < 0x0700\r\n\tDDSURFACEDESC sd={sizeof(sd)};\r\n#else// DIRECTDRAW_VERSION\r\n\tDDSURFACEDESC2 sd={sizeof(sd)};\r\n#endif// DIRECTDRAW_VERSION\r\n\r\n\tif (!isReady()) return false;\r\n\tif (locked) return false;\r\n\r\n\tif (FAILED(srfOffScreen->Lock(\r\n\t\tNULL,// rectangle to lock, as it's null, it locks it all\r\n\t\t&sd,// will come back with important info\r\n\t\tDDLOCK_WAIT | // wait if the surface is busy\r\n\t\t(onlyWrite?DDLOCK_WRITEONLY:DDLOCK_WRITEONLY) | // write only?\r\n\t\t(onlyRead?DDLOCK_READONLY:DDLOCK_READONLY),// read only?\r\n\t\tNULL))){// non used parameter\r\n\r\n\t\t// lock failed\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// return important info\r\n\t*pitch=sd.lPitch;\r\n\t*pointer=sd.lpSurface;\r\n\r\n\t// mark the surface as locked and go away\r\n\tlocked=true;*/\r\n\treturn true;// all ok\r\n}// lock\r\n\r\n// It's what you use to unlock a surface.\r\nbool ddSurfaceClass::unlock()\r\n{\r\n/*\tif (!isReady()) return false;\r\n\tif (!locked) return false;// it should be locked to be unlocked\r\n\r\n\tif (FAILED(srfOffScreen->Unlock(NULL))){\r\n\t\treturn false;// unlock failed!\r\n\t}// if\r\n\r\n\t// mark the surface as unlocked and go away\r\n\tlocked=false;*/\r\n\treturn true;// all ok\r\n}// unlock\r\n\r\n// This method obtains the color of a pixel in the surface, in a DWORD.\r\n// can fail if the surface is lost\r\nbool ddSurfaceClass::getDwordFromPixel(int x, int y, DWORD& color)\r\n{\r\n/*#if DIRECTDRAW_VERSION < 0x0700\r\n\tDDSURFACEDESC ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#else// DIRECTDRAW_VERSION\r\n\tDDSURFACEDESC2 ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#endif// DIRECTDRAW_VERSION\r\n\r\n\t// lock the surface\r\n\tif (FAILED(srfOffScreen->Lock(\r\n\t\tNULL,// dest rect\r\n\t\t&ddsd,// surface desc\r\n\t\tDDLOCK_NOSYSLOCK|DDLOCK_WAIT,// flags\r\n\t\tNULL// event, future param\r\n\t\t)))\r\n\t\treturn false;\r\n\r\n\t// get the pixel\r\n\tcolor=*((DWORD*)(\r\n\t\t((BYTE*)ddsd.lpSurface)+// original pointer\r\n\t\t(x*(bpp/8))+\r\n\t\t(y*ddsd.lPitch)\r\n\t\t));\r\n\t// take the useless bits away\r\n\tcolor&=((1<<bpp)-1);\r\n\r\n\t// unlock the surface\r\n\tsrfOffScreen->Unlock(NULL);\r\n*/\r\n\treturn true;\r\n}\r\n\r\n// This method converts an RGB value to a DWORD, according to this\r\n// surface's properties\r\n// can fail if the surface is lost\r\nbool ddSurfaceClass::getDwordFromRGB(int r, int g, int b, DWORD& color)\r\n{\r\n/*#if DIRECTDRAW_VERSION < 0x0700\r\n\tDDSURFACEDESC ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#else// DIRECTDRAW_VERSION\r\n\tDDSURFACEDESC2 ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#endif// DIRECTDRAW_VERSION\r\n\tHDC hdc;\r\n\tCOLORREF oldColor;\r\n\tbool err;\r\n\r\n\t// COLOR MATCH IT!\r\n\t// 1- set the pixel in (0,0) with the asked color\r\n\tif (!getDC(&hdc)) return false;\r\n\toldColor=GetPixel(hdc, 0, 0);\r\n\tSetPixel(hdc, 0, 0, RGB(r, g, b));\r\n\treleaseDC(hdc);\r\n\r\n\t// 2- get the changed pixel's equivalent DWORD\r\n\terr=getDwordFromPixel(0, 0, color);\r\n\r\n\t// 3- set the pixel color back!\r\n\tif (!getDC(&hdc)) return false;\r\n\tSetPixel(hdc, 0, 0, oldColor);\r\n\treleaseDC(hdc);\r\n\r\n\t// 4- now see at getDwordFromPixel's return value\r\n\tif (!err) return false;\r\n*/\r\n\t// that's been all\r\n\treturn true;\r\n}\r\n/*\r\n// Tell us whether this surface is lost or not\r\n// (that is, if it needs to be restored)\r\n// (protected version)\r\n#if DIRECTDRAW_VERSION < 0x0700\r\nbool ddSurfaceClass::isLostSrf(bool* errorCode, LPDIRECTDRAWSURFACE& srf)\r\n#else // DIRECTDRAW_VERSION\r\nbool ddSurfaceClass::isLostSrf(bool* errorCode, LPDIRECTDRAWSURFACE7& srf)\r\n#endif // DIRECTDRAW_VERSION\r\n{\r\n\tHRESULT res;\r\n\tbool lost;\r\n\r\n\t// it's wrong until we show the contrary\r\n\tif (errorCode!=NULL) *errorCode=false;\r\n\r\n\t// is it lost?\r\n\tres=srf->IsLost();\r\n\r\n\t// test whether it's lost, restored or in an error state\r\n\tif (res==DDERR_SURFACELOST){\r\n\t\t// the surface is lost\r\n\t\tlost=true;\r\n\t}else{\r\n\t\tif (FAILED(res)){\r\n\t\t\t// it's been an error, return before time!\r\n\t\t\treturn true;// error and lost, that's why it returns true\r\n\t\t}else{\r\n\t\t\t// the surface isn't lost\r\n\t\t\tlost=false;\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// all ok\r\n\tif (errorCode!=NULL) *errorCode=true;\r\n\r\n\t// time to inform the state of this\r\n\treturn lost;\r\n}// isLostSrf\r\n\r\n// Restore a lost surface (protected version)\r\n#if DIRECTDRAW_VERSION < 0x0700\r\nbool ddSurfaceClass::restoreSrf(LPDIRECTDRAWSURFACE& srf)\r\n#else // DIRECTDRAW_VERSION\r\nbool ddSurfaceClass::restoreSrf(LPDIRECTDRAWSURFACE7& srf)\r\n#endif // DIRECTDRAW_VERSION\r\n{\r\n\t// restore the surface if possible\r\n\tif (FAILED(srf->Restore()))\r\n\t\treturn false;// it failed\r\n\r\n\t// it's all ok!\r\n\treturn true;\r\n}// restoreSrf\r\n*/\r\n// Tell us whether this surface is lost or not\r\n// (that is, if it needs to be restored)\r\nbool ddSurfaceClass::isLost(bool* errorCode)\r\n{\r\n/*\t// it's wrong until we show the contrary\r\n\tif (errorCode!=NULL) *errorCode=false;\r\n\r\n\t// are we ready for this?\r\n\tif (!isReady()) return true;// error and lost, that's why it returns true\r\n\r\n\t// see whether it's lost or not\r\n\treturn isLostSrf(errorCode, srfOffScreen);*/\r\n\treturn false;\r\n}// isLost\r\n\r\n// Restore this surface, if it's lost\r\nbool ddSurfaceClass::restore()\r\n{\r\n/*\t// are we ready for this?\r\n\tif (!isReady()) return false;// error\r\n\r\n\t// restore the surface...\r\n\treturn restoreSrf(srfOffScreen);*/\r\n\treturn true;\r\n}// restore\r\n\r\n// Methods of the class directDrawClass\r\n// have to be called before any other method of any other class\r\n// inherited of ddSurfaceClass\r\nbool directDrawClass::init()\r\n{\r\n\tif (isDDReady) return false;\r\n\r\n\t// change static methods of the base\r\n\tisDDReady=true;\r\n\r\n/*\tDDObject=this;// to let all the ddSurface objects access to their DirectDraw main object*/\r\n\tinitialized=true;// change flag\r\n\tvideoModeReady=false;// clean flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\nbool directDrawClass::end()\r\n{\r\n\tif (initialized==false) return false;\r\n\r\n\t// close the video mode\r\n\tif (videoModeReady){\r\n\t\tif (!closeVideoMode()) return false;\r\n\t}\r\n\r\n\t// bye bye dd\r\n\tscreenSurface=NULL;\r\n\tsrfOffScreen=NULL;\r\n\r\n\t// clear the static variable\r\n\tisDDReady=false;\r\n\r\n/*\tDDObject=NULL;// so it's obvious the object doesn't exist anymore*/\r\n\tinitialized=false;// clean flag\r\n\tvideoModeReady=false;// clean flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\nbool directDrawClass::closeVideoMode()\r\n{\r\n\tif (!videoModeReady) return false;\r\n\r\n\t// bye bye surface...\r\n/*\tsrfOnScreen->Release();\r\n\tsrfOnScreen=NULL;*/\r\n\r\n\tvideoModeReady=false;\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\nbool directDrawClass::setVideoMode(int x, int y, int bpp, int backbuffers)\r\n{\r\n\tif (!initialized) return false;\r\n\r\n\tif (backbuffers<1) return false;\r\n\r\n\tscreenSurface=SDL_SetVideoMode(x, y, bpp, SDL_ANYFORMAT);\r\n\tsrfOffScreen=screenSurface;\r\n\r\n\txRes=x; yRes=y; directDrawClass::bpp=bpp;\r\n/*\tdirectDrawClass::backbuffers=backbuffers;*/\r\n\tvideoModeReady=true;// change flag\r\n\r\n\t// get the info for color handling\r\n/*\tif (!updateColorInfo()){\r\n\t\t// failed\r\n\t\tsrfOnScreen->Release();// bye bye my surface\r\n\t\tvideoModeReady=false;\r\n\t\treturn false;\r\n\t}\r\n*/\r\n\treturn true;// all ok\r\n}\r\n\r\n// fill the *Mask, *Off and *Size variables for color handling.\r\nbool directDrawClass::updateColorInfo()\r\n{\r\n/*\tDDPIXELFORMAT pf={sizeof(pf)};\r\n\tint i, j, tMask, tSize, tOff;// temp variables\r\n\tint dwordSize=sizeof(DWORD)*8;// to know the size in bits of a dword\r\n\r\n\tif (!isVideoModeReady()) return false;\r\n\r\n\t// fill pf\r\n\tif (FAILED(srfOnScreen->GetPixelFormat(&pf))) return false;\r\n\r\n\t// fill the palettized field\r\n\tpalettized=false;\r\n\r\n\tif (bpp<=8){\r\n\t\t// it's a palettized mode\r\n\t\tpalettized=true;\r\n\r\n\t\t// In such a case, we'll just set all to zero, and quit\r\n\t\t// without error\r\n\t\trOff=0; rSize=0; r8LessSize=8;\r\n\t\tgOff=0; gSize=0; g8LessSize=8;\r\n\t\tbOff=0; bSize=0; b8LessSize=8;\r\n\r\n\t\treturn true;\r\n\t}// if\r\n\r\n\t// now fill *Mask\r\n\trMask=pf.dwRBitMask;\r\n\tgMask=pf.dwGBitMask;\r\n\tbMask=pf.dwBBitMask;\r\n\r\n\t// now fill *Off and *Size\r\n\t// We use the same process for the three components (r, g, b)\r\n\tfor (i=0; i<3; i++){\r\n\t\t// load our component\r\n\t\tswitch(i){\r\n\t\tcase 0:// time for red\r\n\t\t\ttMask=rMask; break;\r\n\t\tcase 1:// time for green\r\n\t\t\ttMask=gMask; break;\r\n\t\tcase 2:// time for blue\r\n\t\t\ttMask=bMask; break;\r\n\t\t}// switch\r\n\r\n\t\t// now see what's the offset for this component\r\n\t\tfor (j=0; j<dwordSize; j++){\r\n\t\t\tif ((tMask&1)==1) break;// break as soon as a set bit is found\r\n\r\n\t\t\t// time for the next bit\r\n\t\t\ttMask>>=1;\r\n\t\t}// for j\r\n\r\n\t\tif (j==dwordSize){\r\n\t\t\t// if it happens, tMask was zero\r\n\t\t\t// that's bad news, as it's not a palettized mode\r\n\t\t\treturn false;// error!\r\n\t\t}else{\r\n\t\t\t// now we know what's this component offset in bits\r\n\t\t\ttOff=j;\r\n\t\t}// if\r\n\r\n\t\t// let's see what's the size for this component\r\n\t\tfor (; j<dwordSize; j++){\r\n\t\t\tif ((tMask&1)==0) break;// break as soon as a 0 bit is found\r\n\r\n\t\t\t// time for the next bit\r\n\t\t\ttMask>>=1;\r\n\t\t}// for j\r\n\r\n\t\t// now we know what's this component size in bits\r\n\t\ttSize=j-tOff;\r\n\r\n\t\t// save this component info\r\n\t\tswitch(i){\r\n\t\tcase 0:// time for red\r\n\t\t\trOff=tOff; rSize=tSize;\r\n\t\t\tr8LessSize=8-rSize;\r\n\t\t\tbreak;\r\n\t\tcase 1:// time for green\r\n\t\t\tgOff=tOff; gSize=tSize;\r\n\t\t\tg8LessSize=8-gSize;\r\n\t\t\tbreak;\r\n\t\tcase 2:// time for blue\r\n\t\t\tbOff=tOff; bSize=tSize;\r\n\t\t\tb8LessSize=8-bSize;\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t}// for i\r\n*/\r\n\treturn true;// all ok\r\n}// updateColorInfo\r\n\r\n// convert 'palette' to the current video mode (only if it's an 8 bits\r\n// video mode).\r\n// This 8 bit version is very slow, as it uses some system locks for\r\n// every color entry.\r\n// The format of 'palette' is the one for PCXs, that is, three bytes\r\n// (8 bits R, G and B) for every entry. 'pal8' is an only byte for every\r\n// entry.\r\nbool directDrawClass::convertPaletteTo8(\r\n\tconst BYTE* palette,// original palette in PCX format (see above)\r\n\tBYTE* pal8,// resulting palette (memory should be allocated already)\r\n\tint entries)// amount of entries (colors)\r\n{\r\n/*\tint i;\r\n\tDWORD dwColor;\r\n\tconst BYTE* pal=palette; BYTE* palTo=pal8;\r\n\r\n\tif (!isVideoModeReady()) return false;\r\n\tif (bpp!=8) return false;// only for 8 bits video modes\r\n\r\n\t// convert every entry to its 8 bit color\r\n\tfor (i=0; i<entries; i++){\r\n\t\tif (!getDwordFromRGB(pal[0], pal[1], pal[2], dwColor))\r\n\t\t\treturn false;// error\r\n\r\n\t\t// we only use 8 bits, discard the unused 24 bits\r\n\t\t*palTo=(BYTE)(dwColor & 255);\r\n\r\n\t\tpal+=3;\r\n\t\tpalTo++;\r\n\t}// for i\r\n*/\r\n\treturn true;// all ok\r\n}// convertPaletteTo8\r\n\r\n// convert 'palette' to the current video mode (only if it's a 16 bits\r\n// video mode)\r\n// The format of 'palette' is the one for PCXs, that is, three bytes\r\n// (8 bits R, G and B) for every entry. 'pal16' is an only word for every\r\n// entry.\r\nbool directDrawClass::convertPaletteTo16(\r\n\tconst BYTE* palette,// original palette in PCX format (see above)\r\n\tWORD* pal16,// resulting palette (memory should be allocated already)\r\n\tint entries)// amount of entries (colors)\r\n{\r\n/*\tint i;\r\n\tDWORD dwColor;\r\n\tconst BYTE* pal=palette; WORD* palTo=pal16;\r\n\r\n\tif (!isVideoModeReady()) return false;\r\n\tif (bpp!=16) return false;// only for 16 bits video modes\r\n\r\n\t// convert every entry to its 16 bit color\r\n\tfor (i=0; i<entries; i++){\r\n\t\tdwColor=getDwordFromRGBFast(*this, pal[0], pal[1], pal[2]);\r\n\r\n\t\t// we only use 16 bits, discard the unused word\r\n\t\t*palTo=(WORD)(dwColor & 65535);\r\n\r\n\t\tpal+=3;\r\n\t\tpalTo++;\r\n\t}// for i\r\n*/\r\n\treturn true;\r\n}// convertPaletteTo16\r\n\r\nbool directDrawClass::flip()\r\n{\r\n/*\tHRESULT ret;\r\n\r\n\tif (FAILED(ret=srfOnScreen->Flip(\r\n\t\tNULL,// next surface (any)\r\n\t\tDDFLIP_WAIT)// wait until it's flipped\r\n\t\t)){\r\n\r\n\t\t// was the surface lost???\r\n\t\tif (ret==DDERR_SURFACELOST){\r\n\t\t\t// bla bla\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n*/\r\n\tSDL_UpdateRect(screenSurface, 0, 0, 0, 0) ;\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// was the surface initialized enough as to be used?\r\nbool directDrawClass::isReady()\r\n{\r\n\treturn initialized && videoModeReady;\r\n}\r\n\r\n// Tell us whether the main surface is lost or not\r\n// (that is, if it needs to be restored)\r\nbool directDrawClass::isLost(bool* errorCode)\r\n{\r\n/*\t// it's wrong until we show the contrary\r\n\tif (errorCode!=NULL) *errorCode=false;\r\n\r\n\t// are we ready for this?\r\n\tif (!isReady()) return true;// error and lost, that's why it returns true\r\n\r\n\t// see whether it's lost or not\r\n\treturn isLostSrf(errorCode, srfOnScreen);*/\r\n\treturn false;\r\n}// isLost\r\n\r\n// Restore the main surface\r\nbool directDrawClass::restore()\r\n{\r\n/*\t// are we ready for this?\r\n\tif (!isReady()) return false;// error\r\n\r\n\t// restore the surface...\r\n\treturn restoreSrf(srfOnScreen);*/\r\n\treturn true;\r\n}// restore\r\n\r\n// Methods of ddSpriteClass\r\nbool ddSpriteClass::create(int x, int y, bool videoMemory)\r\n{\r\n\txRes=x; yRes=y;\r\n\r\n\tsrfOffScreen=SDL_CreateRGBSurface(videoMemory?SDL_HWSURFACE:SDL_SWSURFACE, x, y, bpp, 0, 0, 0, 0);\r\n\tif (srfOffScreen==NULL) return false;\r\n\r\n\txRes=x;\r\n\tyRes=y;\r\n\trealWidth=x;\r\n\trealHeight=y;\r\n\tinVideoMemory=videoMemory;\r\n\tinitialized=true;// change flag\r\n\r\n/*#if DIRECTDRAW_VERSION < 0x0700\r\n\tDDSURFACEDESC ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#else// DIRECTDRAW_VERSION\r\n\tDDSURFACEDESC2 ddsd={sizeof(ddsd)};// MS's trick to zero it\r\n#endif// DIRECTDRAW_VERSION\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\tif (initialized) return false;// we have to create it only once\r\n\r\n\t// fill the struct...\r\n\t// fields to be used\r\n\tddsd.dwFlags=DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH;\r\n\tddsd.ddsCaps.dwCaps=// capabilities\r\n\t\tDDSCAPS_OFFSCREENPLAIN |\r\n\t\t(videoMemory?DDSCAPS_VIDEOMEMORY:DDSCAPS_SYSTEMMEMORY);\r\n\tddsd.dwWidth=x; ddsd.dwHeight=y;// size\r\n\t// call the api itself\r\n\tif (FAILED(lpDD->CreateSurface(\r\n\t\t&ddsd,// surface description\r\n\t\t&srfOffScreen,// new surface pointer\r\n\t\tNULL// future param\r\n\t\t))){\r\n\r\n\t\t// failed... maybe because lacking of video memory\r\n\t\tif (videoMemory=true){\r\n\t\t\treturn create(x, y, false);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// actualize fields\r\n\txRes=x;\r\n\tyRes=y;\r\n\trealWidth=x;\r\n\trealHeight=y;\r\n\tinVideoMemory=videoMemory;\r\n\tinitialized=true;// change flag\r\n*/\r\n\treturn true;\r\n}\r\n\r\nbool ddSpriteClass::free()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\tsrfOffScreen->Release();\r\n\tsrfOffScreen=NULL;\r\n\r\n\tinitialized=false;\r\n*/\r\n\treturn true;\r\n}\r\n\r\n/*bool ddSpriteClass::genericLoadBmp(char* name, bool isResource, HINSTANCE hInstance, bool videoMemory)\r\n{\r\n\tHBITMAP hbm;// bitmap handle\r\n\tHBITMAP hbmOld;// other bitmap handle\r\n\tBITMAP bm;// for info\r\n\tHDC hdcImage, hdc;// two hdcs for the blitting\r\n\tbool created=false;// just to know whether we've created the surface or not\r\n\r\n\t// load the image itself\r\n\tif (isResource){\r\n\t\thbm=(HBITMAP)LoadImage(\r\n\t\t\thInstance,\r\n\t\t\tname,// resource name\r\n\t\t\tIMAGE_BITMAP,\r\n\t\t\t0, 0,// dest coordinates\r\n\t\t\tLR_CREATEDIBSECTION);\r\n\t}else{\r\n\t\thbm=(HBITMAP)LoadImage(\r\n\t\t\tNULL,// hInstance\r\n\t\t\tname,// path\r\n\t\t\tIMAGE_BITMAP,\r\n\t\t\t0, 0,// dest coordinates\r\n\t\t\tLR_LOADFROMFILE | LR_CREATEDIBSECTION);\r\n\t}\r\n\r\n\tif (hbm==NULL) return false;\r\n\r\n\t// to see the size of the bitmap\r\n\tGetObject(hbm, sizeof(bm), &bm);\r\n\r\n\t// create the surface needed... or work with the existent one\r\n\tif (!initialized){\r\n\t\t// create the surface\r\n\t\tif (!create(bm.bmWidth, bm.bmHeight, videoMemory)){\r\n\t\t\t// error, bye bye all\r\n\t\t\tDeleteObject(hbm);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tcreated=true;// we created it\r\n\t}else{\r\n\t\t// is this surface able to handle the bitmap???\r\n\t\tif (realWidth<bm.bmWidth || realHeight<bm.bmHeight){\r\n\t\t\t// error, bye bye all\r\n\t\t\tDeleteObject(hbm);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// now get both hdcs\r\n\t// 1- image\r\n\thdcImage=CreateCompatibleDC(NULL);// it's ok even if it sounds bad\r\n\thbmOld=(HBITMAP)SelectObject(hdcImage, hbm);\r\n\t// 2- surface\r\n\tif (!getDC(&hdc)){\r\n\t\t// error, bye bye all\r\n\t\tSelectObject(hdcImage, hbmOld);\r\n\t\tDeleteDC(hdcImage);\r\n\t\tDeleteObject(hbm);\r\n\t\t// if we created the surface, let's kill it\r\n\t\tif (created) free();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// copy that image\r\n\tBitBlt(\r\n\t\thdc,// hdc dest\r\n\t\t0, 0,// x y dest\r\n\t\tbm.bmWidth, bm.bmHeight,// size\r\n\t\thdcImage,// hdc source\r\n\t\t0, 0,// // x y src\r\n\t\tSRCCOPY// blt mode\r\n\t\t);\r\n\r\n\t// update the \"virtual\" size\r\n\txRes=bm.bmWidth;\r\n\tyRes=bm.bmHeight;\r\n\r\n\t// free all\r\n\treleaseDC(hdc);\r\n\tSelectObject(hdcImage, hbmOld);\r\n\tDeleteDC(hdcImage);\r\n\tDeleteObject(hbm);\r\n\r\n\treturn true;\r\n}\r\n*/\r\nbool ddSpriteClass::loadBmpFile(char* path, bool videoMemory)\r\n{\r\n/*\treturn genericLoadBmp(path, false, 0, videoMemory);*/\r\n\treturn true;\r\n}\r\n\r\n/*bool ddSpriteClass::loadBmpResource(char* resource, HINSTANCE hInstance, bool videoMemory)\r\n{\r\n\treturn genericLoadBmp(resource, true, hInstance, videoMemory);\r\n}*/\r\n\r\n// create an 8 bits surface from an RLE (run length encoding, as in PCX),\r\n// Currently, this method assumes that rleLen is right, so it does\r\n// not check it to see whether the image is valid or not.\r\n// IMPORTANT NOTE ABOUT THE bytesPerLine PARAMETER:\r\n// \"bytesPerLine\" is, supposedly, the width of the image.\r\n// However, in PCX files, it can be different, ie when the image width\r\n// is an odd value. Because of that, both values have to be used\r\n// differently: this way, bytesPerLine is only used for parsing the\r\n// RLE data and creating the surface for the image obtained, and width\r\n// is used for anything else (blitting and working with the image itself,\r\n// for example).\r\n// Unless you use the RLE methods directly (instead of the PCX functions),\r\n// you shouldn't care about it, as this wrapper hides the bytesPerLine\r\n// value under the name of realWidth, so helping the surfaces work\r\n// coherently.\r\nbool ddSpriteClass::createFromRLE8(\r\n\tBYTE* rle,// pointer to the memory with the RLE information (in 8 bits)\r\n\tDWORD rleLen,// size in bytes of the memory in 'rle'\r\n\tint bytesPerLine,// real width of the encoded image\r\n\tint width, int height,// size of the encoded image\r\n\tBYTE* palette,// palette as returned by convertPaletteTo8\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tDWORD pitch;// surface pitch in bytes\r\n\tBYTE* ptr;// ptr to the screen\r\n\tbool created=false;\r\n\tint x, y;\r\n\tint length;// for run length encoding... (compressed bytes)\r\n\r\n\t// variables for optimization in the decompression\r\n\tBYTE* ptrMax;\r\n\tBYTE colorTemp;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=8) return false;\r\n\r\n\t// create the surface needed... or work with the existent one\r\n\tif (!initialized){\r\n\t\t// create the surface\r\n\t\tif (!create(bytesPerLine, height, videoMemory))\r\n\t\t\treturn false;// error creating the surface\r\n\t\tcreated=true;// set the flag\r\n\t}else{\r\n\t\t// is this surface able to handle the bitmap???\r\n\t\tif (realWidth<bytesPerLine || realHeight<height)\r\n\t\t\treturn false;// the surface doesn't fit\r\n\t}// if\r\n\r\n\t// time to lock it as read only!\r\n\tif (!lock(false, true, &pitch, (LPVOID*)(&ptr))){\r\n\t\t// it failed...\r\n\t\t// only terminate the surface if we've created it here\r\n\t\tif (created) free();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// let's uncompress the RLE while blitting to the surface\r\n\tfor (y=0; y<height; y++){\r\n\t\tfor (x=0; x<bytesPerLine;){\r\n\t\t\tif (((*rle) & 192)==192){\r\n\t\t\t\t// it's a compressed line... let's see its color and\r\n\t\t\t\t// size\r\n\t\t\t\tlength=(*rle)&63;// size\r\n\t\t\t\trle++;// *rle is the color\r\n\t\t\t\tx+=length;\r\n\r\n\t\t\t\t// if the RLE is wrong and tries to bypass the size\r\n\t\t\t\t// limits of the image, don't let it happen.\r\n\t\t\t\tif (x>bytesPerLine){\r\n\t\t\t\t\tlength-=x-bytesPerLine;\r\n\t\t\t\t\tx=bytesPerLine;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// draw the line\r\n\t\t\t\tptrMax=ptr+length;// max pointer\r\n\t\t\t\tcolorTemp=palette[*rle];// color to be blt\r\n\t\t\t\tfor (; ptr<ptrMax; ptr++){\r\n\t\t\t\t\t*ptr=colorTemp;\r\n\t\t\t\t}// for ptr\r\n\r\n\t\t\t}else{\r\n\t\t\t\t// it's a single pixel\r\n\t\t\t\t*ptr=palette[*rle];\r\n\t\t\t\tptr++;\r\n\t\t\t\tx++;\r\n\t\t\t}// if\r\n\r\n\t\t\t// go to the next char\r\n\t\t\trle++;\r\n\t\t}// for x\r\n\r\n\t\t// advance to the next line\r\n\t\tptr+=(pitch-bytesPerLine);\r\n\t}// for y\r\n\r\n\t// it's ready, go away\r\n\tunlock();\r\n\r\n\t// update the \"virtual\" size of this surface\r\n\txRes=width;\r\n\tyRes=height;\r\n*/\r\n\treturn true;// all ok\r\n}// createFromRLE8\r\n\r\n// create an 16 bits surface from an RLE (run length encoding, as in PCX),\r\n// Currently, this method assumes that rleLen is right, so it does\r\n// not check it to see whether the image is valid or not.\r\n// IMPORTANT NOTE ABOUT THE bytesPerLine PARAMETER:\r\n// \"bytesPerLine\" is, supposedly, the width of the image.\r\n// However, in PCX files, it can be different, ie when the image width\r\n// is an odd value. Because of that, both values have to be used\r\n// differently: this way, bytesPerLine is only used for parsing the\r\n// RLE data and creating the surface for the image obtained, and width\r\n// is used for anything else (blitting and working with the image itself,\r\n// for example).\r\n// Unless you use the RLE methods directly (instead of the PCX functions),\r\n// you shouldn't care about it, as this wrapper hides the bytesPerLine\r\n// value under the name of realWidth, so helping the surfaces work\r\n// coherently.\r\nbool ddSpriteClass::createFromRLE16(\r\n\tBYTE* rle,// pointer to the memory with the RLE information (in 8 bits)\r\n\tDWORD rleLen,// size in bytes of the memory in 'rle'\r\n\tint bytesPerLine,// real width of the encoded image\r\n\tint width, int height,// size of the encoded image\r\n\tWORD* palette,// palette as returned by convertPaletteTo16\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tDWORD pitch;// surface pitch in bytes\r\n\tWORD* ptr;// ptr to the screen\r\n\tbool created=false;\r\n\tint x, y;\r\n\tint length;// for run length encoding... (compressed bytes)\r\n\r\n\t// variables for optimization in the decompression\r\n\tWORD* ptrMax;\r\n\tWORD colorTemp;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=16) return false;\r\n\r\n\t// create the surface needed... or work with the existent one\r\n\tif (!initialized){\r\n\t\t// create the surface\r\n\t\tif (!create(bytesPerLine, height, videoMemory))\r\n\t\t\treturn false;// error creating the surface\r\n\t\tcreated=true;// set the flag\r\n\t}else{\r\n\t\t// is this surface able to handle the bitmap???\r\n\t\tif (realWidth<bytesPerLine || realHeight<height)\r\n\t\t\treturn false;// the surface doesn't fit\r\n\t}// if\r\n\r\n\t// time to lock it as read only!\r\n\tif (!lock(false, true, &pitch, (LPVOID*)(&ptr))){\r\n\t\t// it failed...\r\n\t\t// only terminate the surface if we've created it here\r\n\t\tif (created) free();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// let's uncompress the RLE while blitting to the surface\r\n\tfor (y=0; y<height; y++){\r\n\t\tfor (x=0; x<bytesPerLine;){\r\n\t\t\tif (((*rle) & 192)==192){\r\n\t\t\t\t// it's a compressed line... let's see its color and\r\n\t\t\t\t// size\r\n\t\t\t\tlength=(*rle)&63;// size\r\n\t\t\t\trle++;// *rle is the color\r\n\t\t\t\tx+=length;\r\n\r\n\t\t\t\t// if the RLE is wrong and tries to bypass the size\r\n\t\t\t\t// limits of the image, don't let it happen.\r\n\t\t\t\tif (x>bytesPerLine){\r\n\t\t\t\t\tlength-=x-bytesPerLine;\r\n\t\t\t\t\tx=bytesPerLine;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// draw the line\r\n\t\t\t\tptrMax=ptr+length;// max pointer\r\n\t\t\t\tcolorTemp=palette[*rle];// color to be blt\r\n\t\t\t\tfor (; ptr<ptrMax; ptr++){\r\n\t\t\t\t\t*ptr=colorTemp;\r\n\t\t\t\t}// for ptr\r\n\r\n\t\t\t}else{\r\n\t\t\t\t// it's a single pixel\r\n\t\t\t\t*ptr=palette[*rle];\r\n\t\t\t\tptr++;\r\n\t\t\t\tx++;\r\n\t\t\t}// if\r\n\r\n\t\t\t// go to the next char\r\n\t\t\trle++;\r\n\t\t}// for x\r\n\r\n\t\t// advance to the next line\r\n\t\tptr=(WORD*)(((BYTE*)(ptr))+pitch-bytesPerLine*2);\r\n\t}// for y\r\n\r\n\t// it's ready, go away\r\n\tunlock();\r\n\r\n\t// update the \"virtual\" size of this surface\r\n\txRes=width;\r\n\tyRes=height;\r\n*/\r\n\treturn true;// all ok\r\n}// createFromRLE16\r\n\r\n// createFromRLE generic version\r\n// Create a surface from an RLE (run length encoding, as in PCX),\r\n// whatever the current video mode is (currently, only working for\r\n// 8 and 16 bits).\r\n// Currently, this method assumes that rleLen is right, so it does\r\n// not check it to see whether the image is valid or not.\r\n// IMPORTANT NOTE ABOUT THE bytesPerLine PARAMETER:\r\n// \"bytesPerLine\" is, supposedly, the width of the image.\r\n// However, in PCX files, it can be different, ie when the image width\r\n// is an odd value. Because of that, both values have to be used\r\n// differently: this way, bytesPerLine is only used for parsing the\r\n// RLE data and creating the surface for the image obtained, and width\r\n// is used for anything else (blitting and working with the image itself,\r\n// for example).\r\n// Unless you use the RLE methods directly (instead of the PCX functions),\r\n// you shouldn't care about it, as this wrapper hides the bytesPerLine\r\n// value under the name of realWidth, so helping the surfaces work\r\n// coherently.\r\nbool ddSpriteClass::createFromRLE(\r\n\tBYTE* rle,// pointer to the memory with the RLE information (in 8 bits)\r\n\tDWORD rleLen,// size in bytes of the memory in 'rle'\r\n\tint bytesPerLine,// real width of the encoded image\r\n\tint width, int height,// size of the encoded image\r\n\tBYTE* palette,// raw palette (as saved in PCX)\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tBYTE* palConv8;\r\n\tWORD* palConv16;\r\n\tbool allOk;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=16 && bpp!=8) return false;\r\n\r\n\t// now let's convert the palette to our video mode\r\n\tswitch (bpp){\r\n\tcase 8:\r\n\t\t// let's create an 8 bits palette\r\n\t\tpalConv8=new BYTE[256];\r\n\r\n\t\t// convert it\r\n\t\tif (!DDObject->convertPaletteTo8(palette, palConv8, 256)){\r\n\t\t\tdelete[] palConv8;\r\n\t\t\treturn false;// it failed\r\n\t\t}// if\r\n\t\tbreak;\r\n\tcase 16:\r\n\t\t// let's create a 16 bits palette\r\n\t\tpalConv16=new WORD[256];\r\n\r\n\t\t// convert it\r\n\t\tif (!DDObject->convertPaletteTo16(palette, palConv16, 256)){\r\n\t\t\tdelete[] palConv16;\r\n\t\t\treturn false;// it failed\r\n\t\t}// if\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// now go create the surface\r\n\tswitch(bpp){\r\n\tcase 8:\r\n\t\t// create the surface itself\r\n\t\tallOk=createFromRLE8(\r\n\t\t\trle, rleLen, bytesPerLine, width, height,\r\n\t\t\tpalConv8, videoMemory);\r\n\t\tbreak;\r\n\tcase 16:\r\n\t\t// create the surface itself\r\n\t\tallOk=createFromRLE16(\r\n\t\t\trle, rleLen, bytesPerLine, width, height,\r\n\t\t\tpalConv16, videoMemory);\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// destroy our converted palette\r\n\tswitch(bpp){\r\n\tcase 8:\r\n\t\tdelete[] palConv8;\r\n\t\tbreak;\r\n\tcase 16:\r\n\t\tdelete[] palConv16;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\treturn allOk;// return error code or ok*/\r\n\treturn true;\r\n}// createFromRLE\r\n\r\n// createFromPCX\r\n// Create a surface from a 8 bits PCX file content.\r\n// Currently, this method assumes that the file is valid, so no much\r\n// checks are done. Invalid files could lead the PC to halt.\r\n// Currently, PCX can only be loaded in 8 and 16 screen video modes.\r\nbool ddSpriteClass::createFromPCX(\r\n\tBYTE* pcx,// pointer to the data of a 8 bits PCX file\r\n\tDWORD pcxLen,// size of the file\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tWORD* pcxWord=(WORD*)pcx;\r\n\tBYTE* palette;\r\n\tBYTE* rleInfo;\r\n\tDWORD rleLen;\r\n\tWORD width, height, bytesPerLine;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=16 && bpp!=8) return false;\r\n\r\n\t// check if the file is big enough as to carry any data\r\n\t// 768= 256 colors * 3 bytes per color... space for the palette\r\n\t// 120= size of the header\r\n\tif (pcxLen<=768+128) return false;\r\n\r\n\t// go read the header, check it's a valid PCX file\r\n\tif (\r\n\t\t(pcx[0]!=10) || // PCX identifier\r\n\t\t(pcx[1]!=5) || // PCX version we parse\r\n\t\t(pcx[2]!=1) || // encoding, has to be 1\r\n\t\t(pcx[3]!=8) || // bpp\r\n\t\t(pcx[65]!=1)) // number of color planes\r\n\r\n\t\treturn false;// it's not a valid PCX file\r\n\r\n\t// go get some important data\r\n\t// width=xMax-xMin+1\r\n\twidth=pcxWord[4]-pcxWord[2]+1;\r\n\t// height=yMax-yMin+1\r\n\theight=pcxWord[5]-pcxWord[3]+1;\r\n\t// it's the real width a surface has to have for us to interpret\r\n\t// the RLE code...\r\n\tbytesPerLine=pcxWord[33];\r\n\t// the palette is the last thing on the entire file\r\n\tpalette=pcx+pcxLen-768;\r\n\t// rle (run length encoding) image, it's just after the header\r\n\trleInfo=pcx+128;\r\n\t// size of the rle data (the entire file, less the palette and the header\r\n\trleLen=pcxLen-128-768;\r\n\r\n\t// now create the surface, if possible, and return its error code\r\n\treturn createFromRLE(\r\n\t\trleInfo, rleLen, bytesPerLine, width, height, palette, videoMemory);*/\r\n\treturn true;\r\n}// createFromPCX\r\n\r\n// createFromGeneralImage\r\n// Create a surface from a general image file.\r\nbool ddSpriteClass::createFromGeneralImage(\r\n\tBYTE* filename,// pointer to the data of a 8 bits PCX file\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n\r\n\tif (!isDDReady || initialized) return false;// direct draw wasn't initialized\r\n\r\n\tsrfOffScreen=IMG_Load((char*)filename);\r\n\tif (!srfOffScreen) return false;\r\n\r\n\txRes=srfOffScreen->w;\r\n\tyRes=srfOffScreen->h;\r\n\trealWidth=xRes;\r\n\trealHeight=yRes;\r\n\tinVideoMemory=videoMemory;\r\n\tinitialized=true;\r\n\r\n\treturn true;\r\n}// createFromGeneralImage\r\n\r\n// Create a surface from a Pcx file.\r\n// Currently, PCX can only be loaded in 8 and 16 screen video modes.\r\nbool ddSpriteClass::loadPcxFile(\r\n\tchar* path,// path of the Pcx file\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tHANDLE hFile;\r\n\tBYTE* pcxData;\r\n\tDWORD fileSize;\r\n\tHANDLE fileMap;\r\n\tbool allOk;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=16 && bpp!=8) return false;\r\n\r\n\t// Open the file for reading\r\n\tif ((hFile=CreateFile(\r\n\t\tpath,//name of the file\r\n\t\tGENERIC_READ,//desired access\r\n\t\tFILE_SHARE_READ,//share mode\r\n\t\tNULL,//security attributes\r\n\t\tOPEN_EXISTING,//creation disposition\r\n\t\tFILE_ATTRIBUTE_NORMAL,//flags and attr\r\n\t\tNULL)//template file\r\n\t\t)==INVALID_HANDLE_VALUE)\r\n\r\n\t\treturn false;\r\n\r\n\t// get the file size\r\n\tif ((fileSize=GetFileSize(hFile,NULL))==0xFFFFFFFF){\r\n\r\n\t\t// failed\r\n\t\tCloseHandle(hFile);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// create the file mapping object\r\n\tif ((fileMap=CreateFileMapping(\r\n\t\thFile,//handle\r\n\t\tNULL,//security\r\n\t\tPAGE_READONLY,//flProtect\r\n\t\t0,0,//max size\r\n\t\tNULL))//name\r\n\t\t==NULL){\r\n\r\n\t\t// failed\r\n\t\tCloseHandle(hFile);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// obtain a pointer to the file\r\n\tif ((pcxData=(BYTE*)MapViewOfFile(\r\n\t\tfileMap,FILE_MAP_READ,0,0,0))\r\n\t\t==NULL){\r\n\r\n\t\t// failed\r\n\t\tCloseHandle(fileMap);\r\n\t\tCloseHandle(hFile);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// create the surface, if possible\r\n\tallOk=createFromPCX(pcxData, fileSize, videoMemory);\r\n\r\n\t// close the file\r\n\tUnmapViewOfFile(pcxData);\r\n\tCloseHandle(fileMap);\r\n\tCloseHandle(hFile);\r\n\r\n\t// time to go away\r\n\treturn allOk;*/\r\n\treturn true;\r\n}// loadPcxFile\r\n\r\n// Create a surface from a Pcx resource.\r\n// Currently, PCX can only be loaded in 8 and 16 screen video modes.\r\nbool ddSpriteClass::loadPcxResource(\r\n\tchar* resource,// name of the resource\r\n\tchar* resourceType,// type of the custom resource...\r\n\tbool videoMemory)// is the surface going to be in video memory?\r\n{\r\n/*\tHRSRC resInfo;// resource as obtained by FindResource\r\n\tHGLOBAL glD;// global data\r\n\tBYTE* pcxData;\r\n\tDWORD pcxSize;\r\n\tbool allOk;\r\n\r\n\tif (!isDDReady) return false;// direct draw wasn't initialized\r\n\r\n\t// check the bits per pixel\r\n\tif (bpp!=16 && bpp!=8) return false;\r\n\r\n\t// look for the resource\r\n\tif ((resInfo=FindResource(\r\n\t\tNULL,// module,\r\n\t\tresource,// resource name\r\n\t\tresourceType// resource type\r\n\t\t))==NULL)\r\n\t\treturn false;// error: there is no resource named that way\r\n\r\n\t// get its size\r\n\tif ((pcxSize=SizeofResource(\r\n\t\tNULL,// module\r\n\t\tresInfo// resource info object\r\n\t\t))==0)\r\n\t\treturn false;// error\r\n\r\n\t// load it...\r\n\tif ((glD=LoadResource(\r\n\t\tNULL,// module\r\n\t\tresInfo// data returned by FindResource\r\n\t\t))==NULL)\r\n\t\treturn false;// error...\r\n\r\n\t// let's obtain a pointer to the resource\r\n\tif ((pcxData=(BYTE*)LockResource(glD))==NULL){\r\n\t\t// let's go out\r\n\t\tFreeResource(glD);\r\n\t\treturn false;// error!\r\n\t}// if\r\n\r\n\t// create the surface\r\n\tallOk=createFromPCX(pcxData, pcxSize, videoMemory);\r\n\r\n\t// now it's time to free the locked resource (it will also unlock it)\r\n\tUnlockResource(glD);\r\n\tFreeResource(glD);\r\n\r\n\t// exit, returning the error code found in createFromPCX\r\n\treturn allOk;*/\r\n\treturn true;\r\n}// loadPcxResource\r\n\r\n// the following three can fail if the surface\r\n// is lost\r\nbool ddSpriteClass::setBlackTransparentColor()\r\n{\r\n\tDWORD color;\r\n\r\n\tif (!getDwordFromRGB(0, 0, 0, color)) return false;\r\n\treturn setTransparentColorFromDword(color);\r\n}\r\n\r\nbool ddSpriteClass::setWhiteTransparentColor()\r\n{\r\n\tDWORD color;\r\n\r\n\tif (!getDwordFromRGB(255, 255, 255, color)) return false;\r\n\treturn setTransparentColorFromDword(color);\r\n}\r\n\r\n// This method sets the transparent color of the surface, from the\r\n// color that results from the combination of red, green and blue\r\n// values.\r\nbool ddSpriteClass::setTransparentColorFromRGB(BYTE r, BYTE g, BYTE b)\r\n{\r\n\tDWORD color;\r\n\r\n\tif (!getDwordFromRGB(r, g, b, color)) return false;\r\n\treturn setTransparentColorFromDword(color);\r\n}// setTransparentColorFromRGB\r\n\r\n// This method sets the transparent color of the surface, from the\r\n// color in a given pixel.\r\nbool ddSpriteClass::setTransparentColorFromPixel(int x, int y)\r\n{\r\n\tDWORD color;\r\n\r\n\tif (!getDwordFromPixel(x, y, color)) return false;\r\n\treturn setTransparentColorFromDword(color);\r\n}// setTransparentColorFromDword\r\n\r\n// This method sets the transparent color of the surface, from a\r\n// DWORD (useful for blittings).\r\nbool ddSpriteClass::setTransparentColorFromDword(DWORD color)\r\n{\r\n/*\tDDCOLORKEY colorKey={sizeof(colorKey)};// and zero it!\r\n\r\n\tcolorKey.dwColorSpaceHighValue=color;\r\n\tcolorKey.dwColorSpaceLowValue=color;\r\n\r\n\tif (FAILED(srfOffScreen->SetColorKey(\r\n\t\tDDCKEY_SRCBLT,// kind of color key\r\n\t\t&colorKey// color structure\r\n\t\t)))\r\n\t\treturn false;\r\n\r\n\t// set the transparency info\r\n\ttransparentDword=color;// remember the value of our transparent color\r\n\ttransparent=true;// change flag\r\n*/\r\n\treturn true;\r\n}\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#ifndef FILE_DDWRAP_INCLUDED\r\n#define FILE_DDWRAP_INCLUDED\r\n\r\n#define FILE_DDWRAP_VERSION \"4-8-2003-H\"// last modification: dd/mm/yy\r\n\r\n#include \"win-constants.h\"\r\n\r\n// If you want your code to be fully compatible with DX 5, keep this line\r\n// uncommented... Otherwise, you'll need to comment it, and the generated\r\n// code will only work for DirectX 7 and above.\r\n// For code compatible with DX 6, keep this line uncommented.\r\n// You can also try changing this number to make it be other values.\r\n#define DIRECTDRAW_VERSION 0x0500 // comment it if necessary\r\n#ifndef DIRECTDRAW_VERSION\r\n\t#define DIRECTDRAW_VERSION 0x0700\r\n#endif // DIRECTDRAW_VERSION\r\n\r\n// FILES TO ADD TO THE PROJECT FILE:\r\n// This wrapper needs ddraw.lib and dxguid.lib\r\n// from the \"lib\" directory of your compiler,\r\n// to be added to the project it's being used in,\r\n// otherwise it won't compile.\r\n\r\n#include <SDL.h>\r\n#include \"types.h\"\r\n\r\n// This macro converts a color given in RGB format (with 8 bits per\r\n// component), to the color format of the surface, in a dword.\r\n// Only for NON-palettized video modes.\r\n// ddObj is a directDrawClass object.\r\n// Remember that r8LessSize = 8-rSize.\r\n#define getDwordFromRGBFast(ddObj, rrr, ggg, bbb) \\\r\n\t(((rrr)>>((ddObj).r8LessSize))<<(ddObj).rOff)| \\\r\n\t(((ggg)>>((ddObj).g8LessSize))<<(ddObj).gOff)| \\\r\n\t(((bbb)>>((ddObj).b8LessSize))<<(ddObj).bOff)\r\n\r\n// The following macros return each color component (in 8 bits) from a\r\n// Dword containing a color value, according to the surface color format.\r\n// Only for NON-palettized video modes.\r\n// ddObj is a directDrawClass object.\r\n// Remember that r8LessSize = 8-rSize.\r\n#define getRedFromDword(ddObj, color) \\\r\n\t((((color) & (ddObj).rMask)>>(ddObj).rOff)<<(ddObj).r8LessSize)\r\n#define getGreenFromDword(ddObj, color) \\\r\n\t((((color) & (ddObj).gMask)>>(ddObj).gOff)<<(ddObj).g8LessSize)\r\n#define getBlueFromDword(ddObj, color) \\\r\n\t((((color) & (ddObj).bMask)>>(ddObj).bOff)<<(ddObj).b8LessSize)\r\n\r\nenum alignEnum {FILE_DDWRAP_ALIGN_LEFT,\r\n\tFILE_DDWRAP_ALIGN_CENTER, FILE_DDWRAP_ALIGN_RIGHT};\r\nenum valignEnum {FILE_DDWRAP_VALIGN_TOP,\r\n\tFILE_DDWRAP_VALIGN_CENTER, FILE_DDWRAP_VALIGN_BOTTOM};\r\n\r\nclass ddSurfaceClass;\r\nclass directDrawClass;\r\nclass ddSpriteClass;\r\n\r\nclass ddSurfaceClass{\r\nprivate:\r\nprotected:\r\n\tint xRes, yRes;// size of the surface (useful part)\r\n\tint realWidth, realHeight;// real size of the surface (not of much use, for internal purposes mostly)\r\n\tstatic int bpp;\r\n\tbool inVideoMemory;// is in the video memory or in the system one?\r\n\r\n\t// transparent info will only be used in ddSpriteClass\r\n\t// bool transparent can only be true in ddSpriteClass and other\r\n\t// classes which could implement interfaces for this transparency\r\n\t// info.\r\n\tbool transparent;// is a transparent sprite\r\n\tDWORD transparentDword;// transparent color in dword format\r\n\r\n\t// pointer to our Direct Draw object\r\n\tstatic directDrawClass* DDObject;\r\n\r\n\t// info for locked surfaces\r\n\tbool locked;// is it locked?\r\n\r\n\tSDL_Surface* srfOffScreen;// main surface\r\n/*\r\n#if DIRECTDRAW_VERSION < 0x0700\r\n\tLPDIRECTDRAWSURFACE srfOffScreen;// surface for blitting\r\n#else // DIRECTDRAW_VERSION\r\n\tLPDIRECTDRAWSURFACE7 srfOffScreen;// surface for blitting\r\n#endif // DIRECTDRAW_VERSION\r\n*/\r\n\t// two static variables that help to locate the direct draw\r\n\t// object\r\n\tstatic SDL_Surface* screenSurface;// direct draw object\r\n\tstatic bool isDDReady;\r\n/*\r\n\t// two very useful methods, for the two versions of this class\r\n#if DIRECTDRAW_VERSION < 0x0700\r\n\tvirtual bool isLostSrf(bool* errorCode, LPDIRECTDRAWSURFACE& srf);\r\n\tvirtual bool restoreSrf(LPDIRECTDRAWSURFACE& srf);\r\n#else // DIRECTDRAW_VERSION\r\n\tvirtual bool isLostSrf(bool* errorCode, LPDIRECTDRAWSURFACE7& srf);\r\n\tvirtual bool restoreSrf(LPDIRECTDRAWSURFACE7& srf);\r\n#endif // DIRECTDRAW_VERSION*/\r\npublic:\r\n\tddSurfaceClass():locked(false), transparent(false){}\r\n\tddSurfaceClass(ddSurfaceClass&):locked(false), transparent(false){}\r\n\tvirtual ~ddSurfaceClass(){}\r\n\r\n\t// blitting methods, clipping in the destination surface (or not)\r\n\tvirtual bool bltFrom(ddSurfaceClass& srf, int xD, int yD,\r\n\t\tbool clip=true, bool transparent=false);\r\n\tvirtual bool bltFrom(ddSurfaceClass& srf, int xD, int yD, \r\n\t\tint xS, int yS, int wS, int hS,\r\n\t\tbool clip=true, bool transparent=false);\r\n\tvirtual bool bltFrom(ddSurfaceClass& srf, int xD, int yD, \r\n\t\tint xS, int yS, int wS, int hS,\r\n\t\tint xClip, int yClip, int wClip, int hClip,\r\n\t\tbool clip=true, bool transparent=false);\r\n\tvirtual bool stretchBltFrom(ddSurfaceClass& srf, int xD, int yD,\r\n\t\tint wD, int hD, int xS, int yS,\tint wS, int hS,\r\n\t\tbool mirrorX=false, bool mirrorY=false, bool transparent=false);\r\n\tvirtual bool obscuredBltFrom(ddSurfaceClass& srf, int xD, int yD,\r\n\t\tint lightness, bool transparent=false);\r\n\tvirtual bool alphaBltFrom(ddSurfaceClass& srf, int xD, int yD,\r\n\t\tint alphaValue, bool transparent=false);\r\n\t// other graphical methods\r\n\tvirtual bool writeText(char* text, int r, int g, int b, alignEnum align, int x, int y, int width=0, int height=0);\r\n\tvirtual bool calculateText(char* text, alignEnum align, int& width, int& height);\r\n\tvirtual bool fillRect(int r, int g, int b, int x, int y, int width=0, int height=0);\r\n\tvirtual bool fillAllDword(DWORD color);\r\n/*\tvirtual bool getDC(HDC* hdc);\r\n\tvirtual bool releaseDC(HDC hdc);*/\r\n\tvirtual bool getDwordFromPixel(int x, int y, DWORD& color);\r\n\tvirtual bool getDwordFromRGB(int r, int g, int b, DWORD& color);\r\n\tvirtual bool putPixel(int x, int y, int r, int g, int b);\r\n\tvirtual bool drawLine(int x, int y, int x2, int y2, int r, int g, int b);\r\n\r\n\t// for saving the surface to disk\r\n\tvirtual bool saveAsBmpFile(char* filename, bool overwrite=false);\r\n\r\n\t// Warning!\r\n\t// Don't play with locks under you really know what you are doing!\r\n\tvirtual bool lock(bool onlyRead, bool onlyWrite, DWORD* pitch, LPVOID* pointer);\r\n\tvirtual bool unlock();\r\n\r\n\tvirtual bool isInVideoMemory(){return inVideoMemory;}\r\n\tvirtual int getWidth(){return xRes;}\r\n\tvirtual int getHeight(){return yRes;}\r\n\tvirtual int getRealWidth(){return realWidth;}// don't use it unless you are real sure you need it\r\n\tvirtual int getRealHeight(){return realHeight;}// don't use it unless you are real sure you need it\r\n\tvirtual bool isLost(bool* errorCode=NULL);\r\n\tvirtual bool restore();\r\n\tvirtual bool isReady()=0;\r\n\r\n\t// a small function for obtaining the main DD object from any\r\n\t// surface attached to it.\r\n\tvirtual directDrawClass* getDDObject(){return DDObject;}\r\n};\r\n\r\nclass directDrawClass:public ddSurfaceClass{\r\nprivate:\r\n/*\t// dd data\r\n#if DIRECTDRAW_VERSION < 0x0700\r\n\tLPDIRECTDRAWSURFACE srfOnScreen;// main surface\r\n#else// DIRECTDRAW_VERSION\r\n\tLPDIRECTDRAWSURFACE7 srfOnScreen;// main surface\r\n#endif// DIRECTDRAW_VERSION\r\n*/\r\n\tbool initialized;// was init executed ever?\r\n\tbool videoModeReady;// was the video mode initialized ever?\r\n\tbool palettized;// has this video mode a palette?\r\n\tint backbuffers;// how many back buffers does this video mode have?\r\n\r\npublic:\r\n\tbool init();\r\n\tbool end();\r\n\r\n\tbool setVideoMode(int x, int y, int bpp, int backbuffers=1);\r\n\tbool updateColorInfo();\r\n\tbool closeVideoMode();\r\n\r\n\tbool flip();\r\n\r\n\t// derived from ddSurfaceClass\r\n\tvirtual bool isReady();\r\n\tvirtual bool isLost(bool* errorCode=NULL);\r\n\tvirtual bool restore();\r\n\r\n\tbool isVideoModeReady(){return videoModeReady;}\r\n\tbool isPalettized(){return palettized;}\r\n\tint getBackBuffersCount(){return backbuffers;}\r\n\r\n\t// for conversions of palette\r\n\tbool convertPaletteTo8(const BYTE* palette, BYTE* pal8, int entries);\r\n\tbool convertPaletteTo16(const BYTE* palette, WORD* pal16, int entries);\r\n\r\n\t// constructors / destructors\r\n\tdirectDrawClass():initialized(false), videoModeReady(false)\r\n\t{\r\n\t\tinVideoMemory=true;\r\n\t}\r\n\t~directDrawClass(){end();}\r\n\r\n\t// Important data for color handling\r\n\t// We assume it doesn't vary from a surface to other one, so\r\n\t// we put it here to be updated every time a video mode is set.\r\n\t// Color masks:\r\n\tDWORD rMask,gMask,bMask;\r\n\t// Offset for every color\r\n\tDWORD rOff,gOff,bOff;\r\n\t// Bits in every color\r\n\tDWORD rSize,gSize,bSize;\r\n\tDWORD r8LessSize, g8LessSize, b8LessSize;// used for faster calculations\r\n\r\n/*\t// Important data about the driver and HAL (hardware abstraction\r\n\t// layer) and the emulation capabilities of DirectX, in the HEL\r\n\t// (hardware emulation layer).\r\n\t// The emulation capabilities are only from DX, no HHM additions are\r\n\t// taken into account. And the helCaps don't change from machine to\r\n\t// machine, so they are hardly useful.\r\n\t// These caps are only updated in the initialization.\r\n\tDDCAPS halCaps;// hardware capabilities, read only data\r\n\tDDCAPS helCaps;// emulation capabilities, read only data\r\n\r\n\t// Some useful interfaces for retrieving info about the hardware\r\n\t// capabilities. When you can, use these instead of the caps\r\n\t// structures presented above.\r\n\t// You can use this information to decide whether a surface will go\r\n\t// in video or system memory, considering that hardware operations\r\n\t// generally work faster in video memory, and emulated operations\r\n\t// work faster in system memory.\r\n\tbool doesHardwareBlt(){// is blitting executed by the hardware?\r\n\t\treturn (halCaps.dwCaps & DDCAPS_BLT)==DDCAPS_BLT;\r\n\t}// doesHardwareBlt\r\n\tbool doesHardwareTransparentBlt(){// is blitting with transparency executed by the hardware?\r\n\t\treturn (halCaps.dwCKeyCaps & DDCKEYCAPS_SRCBLT)==DDCKEYCAPS_SRCBLT;\r\n\t}// doesHardwareTransparentBlt\r\n\tbool doesHardwareStretchX(){// is x stretching executed by the hardware?\r\n\t\treturn (halCaps.dwFXCaps & DDFXCAPS_BLTSTRETCHX)==DDFXCAPS_BLTSTRETCHX;\r\n\t}// doesHardwareStretchX\r\n\tbool doesHardwareStretchY(){// is y stretching executed by the hardware?\r\n\t\treturn (halCaps.dwFXCaps & DDFXCAPS_BLTSTRETCHY)==DDFXCAPS_BLTSTRETCHY;\r\n\t}// doesHardwareStretchY\r\n\tbool doesHardwareMirrorX(){// is x mirroring executed by the hardware?\r\n\t\treturn (halCaps.dwFXCaps & DDFXCAPS_BLTMIRRORLEFTRIGHT)==DDFXCAPS_BLTMIRRORLEFTRIGHT;\r\n\t}// doesHardwareMirrorX\r\n\tbool doesHardwareMirrorY(){// is y mirroring executed by the hardware?\r\n\t\treturn (halCaps.dwFXCaps & DDFXCAPS_BLTMIRRORUPDOWN)==DDFXCAPS_BLTMIRRORUPDOWN;\r\n\t}// doesHardwareMirrorY*/\r\n};// directDrawClass\r\n\r\nclass ddSpriteClass:public ddSurfaceClass{\r\nprivate:\r\n\tbool initialized;// does the surface exist?\r\n\r\n/*\tbool genericLoadBmp(char* name, bool isResource, HINSTANCE hInstance, bool videoMemory);*/\r\npublic:\r\n\t// constructors / destructors\r\n\tddSpriteClass():initialized(false){}\r\n\t~ddSpriteClass(){free();}\r\n\r\n\tbool create(int x, int y, bool videoMemory=true);\r\n\tbool free();\r\n\tbool loadBmpFile(char* path, bool videoMemory=true);\r\n/*\tbool loadBmpResource(char* resource, HINSTANCE hInstance, bool videoMemory=true);*/\r\n\r\n\t// methods for PCX\r\n\tbool createFromRLE8(BYTE* rle, DWORD rleLen, int bytesPerLine, int width, int height, BYTE* palette, bool videoMemory=true);\r\n\tbool createFromRLE16(BYTE* rle, DWORD rleLen, int bytesPerLine, int width, int height, WORD* palette, bool videoMemory=true);\r\n\tbool createFromRLE(BYTE* rle, DWORD rleLen, int bytesPerLine, int width, int height, BYTE* palette, bool videoMemory=true);\r\n\tbool createFromPCX(BYTE* pcx, DWORD pcxLen, bool videoMemory=true);\r\n\tbool loadPcxFile(char* path, bool videoMemory=true);\r\n\tbool loadPcxResource(char* resource, char* resourceType, bool videoMemory=true);\r\n\tbool createFromGeneralImage(BYTE* filename, bool videoMemory);\r\n\r\n\tbool isTransparent(){return transparent;}\r\n\tbool setBlackTransparentColor();\r\n\tbool setWhiteTransparentColor();\r\n\tbool setTransparentColorFromDword(DWORD color);\r\n\tbool setTransparentColorFromPixel(int x, int y);\r\n\tbool setTransparentColorFromRGB(BYTE r, BYTE g, BYTE b);\r\n\r\n\t// derived from ddSurfaceClass\r\n\tvirtual bool isReady(){return initialized;}\r\n};\r\n\r\n#endif // FILE_DDWRAP_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#include \"diwrap.h\"\r\n#include <string.h>\r\n\r\n// Every function here returns false in error...\r\n\r\n// DIRECT INPUT BASE CLASS\r\n// directInputBaseClass methods and stuff\r\nint directInputBaseClass::initCount=0;\r\n/*#if DIRECTINPUT_VERSION < 0x0700\r\n\tLPDIRECTINPUT directInputBaseClass::lpDI=NULL;\r\n#else// DIRECTINPUT_VERSION\r\n\tLPDIRECTINPUT7 directInputBaseClass::lpDI=NULL;\r\n#endif// DIRECTINPUT_VERSION\r\n*/\r\n// init\r\n// initializes DirectInput if needed, keeping a \"reference count\"\r\n// to see whether it's needed or not.\r\n// Params:\r\n// hInstance: instance of the application\r\nbool directInputBaseClass::init()\r\n{\r\n\tif (initCount==0){\r\n\t\t// real init\r\n\t}\r\n/*\tif (initCount==0){\r\n#if DIRECTINPUT_VERSION < 0x0700\r\n\t\tif (FAILED(DirectInputCreate(\r\n\t\t\thInstance, // hInstance\r\n\t\t\tDIRECTINPUT_VERSION, // version\r\n\t\t\t&lpDI,// new dinput object pointer\r\n\t\t\tNULL// don't care\r\n\t\t\t)))\r\n\t\t\treturn false;\r\n#else// DIRECTINPUT_VERSION\r\n\t\tif (FAILED(DirectInputCreateEx(\r\n\t\t\thInstance, // hInstance\r\n\t\t\tDIRECTINPUT_VERSION, // version\r\n\t\t\tIID_IDirectInput7,// interface to create\r\n\t\t\t(VOID **) &lpDI,// new dinput object pointer\r\n\t\t\tNULL// don't care\r\n\t\t\t)))\r\n\t\t\treturn false;\r\n#endif// DIRECTINPUT_VERSION\r\n\r\n\t}\r\n*/\r\n\tinitCount++;\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// end\r\n// Release the DirectInput object if it's needed.\r\nbool directInputBaseClass::end()\r\n{\r\n\tif (initCount==1){\r\n\t\t// time to free it\r\n//\t\tlpDI->Release();\r\n//\t\tlpDI=NULL;\r\n\t\t// real deinit\r\n\t}\r\n\r\n\tinitCount--;\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// DI KEYBOARD CLASS\r\n// diKeyboardClass methods and stuff\r\n\r\n// init\r\n// Initializes DirectInput for the keyboard if needed.\r\n// Params:\r\n// hInstance: instance of the application\r\nbool diKeyboardClass::init()\r\n{\r\n\tif (initializedDI) return false;\r\n\r\n\tinitializedDI=directInputBaseClass::init();\r\n\r\n\treturn initializedDI;\r\n}\r\n\r\n// end\r\n// Closes anything that remains open in the object, and then\r\n// closes DirectInput if needed.\r\nbool diKeyboardClass::end()\r\n{\r\n\tif (!initializedDI) return false;\r\n\r\n\tif (initializedKB){\r\n\t\tif (!closeKeyboard()) return false;\r\n\t}\r\n\r\n\tinitializedDI=!directInputBaseClass::end();\r\n\r\n\treturn !initializedDI;\r\n}\r\n\r\nFILE_DIWRAP_KEYS_TYPE *diKeyboardClass::createKeysArray(int numkeys)\r\n{\r\n\tFILE_DIWRAP_KEYS_TYPE *tmpk;\r\n\r\n\ttmpk=new FILE_DIWRAP_KEYS_TYPE[numkeys];\r\n\tmemset(tmpk, 0, sizeof(FILE_DIWRAP_KEYS_TYPE)*numkeys);// zero all the array\r\n\r\n\treturn tmpk;\r\n}\r\n\r\n\r\n// setUpKeyboard\r\n// Prepares the object to manage the keyboard.\r\n// Params:\r\n// hwnd: handle of the window that will manage it.\r\nbool diKeyboardClass::setUpKeyboard()\r\n{\r\n\tif (initializedKB) return false;\r\n/*\r\n\t// create the device\r\n\tif (FAILED(lpDI->CreateDevice(\r\n\t\tGUID_SysKeyboard,// ref guid\r\n\t\t&lpDev,// pointer to the new device\r\n\t\tNULL// don't care\r\n\t\t)))\r\n\t\treturn false;\r\n\r\n\t// set the keyboard data format\r\n\tif (FAILED(lpDev->SetDataFormat(\r\n\t\t&c_dfDIKeyboard// predefined data format\r\n\t\t))){\r\n\r\n\t\tlpDev->Release();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// set the cooperative level\r\n\tif (FAILED(lpDev->SetCooperativeLevel(\r\n\t\thwnd,// window handle\r\n\t\tDISCL_NONEXCLUSIVE | DISCL_FOREGROUND// flags\r\n\t\t))){\r\n\r\n\t\tlpDev->Release();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// acquire the device... don't care if result is error\r\n\tacquire();\r\n*/\r\n\tconst int baseNumKeysUsed=256;\r\n\tmaxNumKeysUsed=baseNumKeysUsed;\r\n\r\n\t// set up our arrays of keys\r\n\tkeys=createKeysArray(maxNumKeysUsed);\r\n\tlatestKeys=createKeysArray(maxNumKeysUsed);\r\n\r\n\tif (!getKeys(NULL)) return false;\r\n\tinitializedKB=true;// change flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// closeKeyboard\r\n// Closes the keyboard object.\r\nbool diKeyboardClass::closeKeyboard()\r\n{\r\n\tif (!initializedKB) return false;\r\n\r\n\t// bye bye all\r\n\tdelete[] keys;\r\n\tdelete[] latestKeys;\r\n/*\tunacquire();\r\n\tlpDev->Release();\r\n*/\r\n\tinitializedKB=false;// clear flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// acquire\r\n// Prepares the keyboard to get the keys.\r\n// Initialization does it automatically, redo if the input is lost.\r\n// Note:\r\n// Acquires aren't reference counted, and failed acquires are just\r\n// a temporal problem\r\nbool diKeyboardClass::acquire()\r\n{\r\n/*\treturn SUCCEEDED(lpDev->Acquire());*/\r\n\treturn true;//2010\r\n}\r\n\r\n// unacquire\r\n// Release the keyboard until the next acquire.\r\nbool diKeyboardClass::unacquire()\r\n{\r\n/*\tlpDev->Unacquire();*/\r\n\treturn true;// always ok\r\n}\r\n\r\n// getKeys\r\n// Take the current state of the keyboard. After it, keyboard stuff\r\n// can be known through the KEYDOWN macro.\r\n// If this method returns false, and isLost isn't NULL, the variable\r\n// pointed by isLost will be true if the error was caused by an\r\n// unaquired device (which needs the acquire method to be called), or\r\n// false if the error is anything else.\r\nbool diKeyboardClass::getKeys(bool* isLost)\r\n{\r\n\tFILE_DIWRAP_KEYS_TYPE* tmpKeys;\r\n\tint numkeys;\r\n\r\n/*\tHRESULT res;\r\n\r\n\tif (!isReady()) return false;\r\n\r\n\t// update the latest state information\r\n\tmemcpy(latestKeys, keys, FILE_DIWRAP_KEYS_SIZE);\r\n\r\n\t// get the current state of the device\r\n\tres=lpDev->GetDeviceState(\r\n\t\tFILE_DIWRAP_KEYS_SIZE,// size of the buffer (256)\r\n\t\t(LPVOID *)keys// address of the buffer\r\n\t\t);\r\n\r\n\t// check for lost input\r\n\tif (res==DIERR_INPUTLOST){\r\n\t\t// input lost\r\n\t\tif (isLost!=NULL) *isLost=true;\r\n\t}else{\r\n\t\t// input not lost\r\n\t\tif (isLost!=NULL) *isLost=false;\r\n\t}// if\r\n\r\n\t// check for errors\r\n\tif (FAILED(res))\r\n\t\treturn false;\r\n*/\r\n\t#ifdef EMSCRIPTEN\r\n\t\ttmpKeys=SDL_GetKeyboardState(&numkeys);\r\n\t#else\r\n\t\ttmpKeys=SDL_GetKeyState(&numkeys);\r\n\t#endif\r\n\t\r\n\t// if we need bigger buffers, recreate them\r\n\tif (numkeys>maxNumKeysUsed){\r\n\t\tmaxNumKeysUsed=numkeys;\r\n\r\n\t\t// todo 2010, this erases previous key data!!\r\n\t\tdelete[] keys;\r\n\t\tdelete[] latestKeys;\r\n\r\n\t\tkeys=createKeysArray(maxNumKeysUsed);\r\n\t\tlatestKeys=createKeysArray(maxNumKeysUsed);\r\n\t}\r\n\r\n\tmemcpy(latestKeys, keys, sizeof(FILE_DIWRAP_KEYS_TYPE)*maxNumKeysUsed);// latestKeys=keys\r\n\tmemcpy(keys, tmpKeys, sizeof(FILE_DIWRAP_KEYS_TYPE)*maxNumKeysUsed);// keys=tmpKeys\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// DI MOUSE CLASS\r\n// diMouseClass methods and stuff\r\n\r\n// init\r\n// Initializes DirectInput for the mouse if needed.\r\n// Params:\r\n// hInstance: instance of the application\r\nbool diMouseClass::init()\r\n{\r\n\tif (initializedDI) return false;\r\n\r\n\tinitializedDI=directInputBaseClass::init();\r\n\r\n\treturn initializedDI;\r\n}\r\n\r\n// end\r\n// Closes anything that remains open in the object, and then\r\n// closes DirectInput if needed.\r\nbool diMouseClass::end()\r\n{\r\n\tif (!initializedDI) return false;\r\n\r\n\tif (initializedM){\r\n\t\tif (!closeMouse()) return false;\r\n\t}\r\n\r\n\tinitializedDI=!directInputBaseClass::end();\r\n\r\n\treturn !initializedDI;\r\n}\r\n\r\n// setUpMouse\r\n// Prepares the object to manage the mouse.\r\n// Params:\r\n// hwnd: handle of the window that will manage it.\r\nbool diMouseClass::setUpMouse()\r\n{\r\n\tmouseData.mouse_abs_x=0;\r\n\tmouseData.mouse_abs_y=0;\r\n\tmouseData.mouse_x=0;\r\n\tmouseData.mouse_y=0;\r\n\tmouseData.mouse_state=0;\r\n\r\n/*\tif (initializedM) return false;\r\n\r\n\t// create the device\r\n\tif (FAILED(lpDI->CreateDevice(\r\n\t\tGUID_SysMouse,// ref guid\r\n\t\t&lpDev,// pointer to the new device\r\n\t\tNULL// don't care\r\n\t\t)))\r\n\t\treturn false;\r\n\r\n\t// set the mouse data format\r\n\tif (FAILED(lpDev->SetDataFormat(\r\n\t\t&c_dfDIMouse// predefined data format\r\n\t\t))){\r\n\r\n\t\tlpDev->Release();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// set the cooperative level\r\n\tif (FAILED(lpDev->SetCooperativeLevel(\r\n\t\thwnd,// window handle\r\n\t\tDISCL_EXCLUSIVE | DISCL_FOREGROUND// flags\r\n\t\t))){\r\n\r\n\t\tlpDev->Release();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// zero the buffers, the information in these isn't reliable at all\r\n\tmemset(&mouseData, 0, sizeof(mouseData));\r\n\tmemset(&latestMouseData, 0, sizeof(latestMouseData));\r\n\r\n\t// acquire the device... don't care if result is error\r\n\tacquire();\r\n*/\r\n\tinitializedM=true;// change flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// closeMouse\r\n// Closes the mouse object.\r\nbool diMouseClass::closeMouse()\r\n{\r\n\tif (!initializedM) return false;\r\n/*\r\n\t// bye bye all\r\n\tunacquire();\r\n\tlpDev->Release();\r\n*/\r\n\tinitializedM=false;// clear flag\r\n\r\n\treturn true;// all ok\r\n}\r\n\r\n// acquire\r\n// Prepares the mouse to get the keys.\r\n// Initialization does it automatically, redo if the input is lost.\r\n// Note:\r\n// Acquires aren't reference counted, and failed acquires are just\r\n// a temporal problem\r\nbool diMouseClass::acquire()\r\n{\r\n/*\treturn SUCCEEDED(lpDev->Acquire());*/\r\n\treturn true;\r\n}\r\n\r\n// unacquire\r\n// Release the mouse until the next acquire.\r\nbool diMouseClass::unacquire()\r\n{\r\n/*\tlpDev->Unacquire();*/\r\n\treturn true;// always ok\r\n}\r\n\r\n// getState\r\n// Take the current state of the mouse. After it, mouse stuff\r\n// can be known through the MOUSE* macros.\r\n// If this method returns false, and isLost isn't NULL, the variable\r\n// pointed by isLost will be true if the error was caused by an\r\n// unaquired device (which needs the acquire method to be called), or\r\n// false if the error is anything else.\r\nbool diMouseClass::getState(bool* isLost)\r\n{\r\n/*\tHRESULT res;*/\r\n\tmouseDataStruct latestMouseDataCopy;\r\n\r\n\tif (!isReady()) return false;\r\n\tif (isLost!=NULL) *isLost=false;//2010\r\n/*\r\n\t// update the latest state information\r\n\tmemcpy(&latestMouseData, &mouseData, sizeof(mouseData));\r\n\r\n\t// get the state of this device\r\n\tres=lpDev->GetDeviceState(\r\n\t\tsizeof(mouseData),// size of the buffer\r\n\t\t(LPVOID *)&mouseData// address of the buffer\r\n\t\t);\r\n\r\n\t// check for lost input\r\n\tif (res==DIERR_INPUTLOST){\r\n\t\t// input lost\r\n\t\tif (isLost!=NULL) *isLost=true;\r\n\t}else{\r\n\t\t// input not lost\r\n\t\tif (isLost!=NULL) *isLost=false;\r\n\t}// if\r\n\r\n\t// check for errors\r\n\tif (FAILED(res))\r\n\t\treturn false;\r\n*/\r\n\tlatestMouseDataCopy=latestMouseData;\r\n\r\n\tlatestMouseData=mouseData;\r\n\tmouseData.mouse_state=SDL_GetMouseState(&(mouseData.mouse_abs_x), &(mouseData.mouse_abs_y));\r\n\tmouseData.mouse_x=mouseData.mouse_abs_x-latestMouseDataCopy.mouse_abs_x;\r\n\tmouseData.mouse_y=mouseData.mouse_abs_y-latestMouseDataCopy.mouse_abs_y;\r\n\r\n\treturn true;// all ok\r\n}\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n/*#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions*/\r\n#include \"sheepai.h\"// for managing the AI of a specific type of enemies, the sheeps\r\n#include \"humanheadai.h\"// for managing the AI of a specific type of enemies, the human heads\r\n#include \"carriersai.h\"// for managing the AI of a specific type of enemies, the carriers\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n#include \"players.h\"// for managing the players\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// This function makes an enemy unit start falling\r\nbool unitStartFalling(enemyUnitStruct& enemyData){\r\n\t// frame number, of the frame to be used when the unit is staying\r\n\t// at the ground\r\n\tint atGroundFrameNum;\r\n\t// frame number to be used when falling\r\n\tint nextFrameNum;\r\n\t// speed for falling (in this unit)\r\n\tdouble fallingSpeed;\r\n\t// other temp values\r\n\tint minX, maxX;\r\n\tint limitX;\r\n\r\n\tswitch(enemyData.unitType){\r\n\tcase FILE_GAMEDATA_ENEMY_WHITESHEEP:\r\n\t\t// set some useful extra fields\r\n\t\tenemyData.aiSpecific.sheepData.nowFalling=true;// it's falling!\r\n\t\tfallingSpeed=enemyData.aiSpecific.sheepData.sheepSpeedWhenFalling;// linear speed the unit has when it falls\r\n\r\n\t\tatGroundFrameNum=\r\n\t\t\tgetFrameIndexAndListByName(\"whiteSheepWalking\");\r\n\t\tnextFrameNum=\r\n\t\t\tgetFrameIndexAndListByName(\"whiteSheepDropped\");\r\n\r\n\t\t// for checking the destine address\r\n\t\tminX=gameWorld.minXFallenWSheeps;\r\n\t\tmaxX=gameWorld.maxXFallenWSheeps;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_BLACKSHEEP:\r\n\t\t// set some useful extra fields\r\n\t\tenemyData.aiSpecific.sheepData.nowFalling=true;// it's falling!\r\n\t\tfallingSpeed=enemyData.aiSpecific.sheepData.sheepSpeedWhenFalling;// linear speed the unit has when it falls\r\n\r\n\t\tatGroundFrameNum=\r\n\t\t\tgetFrameIndexAndListByName(\"blackSheepWalking\");\r\n\t\tnextFrameNum=\r\n\t\t\tgetFrameIndexAndListByName(\"blackSheepDropped\");\r\n\r\n\t\t// for checking the destine address\r\n\t\tminX=gameWorld.minXFallenWSheeps;\r\n\t\tmaxX=gameWorld.maxXFallenWSheeps;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_HUMANHEAD:\r\n\t\t// set some useful extra fields\r\n\t\tenemyData.aiSpecific.headData.fallingHead=true;// it's falling!\r\n\t\tatGroundFrameNum=\r\n\t\t\tgetFrameIndexAndListByName(\"humanHeadFalling\");// common frame\r\n\t\tnextFrameNum=atGroundFrameNum;\r\n\t\tfallingSpeed=enemyData.aiSpecific.headData.headSpeedWhenFalling;// linear speed the unit has when it falls\r\n\r\n\t\t// for checking the destine address\r\n\t\tminX=gameWorld.minXFallenHeads;\r\n\t\tmaxX=gameWorld.maxXFallenHeads;\r\n\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// no other kind of unit is allowed to fall this way\r\n\t\treturn false;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// set the destine address X\r\n\tenemyData.goingToPointX=enemyData.x-30;\r\n\r\n\t// check the destine address X\r\n\tlimitX=minX+\r\n\t\tgetUnitFramesList(&enemyData)[atGroundFrameNum].handlerY;\r\n\tif (enemyData.goingToPointX<limitX)\r\n\t\tenemyData.goingToPointX=limitX+(rand()%70);\r\n\tlimitX=maxX-\r\n\t\tgetUnitFramesList(&enemyData)[atGroundFrameNum].cW+\r\n\t\tgetUnitFramesList(&enemyData)[atGroundFrameNum].handlerX;\r\n\tif (enemyData.goingToPointX>limitX)\r\n\t\tenemyData.goingToPointX=limitX-(rand()%70);\r\n\r\n\t// set the destine address Y\r\n\tenemyData.goingToPointY=\r\n\t\tgetGroundWall(int(enemyData.goingToPointX))-\r\n\t\tgetUnitFramesList(&enemyData)[atGroundFrameNum].cH+\r\n\t\tgetUnitFramesList(&enemyData)[atGroundFrameNum].handlerY;\r\n\r\n\t// set the stuff all these types have in common\r\n\tenemyData.goingToPoint=true;\r\n\tif (enemyData.isPosRelative){\r\n\t\t// correct the coordinates to be relative\r\n\t\tenemyData.goingToPointX-=gameWorld.xCamera;\r\n\t\tenemyData.goingToPointY-=gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// set the speed for going to such point\r\n\tsetSpeedForLinealMove(&enemyData,\r\n\t\tenemyData.goingToPointX, enemyData.goingToPointY,\r\n\t\tfallingSpeed);\r\n\r\n\t// set the current frame\r\n\tenemyData.currentFrame=nextFrameNum;\r\n\r\n\treturn true;// all ok\r\n}// unitStartFalling\r\n\r\n// This function does whatever has to be done every time an enemy unit\r\n// is freed (as sheeps and heads are freed, for example)...\r\n// To be freed, is to be taken off, by the anti wave generator\r\nbool enemyUnitFreed(enemyUnitStruct* enemyData){\r\n\r\n\tint unitScore;// score to add to the players, from the unit\r\n\tint* statisticToUse;// either scoreInFreeWhiteSheeps, scoreInFreeBlackSheeps or scoreInFreeHeads\r\n\r\n\t// calculate the score to increment\r\n\tswitch (enemyData->unitType){\r\n\tcase FILE_GAMEDATA_ENEMY_BLACKSHEEP:\r\n\t\t// calculate the score for the sheeps, but first check for\r\n\t\t// slave heads...\r\n\t\tif (enemyData->slaveUnit.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_ENEMY &&\r\n\t\t\tgetUnitPointer(enemyData->slaveUnit)!=NULL &&\r\n\t\t\tgetUnitPointer(enemyData->slaveUnit)->unitType==\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD){\r\n\r\n\t\t\t// it carries a head, act accordingly\r\n\t\t\t// calculate the score\r\n\t\t\tunitScore=enemyData->aiSpecific.sheepData.\r\n\t\t\t\tsheepScoreToGiveWhenFreedWithAHead;\r\n\t\t}else{\r\n\t\t\t// it doesn't carry any head, act accoridingly\r\n\t\t\t// calculate the score\r\n\t\t\tunitScore=enemyData->aiSpecific.sheepData.\r\n\t\t\t\tsheepScoreToGiveWhenFreed;\r\n\t\t}// if\r\n\r\n\t\t// set the statistic to use, to the right one\r\n\t\tstatisticToUse=&gameWorld.scoreInFreeBlackSheeps;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_WHITESHEEP:\r\n\t\t// calculate the score for the sheeps, but first check for\r\n\t\t// slave heads...\r\n\t\tif (enemyData->slaveUnit.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_ENEMY &&\r\n\t\t\tgetUnitPointer(enemyData->slaveUnit)!=NULL &&\r\n\t\t\tgetUnitPointer(enemyData->slaveUnit)->unitType==\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD){\r\n\r\n\t\t\t// it carries a head, act accordingly\r\n\t\t\t// calculate the score\r\n\t\t\tunitScore=enemyData->aiSpecific.sheepData.\r\n\t\t\t\tsheepScoreToGiveWhenFreedWithAHead;\r\n\t\t}else{\r\n\t\t\t// it doesn't carry any head, act accoridingly\r\n\t\t\t// calculate the score\r\n\t\t\tunitScore=enemyData->aiSpecific.sheepData.\r\n\t\t\t\tsheepScoreToGiveWhenFreed;\r\n\t\t}// if\r\n\r\n\t\t// set the statistic to use, to the right one\r\n\t\tstatisticToUse=&gameWorld.scoreInFreeWhiteSheeps;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_HUMANHEAD:\r\n\t\t// calculate the score for human heads\r\n\t\tunitScore=enemyData->aiSpecific.headData.headScoreToGiveWhenFreed;\r\n\t\t// set the statistic to use, to the right one\r\n\t\tstatisticToUse=&gameWorld.scoreInFreeHeads;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tunitScore=0;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// increment such score in all the players\r\n\tallPlayersIncrementScore(unitScore);\r\n\t// save the statistics...\r\n\t(*statisticToUse)+=unitScore;\r\n\r\n\treturn true;// all ok\r\n}// enemyUnitFreed\r\n\r\n// checkWaveAntigeneration ********\r\n// A function used to check if a given unit is inside a wave\r\n// antigenerator, and to do some management related to that.\r\n// This function is used for heads and sheeps.\r\n// It's important to note that no unit will be called if it's a slave\r\n// of another one... this means that our units won't be losing\r\n// 'slaves' before their score is well computed\r\nbool checkWaveAntigeneration(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit,\r\n\tbool* wasRemoved)\r\n{\r\n\tvectorListNodeStruct<waveGenUnitStruct>* wgUnit;\r\n\r\n\tframeDataStruct combFrame;\r\n\tframeDataStruct* wgFrame;\r\n\r\n\t// we use wasRemoved to inform about the existential status of the\r\n\t// given unit after this function finishes its execution.\r\n\tif (wasRemoved==NULL) return false;\r\n\t*wasRemoved=false;\r\n\r\n\t// traverse the wave generators list\r\n\tfor (wgUnit=waveGenList.getFirstNode(); wgUnit!=NULL;\r\n\t\twgUnit=waveGenList.getNextNode(wgUnit)){\r\n\r\n\t\t// never mind about inactive wave gens\r\n\t\tif (!wgUnit->data.nowActive) continue;\r\n\r\n\t\tif (wgUnit->data.unitType==FILE_GAMEDATA_WAVEGEN_SHEEPSOUT){\r\n\r\n\t\t\t// construct the frame info containing all the slaves\r\n\t\t\tif (!constructSlaverFullFrame(&unit.data, &combFrame))\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// get the frame info of the wave generator\r\n\t\t\twgFrame=getUnitFrame(&wgUnit->data);\r\n\t\t\tif (wgFrame==NULL) return false;\r\n\r\n\t\t\t// Checks for the unit being entirely inside the\r\n\t\t\t// wave antigenerator\r\n\t\t\tif (RECTINRECTANGLE(\r\n\t\t\t\tunit.data.x-(combFrame.handlerX),\r\n\t\t\t\tunit.data.y-(combFrame.handlerY),\r\n\t\t\t\tunit.data.x+(combFrame.w)-(combFrame.handlerX)-1,\r\n\t\t\t\tunit.data.y+(combFrame.h)-(combFrame.handlerY)-1,\r\n\t\t\t\twgUnit->data.x-(wgFrame->handlerX)+(wgFrame->cX),\r\n\t\t\t\twgUnit->data.y-(wgFrame->handlerY)+(wgFrame->cY),\r\n\t\t\t\twgUnit->data.x-(wgFrame->handlerX)+\r\n\t\t\t\t\t(wgFrame->cX)+(wgFrame->cW)-1,\r\n\t\t\t\twgUnit->data.y-(wgFrame->handlerY)+\r\n\t\t\t\t\t(wgFrame->cY)+(wgFrame->cH)-1)){\r\n\r\n\t\t\t\t// you know, it's going to be freed\r\n\t\t\t\t// act accordingly...\r\n\t\t\t\tif (!enemyUnitFreed(&unit.data)) return false;\r\n\r\n\t\t\t\t// it's inside, remove the unit...\r\n\t\t\t\t// free the slaves of this unit\r\n\t\t\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t\t\t// remove the unit\r\n\t\t\t\tif (!enemyList.removeNode(enemyList.getIndex(&unit)))\r\n\t\t\t\t\treturn false;\r\n/*\t\t\t\t// execute the escaped unit sound\r\n\t\t\t\tmakeSoundFriendlyUnitEscaped();*/\r\n\t\t\t\t// the unit has been removed, we cannot continue here\r\n\t\t\t\t*wasRemoved=true;\r\n\t\t\t\treturn true;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// for\r\n\r\n\treturn true;// all ok\r\n}// checkWaveAntigeneration\r\n\r\n\r\n// executeUnitAI ******\r\n// This method executes the individual AI of a unit.\r\nbool executeUnitAI(\r\n\tDWORD frameNumber,// current frame\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)// enemy unit to move\r\n{\r\n\tgenericUnitTypeDataStruct* myType=&(enemyType[unit.data.unitType]);\r\n\tframeDataStruct* myUnitFrame=&(myType->frames[unit.data.currentFrame]);\r\n\r\n\t// we use this to know if the unit was going to a given point\r\n\t// before executing the unintelligent lineal movement\r\n\tbool wasGoingToPoint=unit.data.goingToPoint;\r\n\r\n\t// AUTOFRAMING BEGIN\r\n\t// auto frame it\r\n\tif (!autoFrameUnit(&(unit.data))) return false;\r\n\r\n\t// check for negative frame numbers (they use to have a meaning,\r\n\t// attached)\r\n\tswitch(unit.data.currentFrame){\r\n\t// BULLET SPECIFIC CODE BEGIN\r\n\tcase -1:\r\n\t\t// frame -1 means: this unit should stop existing!\r\n\t\t// free the slaves of this unit\r\n\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t// remove the unit\r\n\t\tif (!enemyList.removeNode(enemyList.getIndex(&unit)))\r\n\t\t\treturn false;\r\n\t\t// the unit has been removed, we cannot continue here\r\n\t\treturn true;\r\n\t// BULLET SPECIFIC CODE END\r\n\tdefault:\r\n\t\t// no problem here...\r\n\t\tbreak;\r\n\t}// switch\r\n\t// AUTOFRAMING END\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\r\n\t// if this unit is a slave of any other, no more work should be\r\n\t// done here\r\n\tif (unit.data.slaveOf.objectType!=FILE_GAMEDATA_GAMEOBJECT_EMPTY)\r\n\t\treturn true;\r\n\r\n\t// move the unit with the camera if it's necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.x=gameWorld.xCamera+unit.data.xFromCamera;\r\n\t\tunit.data.y=gameWorld.yCamera+unit.data.yFromCamera;\r\n\t}// if\r\n\r\n\t// before anything, decrease the counters if needed\r\n\t// For being untouchable\r\n\tif (unit.data.untouchableTimeLeft>0){\r\n\t\tunit.data.untouchableTimeLeft--;\r\n\r\n\t\tif (unit.data.untouchableTimeLeft==0 && unit.data.energyLeft>0){\r\n\t\t\t// go back to the usual frame...\r\n\t\t\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t\t\tswitch(unit.data.unitType){\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\t\t\tif (!carrierFinishUntouchabilityEvent(unit))\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\r\n\t\t\t// to avoid mistakes, update the frame info\r\n\t\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t\t\t// ENEMIES SPECIFIC CODE END\r\n\t\t}// if\r\n\t}// if\r\n\t// For being unarmed\r\n\tif (unit.data.unarmedTimeLeft>0)\r\n\t\tunit.data.unarmedTimeLeft--;\r\n\r\n\t// should we move the unit to some specific point?\r\n\t// that is, unintelligent movement vs. intelligent movement\r\n\tif (unit.data.goingToPoint){\r\n\t\tif (!unintelligentLinealMove(&unit.data))\r\n\t\t\treturn false;// failed!\r\n\t}else{\r\n\t\t// UNIT AI\r\n\t\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t\t// move it as preferred by the unit\r\n\t\t// nothing of interest to be done here\r\n\t\t// ENEMIES SPECIFIC CODE END\r\n\t}// if\r\n\r\n\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t// it ain't easy being a white sheep\r\n/*\t// execute the characteristic sheep sound now, once every\r\n\t// half a second in average, of being at ground\r\n\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\t\t// all the sheeps feel compelled to scream 'meeeeeeee',\r\n\t\t// once every four seconds on average\r\n\t\tif ((rand()%(desiredFramesPerSecond*4))==0){\r\n\t\t\tmakeSoundHappySheep();\r\n\t\t}// if\r\n\t}// if\r\n*/\t// ENEMIES SPECIFIC CODE END\r\n\r\n\t// check for switches in the linear movement...\r\n\tif (wasGoingToPoint && !unit.data.goingToPoint){\r\n\t\t// it has switched from lineal movement to other ai... do\r\n\t\t// whatever is necessary to continue\r\n\r\n\t\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t\t// switch in stuff carriers\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_HEADCARRIER ||\r\n\t\t\tunit.data.unitType==FILE_GAMEDATA_ENEMY_SHEEPCARRIER){\r\n\r\n\t\t\t// execute the switch event itself\r\n\t\t\tif (!carrierLinearMovementDoneEvent(unit))\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// switch in human heads\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_HUMANHEAD){\r\n\r\n\t\t\t// execute the switch event itself\r\n\t\t\tif (!headLinearMovementDoneEvent(unit))\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// switch in sheeps\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_BLACKSHEEP ||\r\n\t\t\tunit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\t// execute the switch event itself\r\n\t\t\tif (!sheepLinearMovementDoneEvent(unit))\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// ENEMIES SPECIFIC CODE END\r\n\t}else{\r\n\t\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t\t// SHEEP SPECIFIC CODE BEGIN\r\n\t\t// it's doing NOTHING right now... sometimes it's useful\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_BLACKSHEEP ||\r\n\t\t\tunit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\tchar* event=getUnitFrame(&unit.data)->nextEventName;\r\n\t\t\tint framesAmount=\r\n\t\t\t\tgetUnitFrame(&unit.data)->autoShowVirtualFrames;\r\n\r\n\t\t\t// for white sheeps\r\n\t\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP &&\r\n\t\t\t\tevent!=NULL &&\r\n\t\t\t\t(int(unit.data.vFramesPassed)==framesAmount-1) &&\r\n\t\t\t\tstrcmp(event, \"eventWSheep_startWalking\")==0){\r\n\r\n\t\t\t\t// make the sheep start walking to its home\r\n\t\t\t\tif (!makeSheepWalk(unit)) return false;\r\n\t\t\t}// if\r\n\r\n\t\t\t// for black sheeps (bodies)\r\n\t\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_BLACKSHEEP &&\r\n\t\t\t\tevent!=NULL &&\r\n\t\t\t\t(int(unit.data.vFramesPassed)==framesAmount-1) &&\r\n\t\t\t\tstrcmp(event, \"eventBSheep_startWalking\")==0){\r\n\r\n\t\t\t\t// make the sheep start walking to its home\r\n\t\t\t\tif (!makeSheepWalk(unit)) return false;\r\n\t\t\t}// if\r\n\r\n\t\t}// if\r\n\t\t// SHEEP SPECIFIC CODE END\r\n\t\t// ENEMIES SPECIFIC CODE END\r\n\t}// if\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\t// update the *FromCamera variables if necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.xFromCamera=unit.data.x-gameWorld.xCamera;\r\n\t\tunit.data.yFromCamera=unit.data.y-gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// let's move the unit with the owner unit, if any\r\n\tif (!moveWithOwner(&unit.data)) return false;\r\n\r\n\t// ENEMIES SPECIFIC CODE BEGIN\r\n\t// Time to check for sheeps and heads inside the wave antigenerators\r\n\tswitch (unit.data.unitType){\r\n\tcase FILE_GAMEDATA_ENEMY_BLACKSHEEP:\r\n\tcase FILE_GAMEDATA_ENEMY_WHITESHEEP:\r\n\tcase FILE_GAMEDATA_ENEMY_HUMANHEAD:\r\n\t\tbool wasRemoved;\r\n\r\n\t\t// do such check for this unit\r\n\t\tif (!checkWaveAntigeneration(unit, &wasRemoved)) return false;\r\n\r\n\t\t// if the unit was removed, we cannot continue here\r\n\t\tif (wasRemoved) return true;\r\n\t\tbreak;\r\n\t}// switch\r\n\t// ENEMIES SPECIFIC CODE END\r\n\r\n\t// VISIBILITY CHECK BEGIN\r\n\t// Checks for visibility after the unit moved...\r\n\tif (isUnitInsideTheScreen(&unit.data)){\r\n\r\n\t\t// It's inside the screen, zero the counter\r\n\t\tunit.data.timeOutsideTheScreenLeft=0;\r\n\t}else{\r\n\t\t// The unit is outside the screen.\r\n\t\tif (unit.data.timeOutsideTheScreenLeft<=0){\r\n\t\t\t// That's the first time now, set to the max\r\n\t\t\tunit.data.timeOutsideTheScreenLeft=\r\n\t\t\t\tunit.data.timeOutsideTheScreenMax;\r\n\t\t}else{\r\n\t\t\t// It's not the first time, decrement the counter first\r\n\t\t\tunit.data.timeOutsideTheScreenLeft--;\r\n\t\t}// if\r\n\r\n\t\t// Now see if it hasn't been too much time out there\r\n\t\tif (unit.data.timeOutsideTheScreenLeft<=0){\r\n\t\t\t// It's been too much time out there, remove it.\r\n\t\t\t// free the slaves of this unit\r\n\t\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t\t// remove the unit\r\n\t\t\tif (!enemyList.removeNode(enemyList.getIndex(&unit)))\r\n\t\t\t\treturn false;\r\n\t\t\t// the unit has been removed, we cannot continue here\r\n\t\t\treturn true;\r\n\t\t}// if\r\n\t}// if\r\n\t// END VISIBILITY CHECK\r\n\r\n\treturn true;// all ok\r\n}// executeUnitAI\r\n\r\n// executeEnemyAI *****\r\n// This method executes the individual AI of all the enemies in the\r\n// game world (executed once per game frame).\r\nbool executeEnemyAI(DWORD frameNumber)\r\n{\r\n\tvectorListNodeStruct<enemyUnitStruct> *unit;\r\n\r\n\t// Manage the AI of all the enemies on screen...\r\n\tfor (unit=enemyList.getFirstNode(); unit!=NULL; unit=enemyList.getNextNode(unit)){\r\n\t\t// don't move this unit if it's not active now\r\n\t\tif (!unit->data.nowActive) continue;\r\n\r\n\t\t// execute the ai of this unit\r\n\t\tif (!executeUnitAI(frameNumber, *unit)) return false;\r\n\t}// for unit\r\n\r\n\treturn true;// all ok\r\n}// executeEnemyAI\r\n\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"fileString.h\"// for accessing to strings, memory, files and windows resources in an only simple way\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n\r\n// FILE STRING CLASS METHODS\r\n// *************************\r\n\r\n// OPENERS\r\n// openFromFile ******\r\n// initializes the fileString object from a file... all next method\r\n// calls asking for string data will actually taking that data from\r\n// the file.\r\nbool fileStringClass::openFromFile(char* fileName)\r\n{\r\n\tFILE* file;\r\n\tDWORD fsize;\r\n\tDWORD readed;\r\n\r\n\tif (isReady()) return false;// should be closed first, if it has been initialized before\r\n\r\n\t// open the file\r\n\tfile=fopen(fileName, \"rb\");\r\n\tif (file==NULL) return false;\r\n\r\n\t// get the file size and check for errors\r\n\tif (fseek(file,0,SEEK_END)!=0){\r\n\t\tfclose(file);\r\n\t\treturn false;\r\n\t}\r\n\tfsize=ftell(file);\r\n\tfseek(file,0,SEEK_SET);\r\n\r\n\t// create the memory and set up the data...\r\n\tmemory=new BYTE[fsize];\r\n\r\n\t// read the data...\r\n\treaded=fread(memory, 1, fsize, file);\r\n\t// TODO 2010: big while for this\r\n\tif (readed<fsize) return false;\r\n\r\n\t// close the file...\r\n\tfclose(file);\r\n\r\n\t// set up the filestring data...\r\n\tshouldReleaseMemory=true;\r\n\tsize=fsize;\r\n\tready=true;\r\n\r\n\t// all ok...\r\n\treturn true;\r\n}// openFromFile\r\n/*\r\n// openFromResource ******\r\n// initializes the fileString object from a windows resource...\r\n// all next method calls asking for string data will actually taking\r\n// that data from the resource.\r\nbool fileStringClass::openFromResource(\r\n\tchar* resName,// resource name\r\n\tHINSTANCE hInstance)// app instance handler\r\n{\r\n\tif (isReady()) return false;// should be closed first, if it has been initialized before\r\n\r\n\t// yet to be implemented, check open from file to see how\r\n\treturn false;\r\n}// openFromResource \r\n*/\r\n// openFromStringZ ******\r\n// initializes the fileString object from a string ending in zero\r\n// all next method calls asking for string data will actually taking\r\n// that data from the stringZ\r\nbool fileStringClass::openFromStringZ(\r\n\tchar* stringz,// pointer to the string itself\r\n\tbool localCopy)// will the string be copied to a memory position that is local to this object?\r\n{\r\n\tif (isReady()) return false;// should be closed first, if it has been initialized before\r\n\r\n\t// get the size data...\r\n\tsize=strlen(stringz);\r\n\r\n\t// do the local copy of the data if needed\r\n\tif (localCopy){\r\n\t\t// do a copy of the data\r\n\t\tmemory=new char[size];\r\n\t\tmemcpy(memory, stringz, size);\r\n\t}else{\r\n\t\t// no copy, it's actually easier\r\n\t\tmemory=stringz;\r\n\t}// if\r\n\r\n\t// set all up\r\n\tshouldReleaseMemory=localCopy;\r\n\tready=true;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// openFromStringZ\r\n\r\n// openFromMemory ******\r\n// initializes the fileString object from a memory pointer\r\n// all next method calls asking for string data will actually taking\r\n// that data from that memory position.\r\nbool fileStringClass::openFromMemory(\r\n\tvoid* mem,// pointer to the memory data itself\r\n\tint memSize,// size of the memory to be used\r\n\tbool localCopy)// will the string be copied to a memory position that is local to this object?\r\n{\r\n\tif (isReady()) return false;// should be closed first, if it has been initialized before\r\n\r\n\t// do the local copy of the data if needed\r\n\tif (localCopy){\r\n\t\t// do a copy of the data\r\n\t\tmemory=new BYTE[memSize];\r\n\t\tmemcpy(memory, mem, memSize);\r\n\t}else{\r\n\t\t// no copy, it's actually easier\r\n\t\tmemory=mem;\r\n\t}// if\r\n\r\n\t// set all up\r\n\tshouldReleaseMemory=localCopy;\r\n\tsize=memSize;\r\n\tready=true;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// openFromMemory \r\n\r\n// CLOSERS\r\n// close *********\r\n// This method closes the fileString object\r\nbool fileStringClass::close()\r\n{\r\n\tif (!isReady()) return false;// should be initialized first\r\n\r\n\t// when needed, release the memory used for the data (only\r\n\t// when it's 'local' to the object)\r\n\tif (shouldReleaseMemory) delete[] ((BYTE*)memory);\r\n\r\n\t// close all\r\n\tready=false;\r\n\r\n\t// closed!\r\n\treturn true;\r\n}// close\r\n\r\n// SIMPLE INTERFACES\r\n\r\n// getDataPointer ********\r\n// This method returns a pointer to the data in memory\r\nvoid* fileStringClass::getDataPointer()\r\n{\r\n\tif (!isReady()) return false;// should be initialized first\r\n\r\n\treturn memory;\r\n}// getDataPointer\r\n\r\n// isReady **********\r\n// This method simply tells whether we are ready or not for using\r\n// this object (that is, if it has been initialized)\r\nbool fileStringClass::isReady()\r\n{\r\n\treturn ready;\r\n}// isReady\r\n\r\n// getDataSize *********\r\n// This method returns the amount of bytes that are to be accessed\r\n// with getDataPointer... that is, what the file / resource / string\r\n// / memory size is\r\nint fileStringClass::getDataSize()\r\n{\r\n\tif (!isReady()) return false;// should be initialized first\r\n\r\n\treturn size;\r\n}// getDataSize\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nFILESTRING.*:\r\n(fileString: an object designed to homogenize the access to files,\r\nwindows resources and strings or memory in general)\r\n\r\nThese files contain the declaration of the fileString object,\r\nwhich was designed to homogenize the access to files,\r\nwindows resources, strings and memory in general.\r\n\r\n*/\r\n\r\n#ifndef FILE_FILESTRING_INCLUDED\r\n#define FILE_FILESTRING_INCLUDED\r\n\r\n#define FILE_FILESTRING_VERSION \"27-7-2003-H\"// last modification: dd/mm/yy\r\n\r\n\r\n#include \"win-constants.h\"\r\n\r\n// FILE STRING CLASS\r\n// The fileString object\r\nclass fileStringClass{\r\nprivate:\r\n\tvoid* memory;\r\n\tbool shouldReleaseMemory;\r\n\tint size;\r\n\tbool ready;\r\npublic:\r\n\t// constructor / destructor\r\n\tfileStringClass():ready(false){}\r\n\tvirtual ~fileStringClass(){close();}\r\n\r\n\t// openers\r\n\tvirtual bool openFromFile(char* fileName);\r\n/*\tvirtual bool openFromResource(char* resName, HINSTANCE hInstance);*/\r\n\tvirtual bool openFromStringZ(char* stringz, bool localCopy=false);\r\n\tvirtual bool openFromMemory(void* mem, int memSize, bool localCopy=false);\r\n\r\n\t// closers\r\n\tvirtual bool close();\r\n\r\n\t// simple interfaces\r\n\tvirtual void* getDataPointer();\r\n\tvirtual bool isReady();\r\n\tvirtual int getDataSize();\r\n};// fileStringClass\r\n\r\n#endif// FILE_FILESTRING_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#include \"fixedfontwrap.h\"// for creating and displaying fixed bitmapped fonts\r\n#include \"generalmaths.h\"// for mathematical functions\r\n\r\n\r\n// ****************\r\n// FIXED FONT CLASS\r\n// ****************\r\n\r\n// Protected and private methods:\r\n// ==============================\r\n\r\n// calculateTextLine ********\r\n// According to the font characteristics, this method separates the first\r\n// line of text it finds in a given multiline text, while keeping\r\n// the characters which determine line break (0xA and 0xD) out of sight.\r\nbool fixedFontClass::calculateTextLine(\r\n\tchar* text,// string where to find the line\r\n\tint textSize,// string size\r\n\tint maxWidth,// max width for the text, in pixels\r\n\tchar** startOfLine,// pointer to a char* which will point to the beginning of the next line of text, after executing this method\r\n\tint* lineSize)// pointer to an integer which will contain the size of the line starting in *startOfLine, after executing this method\r\n{\r\n\tbool endOfLoop=false;// this will tell us when we finished the calculation\r\n\tint maxWidthInChars=maxWidth/charW;\r\n\tchar* thisChar=text;\r\n\tchar* lastAcceptableEnd;// pointer to the char next to the latest character for this line\r\n\tchar* tmpStartOfLine;\r\n\r\n\t// avoid all the initial spaces...\r\n\twhile (thisChar-text<textSize && *thisChar==' ') thisChar++;\r\n\ttmpStartOfLine=thisChar;\r\n\tlastAcceptableEnd=thisChar;\r\n\r\n\t// for every word...\r\n\tdo{\r\n\t\t// check whether it's time to jump out of the text\r\n\t\tif (thisChar-text>=textSize ||\r\n\t\t\t*thisChar==0xA ||\r\n\t\t\t*thisChar==0xD){\r\n\r\n\t\t\tlastAcceptableEnd=thisChar;\r\n\t\t\tendOfLoop=true;\r\n\t\t}// if\r\n\r\n\t\tif (!endOfLoop){\r\n\t\t\t// look for the next non space character\r\n\t\t\twhile (thisChar-text<textSize && *thisChar!=' ' && *thisChar!=0xA && *thisChar!=0xD)\r\n\t\t\t\tthisChar++;\r\n\r\n\t\t\t// check if this word fits in the text box\r\n\t\t\tif (thisChar-tmpStartOfLine>maxWidthInChars){\r\n\t\t\t\t// It doesn't fit... it's time to decide whether to\r\n\t\t\t\t// partition it or not (only partition it if\r\n\t\t\t\t// real necessary)\r\n\t\t\t\tif (lastAcceptableEnd==tmpStartOfLine){\r\n\t\t\t\t\t// it's a word wider than the text box... draw it\r\n\t\t\t\t\t// in parts\r\n\t\t\t\t\tlastAcceptableEnd=tmpStartOfLine+maxWidthInChars;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// in any case, it's time to end the loop\r\n\t\t\t\tendOfLoop=true;\r\n\t\t\t}// if\r\n\r\n\t\t\tif (!endOfLoop){\r\n\t\t\t\t// if it fitted, let's considerate this word into the\r\n\t\t\t\t// accepted line until now\r\n\t\t\t\tlastAcceptableEnd=thisChar;\r\n\r\n\t\t\t\t// avoid all the spaces...\r\n\t\t\t\twhile (thisChar-text<textSize && *thisChar==' ') thisChar++;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}while (!endOfLoop);\r\n\r\n\t// save the values to return\r\n\t(*startOfLine)=tmpStartOfLine;\r\n\t(*lineSize)=lastAcceptableEnd-tmpStartOfLine;\r\n\r\n\treturn true;// all ok\r\n}// calculateNextLine\r\n\r\n// privateDrawTextLine *************\r\n// This method is used to draw a line of text in a given surface,\r\n// with any alignment, or to calculate the size of such a text line...\r\n// private method to be used only by the class itself\r\nbool fixedFontClass::privateDrawTextLine(\r\n\tddSurfaceClass& srfTo,// surface where to draw the text\r\n\tchar* text,// text to draw\r\n\tint textSize,// size of the string to draw\r\n\tint x, int y,// position where to draw the text\r\n\tint boxWidth, int boxHeight,// size of the text box (used for clipping)\r\n\tbool transparent,// will the text be transparent?\r\n\talignEnum alignment,// text alignment, either FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER or FILE_DDWRAP_ALIGN_RIGHT\r\n\tbool drawText,// tells whether we'll draw the text, or only calculate it\r\n\tint* definitiveX, int* definitiveY,// pointer to variables where to return the actual x and y coordinates (and box size) where the text was placed... if null, they aren't used\r\n\tint* definitiveW, int* definitiveH)\r\n{\r\n\tint realX, realY;// coordinates of the text, after aligned\r\n\tint textWidth=textSize*charW;// width of the text to draw\r\n\r\n\t// assume left alignment...\r\n\trealX=x; realY=y;\r\n\r\n\t// calculate the text coordinates after aligned, but only if\r\n\t// text is not wider than the text box\r\n\tif (textWidth<=boxWidth){\r\n\t\tswitch (alignment){\r\n\t\tcase FILE_DDWRAP_ALIGN_LEFT:// left align\r\n\t\tdefault:\r\n\t\t\trealX=x;\r\n\t\t\trealY=y;\r\n\t\t\tbreak;\r\n\t\tcase FILE_DDWRAP_ALIGN_CENTER:// center align\r\n\t\t\trealX=(boxWidth-textWidth)/2+x;\r\n\t\t\trealY=y;\r\n\t\t\tbreak;\r\n\t\tcase FILE_DDWRAP_ALIGN_RIGHT:// right align\r\n\t\t\trealX=x+(boxWidth-textWidth);\r\n\t\t\trealY=y;\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t}// if\r\n\r\n\t// fill the definitive coordinates of the text, to be returned\r\n\tif (definitiveX!=NULL) (*definitiveX)=realX;\r\n\tif (definitiveY!=NULL) (*definitiveY)=realY;\r\n\tif (definitiveW!=NULL) (*definitiveW)=MIN(textWidth, boxWidth);\r\n\tif (definitiveH!=NULL) (*definitiveH)=MIN(charH, boxHeight);\r\n\r\n\t// call the low level draw text method (implementation dependent)\r\n\tif (drawText){\r\n\t\t// draw it\r\n\t\treturn lowLevelDrawTextLine(\r\n\t\t\tsrfTo,// surface\r\n\t\t\ttext, textSize,// text and text size\r\n\t\t\trealX, realY,// text coordinates\r\n\t\t\tx, y,// clip box, starting coordinates\r\n\t\t\tboxWidth, boxHeight,// size of the clip box\r\n\t\t\ttransparent);// transparency\r\n\t}else{\r\n\t\treturn true;// only calculate the text size\r\n\t}// if\r\n}// privateDrawTextLine\r\n\r\n// privateDrawMultilineText ********\r\n// This method is used to draw a text in a given surface, with any\r\n// alignment, dividing it in multiple lines as it's needed, or to\r\n// calculate the size of such a text, or both... method to be used only\r\n// by the class itself\r\nbool fixedFontClass::privateDrawMultilineText(\r\n\tddSurfaceClass& srfTo,// surface where to draw the text\r\n\tchar* text,// text to draw\r\n\tint textSize,// size of the string to draw\r\n\tint x, int y,// position where to draw the text\r\n\tint boxWidth, int boxHeight,// size of the text box (used for clipping)\r\n\tbool transparent,// will the text be transparent?\r\n\talignEnum alignment,// text alignment, either FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER or FILE_DDWRAP_ALIGN_RIGHT\r\n\tbool drawText,// tells whether we'll draw the text, or only calculate it\r\n\tint* definitiveX, int* definitiveY,// pointer to variables where to return the actual x and y coordinates (and box size) where the text was placed... if null, they aren't used\r\n\tint* definitiveW, int* definitiveH)\r\n{\r\n\tchar* currChar=text;\r\n\tint currX=x, currY=y;\r\n\tint lineSize;\r\n\r\n\t// temporary variables to be used while calculating the definitive\r\n\t// text size...\r\n\tint tempDX=x+boxWidth, tempDY=y+boxHeight, tempDX2=x, tempDY2=y;\r\n\tint lastDX, lastDY, lastDW, lastDH;\r\n\r\n\t// one exceptional case: if width is lower than the character\r\n\t// width, there is nothing to be drawn\r\n\tif (boxWidth<charW){\r\n\t\t// return an ok error code, but do nothing really, and\r\n\t\t// notify the box is an empty one\r\n\t\tif (definitiveX!=NULL) (*definitiveX)=x;\r\n\t\tif (definitiveY!=NULL) (*definitiveY)=y;\r\n\t\tif (definitiveW!=NULL) (*definitiveW)=0;\r\n\t\tif (definitiveH!=NULL) (*definitiveH)=0;\r\n\t\treturn true;\r\n\t}// if\r\n\r\n\twhile(currChar-text<textSize){\r\n\t\t// calculate the next text line\r\n\t\tif (!calculateTextLine(\r\n\t\t\tcurrChar,  textSize-(currChar-text),// text and text size\r\n\t\t\tboxWidth,// maxWidth\r\n\t\t\t&currChar, &lineSize)){// to be returned by the function\r\n\r\n\t\t\t// error\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// draw the line...\r\n//\t\tif (lineSize!=0){\r\n\t\t\tif (!privateDrawTextLine(\r\n\t\t\t\tsrfTo,// the surface\r\n\t\t\t\tcurrChar, lineSize,// text and text size\r\n\t\t\t\tcurrX, currY,// line position\r\n\t\t\t\tboxWidth, boxHeight,// text box size\r\n\t\t\t\ttransparent, alignment,// some other stuff\r\n\t\t\t\tdrawText,// should we draw the text?\r\n\t\t\t\t&lastDX, &lastDY, &lastDW, &lastDH// where to store the real text box coordinates and size\r\n\t\t\t\t)){\r\n\r\n\t\t\t\t// error\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n//\t\t}// if\r\n\r\n\t\t// keep calculating the smallest text box which covers the text\r\n\t\ttempDX=MIN(tempDX, lastDX);\r\n\t\ttempDY=MIN(tempDY, lastDY);\r\n\t\ttempDX2=MAX(tempDX2, lastDX+lastDW);\r\n\t\ttempDY2=MAX(tempDY2, lastDY+lastDH);\r\n\r\n\t\t// increment the position in the text...\r\n\t\tcurrChar+=lineSize;\r\n\t\tif (currChar-text<textSize){\r\n\t\t\t// if we found a 0xD, let's see if there is a 0xA grouped with\r\n\t\t\t// it...\r\n\t\t\tif (*currChar==0xD){\r\n\t\t\t\tcurrChar++;\r\n\t\t\t\tif (currChar-text<textSize && *currChar==0xA) currChar++;\r\n\t\t\t} else if (*currChar==0xA){\r\n\t\t\t\tcurrChar++;\r\n\t\t\t}// if\r\n\t\t\t\t\r\n\t\t}// if\r\n\r\n\t\t// increment y...\r\n\t\tcurrY+=charH;\r\n\t}// while\r\n\r\n\t// return the text size data\r\n\tif (definitiveX!=NULL) (*definitiveX)=tempDX;\r\n\tif (definitiveY!=NULL) (*definitiveY)=tempDY;\r\n\tif (definitiveW!=NULL) (*definitiveW)=tempDX2-tempDX;\r\n\tif (definitiveH!=NULL) (*definitiveH)=tempDY2-tempDY;\r\n\r\n\treturn true;\r\n}// privateDrawMultilineText\r\n\r\n// Methods:\r\n// ========\r\n\r\n// calculateMultilineTextSize ********\r\n// This method is used to calculate the size of a given multiline text\r\n// as drawn by drawMultilineText.\r\nbool fixedFontClass::calculateMultilineTextSize(\r\n\tddSurfaceClass& srfTo,// surface where to draw the text\r\n\tchar* text,// text to draw\r\n\tint textSize,// size of the string to draw\r\n\tint x, int y,// position where to draw the text\r\n\tint boxWidth, int boxHeight,// size of the text box (used for clipping)\r\n\talignEnum alignment,// text alignment, either FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER or FILE_DDWRAP_ALIGN_RIGHT\r\n\tvalignEnum verticalAlignment,// text vertical alignment, either FILE_DDWRAP_VALIGN_TOP, FILE_DDWRAP_VALIGN_CENTER or FILE_DDWRAP_VALIGN_BOTTOM\r\n\tint* definitiveX, int* definitiveY,// pointer to variables where to return the text box coordinates and size\r\n\tint* definitiveW, int* definitiveH)\r\n{\r\n\tbool errorCode;\r\n\tint tempDX, tempDY, tempDW, tempDH;\r\n\r\n\t// let's calculate the text real size\r\n\terrorCode=privateDrawMultilineText(\r\n\t\tsrfTo, text, textSize,// surface and text\r\n\t\tx, y, boxWidth, boxHeight,// text box coordinates and size\r\n\t\tfalse, alignment, false,// transparency, alignment, and drawable\r\n\t\t&tempDX, &tempDY, &tempDW, &tempDH);// where to save the text size data\r\n\r\n\t// let's take into consideration the vertical alignment\r\n\tswitch(verticalAlignment){\r\n\tcase FILE_DDWRAP_VALIGN_TOP:\r\n\t\t// there is nothing to do in this case\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_VALIGN_CENTER:\r\n\t\ttempDY=(boxHeight-tempDH)/2+tempDY;\r\n\t\tbreak;\r\n\tcase FILE_DDWRAP_VALIGN_BOTTOM:\r\n\t\ttempDY=(boxHeight-tempDH)+tempDY;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// return the text size data\r\n\tif (definitiveX!=NULL) (*definitiveX)=tempDX;\r\n\tif (definitiveY!=NULL) (*definitiveY)=tempDY;\r\n\tif (definitiveW!=NULL) (*definitiveW)=tempDW;\r\n\tif (definitiveH!=NULL) (*definitiveH)=tempDH;\r\n\r\n\treturn errorCode;\r\n}// calculateMultilineTextSize\r\n\r\n// drawMultilineText ********\r\n// This method is used to draw a text in a given surface, with any\r\n// vertical and horizontal alignment, dividing it in multiple lines\r\n// as it's needed.\r\nbool fixedFontClass::drawMultilineText(\r\n\tddSurfaceClass& srfTo,// surface where to draw the text\r\n\tchar* text,// text to draw\r\n\tint textSize,// size of the string to draw\r\n\tint x, int y,// position where to draw the text\r\n\tint boxWidth, int boxHeight,// size of the text box (used for clipping)\r\n\tbool transparent,// will the text be transparent?\r\n\talignEnum alignment,// text alignment, either FILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_ALIGN_CENTER or FILE_DDWRAP_ALIGN_RIGHT\r\n\tvalignEnum verticalAlignment)// text vertical alignment, either FILE_DDWRAP_VALIGN_TOP, FILE_DDWRAP_VALIGN_CENTER or FILE_DDWRAP_VALIGN_BOTTOM\r\n{\r\n\t// calculate the coordinates we'll have to use\r\n\tint tempDX, tempDY, tempDW, tempDH;\r\n\r\n\tif (!calculateMultilineTextSize(\r\n\t\tsrfTo, text, textSize,// surface and text\r\n\t\tx, y, boxWidth, boxHeight,// text box coordinates size\r\n\t\talignment, verticalAlignment,// text alignment\r\n\t\t&tempDX, &tempDY, &tempDW, &tempDH// where to save the text size data\r\n\t\t)){\r\n\r\n\t\treturn false;// error!\r\n\t}// if\r\n\r\n\t// now it's time to draw the text\r\n\treturn privateDrawMultilineText(\r\n\t\tsrfTo, text, textSize,// surface and text\r\n\t\ttempDX, tempDY, tempDW, tempDH,// text box coordinates and size\r\n\t\ttransparent, alignment);// transparency, alignment\r\n}// drawMultilineText\r\n\r\n// **************************\r\n// BITMAPPED FIXED FONT CLASS\r\n// **************************\r\n\r\n// Protected and private methods:\r\n// ==============================\r\n\r\n// lowLevelDrawTextLine *****\r\n// This method manages the low level drawing of a one line text\r\n// in a surface. It might be different for every subclass of\r\n// fixedFontClass.\r\nbool bitmappedFixedFontClass::lowLevelDrawTextLine(\r\n\tddSurfaceClass& srfTo,// surface where to draw the text\r\n\tchar* text,// text to draw\r\n\tint textSize,// size of the string to draw\r\n\tint x, int y,// position where to draw the text\r\n\tint xClip, int yClip,// clip box\r\n\tint wClip, int hClip,\r\n\tbool transparent)// will the text be transparent?\r\n{\r\n\tint i;\r\n\tcharacterStruct* currCharInfo;// current char information\r\n\tchar* currChar=text;// current char\r\n\tint xTemp=x, yTemp=y;\r\n\r\n\t// check it's initialized\r\n\tif (!initialized) return false;\r\n\r\n\t// check for the clipping area being totally outside the surface\r\n\tif (!INTERSECTINGRECTANGLES(\r\n\t\t0, 0, srfTo.getWidth(), srfTo.getHeight(),// surface rectangle\r\n\t\txClip, yClip, xClip+wClip, yClip+hClip)){// clipping rectangle\r\n\r\n\t\t// nothing to draw in such case\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// calculate the clipping rectangle (correct it if it goes further than\r\n\t// the surface)\r\n\tif (xClip<0){\r\n\t\twClip+=xClip;\r\n\t\txClip=0;\r\n\t}// if\r\n\tif (yClip<0){\r\n\t\thClip+=yClip;\r\n\t\tyClip=0;\r\n\t}// if\r\n\tif (xClip+wClip>srfTo.getWidth()) wClip=srfTo.getWidth()-xClip;\r\n\tif (yClip+hClip>srfTo.getHeight()) hClip=srfTo.getHeight()-yClip;\r\n\r\n\t// draw every character\r\n\tfor (i=0; i<textSize; i++){\r\n\t\tcurrCharInfo=&(characters[(unsigned char)(*currChar)]);\r\n\r\n\t\tif (currCharInfo->isAllowed){\r\n\t\t\t// draw a character in the destination surface\r\n\t\t\tif (!srfTo.bltFrom(\r\n\t\t\t\t*surface,// source surface\r\n\t\t\t\txTemp, yTemp,// destination coordinates\r\n\t\t\t\tcurrCharInfo->x, currCharInfo->y,// source coordinates\r\n\t\t\t\tcharW, charH,// image size\r\n\t\t\t\txClip, yClip,// rectangle for clipping\r\n\t\t\t\twClip, hClip,\r\n\t\t\t\ttrue,// clip: true\r\n\t\t\t\ttransparent))// transparency?\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// go to the next character\r\n\t\tcurrChar++;\r\n\t\txTemp+=charW;\r\n\t}// for\r\n\r\n\treturn true;// all ok\r\n}// lowLevelDrawTextLine\r\n\r\n\r\n// Public methods:\r\n// ===============\r\n\r\n// init *************\r\n// This method initializes a fixed font object.\r\nbool bitmappedFixedFontClass::init(\r\n\tddSpriteClass* fontSurface,// surface containing the font data\r\n\tint charWidth,// fixed width for the characters\r\n\tint charHeight)// fixed height for the characters\r\n{\r\n\tint i;\r\n\r\n\t// check it's not already initialized\r\n\tif (initialized) return false;\r\n\r\n\t// initialize the characters data\r\n\tcharacters=new characterStruct[256];\t\r\n\tfor (i=0; i<256; i++) characters[i].isAllowed=false;\r\n\r\n\t// set other data\r\n\tsurface=fontSurface; charW=charWidth; charH=charHeight;\r\n\tinitialized=true;\r\n\t\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// end **************\r\n// Method which gives end to the fixed font object.\r\nbool bitmappedFixedFontClass::end()\r\n{\r\n\t// check it's initialized\r\n\tif (!initialized) return false;\r\n\r\n\tdelete[] characters;\r\n\t\r\n\tinitialized=false;\r\n\t\r\n\treturn true;// all ok\r\n}// end\r\n\r\n// setUpCharactersInMatrix ****\r\n// This methods prepares the characters information, in the case\r\n// characters are organized as a matrix in the font surface.\r\n// For example, if you have a characters matrix like the following one:\r\n//\t\tABCD\r\n//\t\tEFab\r\n//\t\tcdef\r\n// You'd use:\r\n// setUpCharactersInMatrix(\"ABCDEFabcdef\", 0, 0, 4, 0, 0);\r\nbool bitmappedFixedFontClass::setUpCharactersInMatrix(\r\n\tchar* string,// string showing all the characters present in the matrix, in the order they appear there (from left to right, then from top to bottom)\r\n\tint xMat, int yMat,// coordinates where the matrix starts\r\n\tint matWidthChars,// width of the matrix in characters\r\n\tint hSpace,// horizontal space, in pixels, between characters\r\n\tint vSpace)// vertical space, in pixels, between characters\r\n{\r\n\tchar* currChar;// current character\r\n\tcharacterStruct* currCharInfo;// current char information\r\n\tint x=xMat, y=yMat;// coordinates for every character\r\n\r\n\tfor (currChar=string; *currChar!=0; currChar++){\r\n\t\t// save the coordinates for this character\r\n\t\tcurrCharInfo=&(characters[(unsigned char)(*currChar)]);\r\n\t\tcurrCharInfo->isAllowed=true;\r\n\t\tcurrCharInfo->x=x;\r\n\t\tcurrCharInfo->y=y;\r\n\r\n\t\t// calculate the next character coordinates\r\n\t\tx+=charW+hSpace;\r\n\t\t// check whether we've reached the right border of the matrix or not\r\n\t\tif (x>=matWidthChars*(charW+hSpace)+xMat){\r\n\t\t\tx=xMat;\r\n\t\t\ty+=charH+vSpace;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\treturn true;\r\n}// setUpCharactersInMatrix\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n/*\r\nFIXEDFONTWRAP.*:\r\n\r\n\r\nThese files contain the code which manages loading and drawing fixed\r\nbitmapped fonts to a surface.\r\n\r\n*/\r\n\r\n#ifndef FILE_FIXEDFONTWRAP_INCLUDED\r\n#define FILE_FIXEDFONTWRAP_INCLUDED\r\n\r\n#define FILE_FIXEDFONTWRAP_VERSION \"6-8-2003-H\"// last modification: dd/mm/yy\r\n\r\n#include \"ddwrap.h\"\r\n\r\n// characterStruct **********\r\nstruct characterStruct {\r\n\tint x, y;// position of a character in the font surface\r\n\tbool isAllowed;// tells whether the character is available for this font, or not\r\n};// characterStruct\r\n\r\n// fixedFontClass ***********\r\nclass fixedFontClass{\r\nprivate:\r\nprotected:\r\n\tbool initialized;// was this font object initialized?\r\n\r\n\tint charW, charH;// width and height of the characters in this font\r\n\r\n\t// important protected methods implemented here\r\n\tvirtual bool calculateTextLine(char* text, int textSize, int maxWidth, char** startOfLine, int* lineSize);\r\n\r\n\t// important methods to be used by the class itself, implemented in\r\n\t// the subclasses\r\n\tvirtual bool lowLevelDrawTextLine(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y,\tint xClip, int yClip, int wClip, int hClip, bool transparent)=0;\r\n\tvirtual bool privateDrawTextLine(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int boxWidth, int boxHeight, bool transparent, alignEnum alignment=FILE_DDWRAP_ALIGN_LEFT, bool drawText=true, int* definitiveX=NULL, int* definitiveY=NULL, int* definitiveW=NULL, int* definitiveH=NULL);\r\n\tvirtual bool privateDrawMultilineText(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int boxWidth, int boxHeight, bool transparent, alignEnum alignment=FILE_DDWRAP_ALIGN_LEFT, bool drawText=true, int* definitiveX=NULL, int* definitiveY=NULL, int* definitiveW=NULL, int* definitiveH=NULL);\r\npublic:\r\n\t// constructors / destructors\r\n\tfixedFontClass():initialized(false){}\r\n\tvirtual ~fixedFontClass(){}\r\n\r\n\t// initialization / deinitialization\r\n\tvirtual bool end()=0;\r\n\r\n\t// simple interfaces\r\n\tvirtual bool isReady(){return initialized;}\r\n\tvirtual int getCharWidth(){return charW;}\r\n\tvirtual int getCharHeight(){return charH;}\r\n\r\n\t// important methods\r\n\tvirtual bool drawTextLine(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int boxWidth, int boxHeight, bool transparent, alignEnum alignment=FILE_DDWRAP_ALIGN_LEFT){\r\n\t\treturn privateDrawTextLine(srfTo, text, textSize, x, y, boxWidth, boxHeight, transparent, alignment);\r\n\t}// drawTextLine\r\n\tvirtual bool calculateMultilineTextSize(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int boxWidth, int boxHeight, alignEnum alignment=FILE_DDWRAP_ALIGN_LEFT, valignEnum verticalAlignment=FILE_DDWRAP_VALIGN_TOP, int* definitiveX=NULL, int* definitiveY=NULL, int* definitiveW=NULL, int* definitiveH=NULL);\r\n\tvirtual bool drawMultilineText(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int boxWidth, int boxHeight, bool transparent, alignEnum alignment=FILE_DDWRAP_ALIGN_LEFT, valignEnum verticalAlignment=FILE_DDWRAP_VALIGN_TOP);\r\n};// fixedFontClass\r\n\r\n\r\n// bitmappedFixedFontClass ***********\r\nclass bitmappedFixedFontClass:public fixedFontClass{\r\nprivate:\r\nprotected:\r\n\tcharacterStruct* characters;// array storing the position of every character in the surface attached to a font object\r\n\r\n\tddSpriteClass* surface;// surface which stores the image of the font\r\n\r\n\t// important methods to be used by the class itself\r\n\tvirtual bool lowLevelDrawTextLine(ddSurfaceClass& srfTo, char* text, int textSize, int x, int y, int xClip, int yClip, int wClip, int hClip, bool transparent);\r\npublic:\r\n\t// constructors / destructors\r\n\tbitmappedFixedFontClass(){}\r\n\tvirtual ~bitmappedFixedFontClass(){end();}\r\n\r\n\t// initialization / deinitialization\r\n\tvirtual bool init(ddSpriteClass* fontSurface, int charWidth, int charHeight);\r\n\tvirtual bool end();\r\n\r\n\t// simple interfaces\r\n\tcharacterStruct* getCharacters(){return characters;}\r\n\r\n\t// important methods\r\n\tbool setUpCharactersInMatrix(char* string, int xMat, int yMat, int matWidthChars, int hSpace, int vSpace);\r\n};// bitmappedFixedFontClass\r\n\r\n\r\n#endif // FILE_FIXEDFONTWRAP_INCLUDED\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"gamecode.h\"// for accessing to the code related only with the game\r\n#include \"gamedata.h\"\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"players.h\"// for managing the players\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n#include \"bullets.h\"// for managing the bullets\r\n#include \"collisions.h\"// for functions related to the collisions of units\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include \"diwrap.h\"// for understanding the input\r\n#include \"wavegens.h\"// for managing the wave generators\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include \"staging.h\"// for the management of stages, levels, and the switching between these\r\n#include \"optionsfile.h\"// for the management of the files where the game options are saved\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n// this integer tells what's the current frame number, only counting\r\n// those frames in which we aren't in pause mode.\r\nint nonPausedFrameNumber;\r\n\r\n// moveCamera ************\r\n// Move the camera\r\nbool moveCamera()\r\n{\r\n\t// move the camera itself\r\n\tgameWorld.xCamera+=gameWorld.xSpeedCamera;\r\n\tgameWorld.yCamera+=gameWorld.ySpeedCamera;\r\n\r\n\t// move the background alone\r\n\tgameWorld.bgOffX+=gameWorld.bgSpeedX;\r\n\tgameWorld.bgOffY+=gameWorld.bgSpeedY;\r\n\r\n\treturn true;// all ok\r\n}// moveCamera\r\n\r\n// drawBackgroundComplements ***************\r\n// This function draws all the useful information and stuff that goes\r\n// just over the background.\r\nbool drawBackgroundComplements(){\r\n\tint x, y;\r\n\tchar tempText[200];\r\n\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\r\n\r\n\t// draw the scores in the screen, even of those players who aren't\r\n\t// active right now (.nowActive=false)\r\n\tx=44; y=89;\r\n\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\tsprintf(tempText,\r\n\t\t\tLAN_SEL(\"PUNTAJE: %i\\nENERGIA: %i\",\r\n\t\t\t\t\"SCORE : %i\\nENERGY: %i\"),\r\n\t\t\tint(nodeP->data.score),\r\n\t\t\tint(nodeP->data.energyLeft));\r\n\t\tfntEdiaFont.drawMultilineText(DD, tempText, strlen(tempText),\r\n\t\t\tx, y, 83, 19, true,\r\n\t\t\tFILE_DDWRAP_ALIGN_LEFT, FILE_DDWRAP_VALIGN_CENTER);\r\n\r\n\t\tx+=300;\r\n\t}// for\r\n\r\n\t// draw the level number\r\n/*\tsprintf(tempText, \"%i\", gameWorld.currentLevel);\r\n\tfntDahFont.drawMultilineText(DD, tempText, strlen(tempText),\r\n\t\t24, 87, 20, 23, true,\r\n\t\tFILE_DDWRAP_ALIGN_CENTER, FILE_DDWRAP_VALIGN_CENTER);\r\n*/\r\n\t// all ok\r\n\treturn true;\r\n}// drawBackgroundComplements\r\n\r\n// drawForegroundComplements ***************\r\n// This function draws all the useful information and stuff that goes\r\n// just over the foreground (that is, over everything else).\r\nbool drawForegroundComplements()\r\n{\r\n\tint x, y;\r\n\tstatic char tempText[200];\r\n\r\n\tif (drawFallingLimits){\r\n\t\t// Also, draw the falling limits\r\n\t\t// for sheeps and heads\r\n\t\t// draw min for W\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.minXFallenWSheeps,// x\r\n\t\t\tgetGroundWall(gameWorld.maxXFallenWSheeps),// y\r\n\t\t\tgameWorld.minXFallenWSheeps,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t255, 0, 0)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the minXFallenWSheeps line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// draw max for W\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.maxXFallenWSheeps,// x\r\n\t\t\tgetGroundWall(gameWorld.maxXFallenWSheeps),// y\r\n\t\t\tgameWorld.maxXFallenWSheeps,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t255, 0, 0)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the maxXFallenWSheeps line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// draw min for B\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.minXFallenBSheeps,// x\r\n\t\t\tgetGroundWall(gameWorld.minXFallenBSheeps),// y\r\n\t\t\tgameWorld.minXFallenBSheeps,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t0, 255, 0)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the minBFallenWSheeps line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// draw max for B\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.maxXFallenBSheeps,// x\r\n\t\t\tgetGroundWall(gameWorld.maxXFallenBSheeps),// y\r\n\t\t\tgameWorld.maxXFallenBSheeps,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t0, 255, 0)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the maxXFallenBSheeps line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// draw min for heads\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.minXFallenHeads,// x\r\n\t\t\tgetGroundWall(gameWorld.minXFallenHeads),// y\r\n\t\t\tgameWorld.minXFallenHeads,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t0, 0, 255)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the minBFallenHeads line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// draw max for heads\r\n\t\tif (!gameWorld.srfGameScreen->drawLine(\r\n\t\t\tgameWorld.maxXFallenHeads,// x\r\n\t\t\tgetGroundWall(gameWorld.maxXFallenHeads),// y\r\n\t\t\tgameWorld.maxXFallenHeads,// x2\r\n\t\t\tgameWorld.hCamera-1,// y2\r\n\t\t\t0, 0, 255)){// color\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the maxXFallenHeads line\");\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// Now, draw the virtual walls limits\r\n\t// But only draw them if required\r\n\tif (drawVirtualWalls){\r\n\t\tfor (y=0; y<int(gameWorld.hCamera); y++){\r\n\t\t\t// draw left wall\r\n\t\t\tx=getLeftWall(y);\r\n\t\t\tx=(x<0?0:x);// not less than zero\r\n\t\t\tx=(x>int(gameWorld.wCamera)-1?// not more than the screen width\r\n\t\t\t\tint(gameWorld.wCamera)-1:x);\r\n\t\t\tif (!gameWorld.srfGameScreen->putPixel(\r\n\t\t\t\tx+int(gameWorld.screenX-(gameWorld.xCamera)),// x\r\n\t\t\t\ty+int(gameWorld.screenY-(gameWorld.yCamera)),// y\r\n\t\t\t\t255, 255, 255)){\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the left wall at (%i, %i)\",\r\n\t\t\t\t\ttrue, true, true, x, y);\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\r\n\t\t\t// draw rightwall\r\n\t\t\tx=getRightWall(y);\r\n\t\t\tx=(x<0?0:x);// not less than zero\r\n\t\t\tx=(x>int(gameWorld.wCamera)-1?// not more than the screen width\r\n\t\t\t\tint(gameWorld.wCamera)-1:x);\r\n\t\t\tif (!gameWorld.srfGameScreen->putPixel(\r\n\t\t\t\tx+int(gameWorld.screenX-(gameWorld.xCamera)),// x\r\n\t\t\t\ty+int(gameWorld.screenY-(gameWorld.yCamera)),// y\r\n\t\t\t\t255, 255, 255)){\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the right wall at (%i, %i)\",\r\n\t\t\t\t\ttrue, true, true, x, y);\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// for\r\n\r\n\t\tfor (x=0; x<int(gameWorld.wCamera); x++){\r\n\t\t\t// draw ground wall\r\n\t\t\ty=getGroundWall(x);\r\n\t\t\ty=(y<0?0:y);// not less than zero\r\n\t\t\ty=(y>int(gameWorld.hCamera)-1?// not more than the screen width\r\n\t\t\t\tint(gameWorld.hCamera)-1:y);\r\n\t\t\tif (!gameWorld.srfGameScreen->putPixel(\r\n\t\t\t\tx+int(gameWorld.screenX-(gameWorld.xCamera)),// x\r\n\t\t\t\ty+int(gameWorld.screenY-(gameWorld.yCamera)),// y\r\n\t\t\t\t255, 255, 255)){\r\n\r\n\t\t\t\t// error when drawing!\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Failed drawing the ground wall at (%i, %i)\",\r\n\t\t\t\t\ttrue, true, true, x, y);\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// for\r\n\t}// if\r\n\r\n\r\n\t// if it's time to show the game over message, draw it\r\n\tchar* gameOverText=LAN_SEL(\"-- JUEGO TERMINADO --\",\"-- GAME OVER --\");\r\n\tif (gameWorld.showGameOverMessage){\r\n\t\tfntEdiaBigFont.drawMultilineText(\r\n\t\t\tDD,// where to draw the text to\r\n\t\t\tgameOverText,// text to draw\r\n\t\t\tstrlen(gameOverText),// text size\r\n\t\t\t0, 0,// position\r\n\t\t\tDD.getWidth(), DD.getHeight(),// text size\r\n\t\t\ttrue,// transparency\r\n\t\t\tFILE_DDWRAP_ALIGN_CENTER,// alignment\r\n\t\t\tFILE_DDWRAP_VALIGN_CENTER);// vertical alignment\r\n\t}// if\r\n\r\n\t// if it's paused, draw a text telling about it\r\n\tchar* pausedText=LAN_SEL(\"-- PAUSA --\", \"-- PAUSED --\");\r\n\tif (gameWorld.isGamePaused){\r\n\t\tfntEdiaBigFont.drawMultilineText(\r\n\t\t\tDD,// where to draw the text to\r\n\t\t\tpausedText,// text to draw\r\n\t\t\tstrlen(pausedText),// text size\r\n\t\t\t0, 0,// position\r\n\t\t\tDD.getWidth(), DD.getHeight(),// text size\r\n\t\t\ttrue,// transparency\r\n\t\t\tFILE_DDWRAP_ALIGN_CENTER,// alignment\r\n\t\t\tFILE_DDWRAP_VALIGN_CENTER);// vertical alignment\r\n\t}// if\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// drawForegroundComplements\r\n\r\n// drawBackground ********\r\n// Draw the background on the game screen.\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool drawBackground()\r\n{\r\n\tint bgX, bgY;\r\n\tint bgW, bgH;\r\n\r\n\t// Fill all the screen using our background image (tiled)...\r\n\t// The position of the background is calculated considering\r\n\t// both the xCamera and yCamera values (which tell the current\r\n\t// camera position), and the bgOffX and bgOffY (which tell the\r\n\t// current background offset)\r\n\r\n\t// Calculate the background size\r\n\tbgW=gameWorld.srfBg->getWidth();\r\n\tbgH=gameWorld.srfBg->getHeight();\r\n\r\n\t// go check what's the initial Y background offset\r\n\tbgY=-((int)(gameWorld.yCamera+gameWorld.bgOffY)%bgH);\r\n\tif (bgY>0) bgY=bgY-bgH;\r\n\r\n\t// Loop for all the rows of tiles in the background.\r\n\tfor (; bgY<(int)(gameWorld.hCamera); bgY+=bgH){\r\n\r\n\t\t// go check what's the initial Y background offset\r\n\t\tbgX=-((int)(gameWorld.xCamera+gameWorld.bgOffX)%bgW);\r\n\t\tif (bgX>0) bgX=bgX-bgW;\r\n\r\n\t\t// Loop for all the tiles in this row...\r\n\t\tfor (; bgX<(int)(gameWorld.wCamera); bgX+=bgW){\r\n\r\n\t\t\t// Blt it.\r\n\t\t\tgameWorld.srfGameScreen->bltFrom(\r\n\t\t\t\t*(gameWorld.srfBg),\r\n\t\t\t\tgameWorld.screenX+bgX,// dest coordinates\r\n\t\t\t\tgameWorld.screenY+bgY,\r\n\t\t\t\t0, 0, bgW, bgH,// source coordinates\r\n\t\t\t\tgameWorld.screenX, gameWorld.screenY,// clipping coordinates\r\n\t\t\t\tgameWorld.wCamera, gameWorld.hCamera,\r\n\t\t\t\ttrue, false);\r\n\t\t}// for bgX\r\n\t}// for bgY\r\n\r\n\t// draw all what goes just over the background\r\n\tif (!drawBackgroundComplements()) return false;\r\n\r\n\treturn true;// all ok\r\n}// drawBackground\r\n\r\n// drawUnit **********\r\n// Draws a given unit on the screen.\r\n// Assumes the unit is drawable and active now (that is, it has to be\r\n// drawn really).\r\nbool drawUnit(genericUnitStruct* unit)\r\n{\r\n\tint x, y;// coordinates\r\n\tint cx, cy;// coordinates for collision\r\n\tgenericUnitTypeDataStruct* myUnitType;\r\n\tgenericUnitTypeDataStruct* typeDataList;\r\n\r\n\t// frame of this unit\r\n\tframeDataStruct* myUnitFrame;\r\n\r\n\t// we have to get this value from the unit type\r\n\tint pixelsToTrembleWhenTrembling;\r\n\r\n\t// make sure the unit isn't a null pointer\r\n\tif (unit==NULL) return false;\r\n\r\n\t// check if this unit has a slave of his own...\r\n\tif (unit->slaveUnit.objectType!=FILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\t\t// it has a slave, draw that one first\r\n\t\tif (!drawUnit(getUnitPointer(unit->slaveUnit)))\r\n\t\t\treturn false;\r\n\t}// if\r\n\r\n\t// get the data specific to this kind of unit\r\n\ttypeDataList=getTypeDataStruct(unit->objectType);\r\n\tif (typeDataList==NULL) return false;\r\n\tmyUnitType=&(typeDataList[unit->unitType]);\r\n\r\n\t// set some data data...\r\n\tmyUnitFrame=&(myUnitType->frames[unit->currentFrame]);\r\n\tpixelsToTrembleWhenTrembling=\r\n\t\tmyUnitType->pixelsToTrembleWhenUntouchable;\r\n\r\n\t// calculate the coordinates...\r\n\t// (int)(unit->x)-(myUnitFrame->handlerX): real x\r\n\t// +gameWorld.screenX: conversion to screen position\r\n\t// -gameWorld.xCamera: conversion to camera\r\n\tx=(int)((unit->x)-(myUnitFrame->handlerX)+\r\n\t\tgameWorld.screenX-(gameWorld.xCamera));\r\n\ty=(int)((unit->y)-(myUnitFrame->handlerY)+\r\n\t\tgameWorld.screenY-(gameWorld.yCamera));\r\n\r\n\t// Check if we have to draw the bounding rectangles...\r\n\tif (drawBoundingRectangles){\r\n\t\t// Let us draw the bounding rectangle of this unit\r\n\t\t// Calculate the coordinates...\r\n\t\tcx=x+myUnitFrame->cX;\r\n\t\tcy=y+myUnitFrame->cY;\r\n\r\n\t\t// draw the bounding rectangle, only if its size is bigger than\r\n\t\t// zero\r\n\t\tif (myUnitFrame->cW>0 && myUnitFrame->cH>0){\r\n\t\t\tgameWorld.srfGameScreen->fillRect(\r\n\t\t\t\t0, 0, 0,// color to use\r\n\t\t\t\tcx, cy,// dest coordinates\r\n\t\t\t\tmyUnitFrame->cW,// size\r\n\t\t\t\tmyUnitFrame->cH);\r\n\t\t}// if\r\n\t}// if drawBoundingRectangles\r\n\r\n\t// if the surface is in untouchable mode, make it tremble, but\r\n\t// only if the game isn't paused and if the user hasn't disabled\r\n\t// trembling from the console\r\n\tif (unit->trembling && !gameWorld.isGamePaused\r\n\t\t&& pixelsToTrembleWhenTrembling>0\r\n\t\t&& letSpritesTremble){\r\n\r\n\t\t// tremble!\r\n\t\t// (trembling is implemented only in the visualization)\r\n\t\tx=x-(pixelsToTrembleWhenTrembling/2)\r\n\t\t\t+rand()%(pixelsToTrembleWhenTrembling+1);\r\n\t\ty=y-(pixelsToTrembleWhenTrembling/2)\r\n\t\t\t+rand()%(pixelsToTrembleWhenTrembling+1);\r\n\t}// if\r\n\r\n\t// blt it!\r\n\tgameWorld.srfGameScreen->bltFrom(\r\n\t\t*(myUnitFrame->surface),\r\n\t\tx,// dest coordinates\r\n\t\ty,\r\n\t\tmyUnitFrame->x,// source coordinates\r\n\t\tmyUnitFrame->y,\r\n\t\tmyUnitFrame->w,\r\n\t\tmyUnitFrame->h,\r\n\t\tgameWorld.screenX, gameWorld.screenY,// clipping coordinates\r\n\t\tgameWorld.wCamera, gameWorld.hCamera,\r\n\t\tdbgClipSprites,// only stop clipping it if that debug mode is enabled\r\n\t\ttrue);\r\n\r\n\t// draw the 'going to' lines if needed\r\n\tif (drawGoingToLines){\r\n\t\tif (unit->goingToPoint){\r\n\t\t\t// some mini local variables\r\n\t\t\tint x, y;\r\n\t\t\tint x2, y2;\r\n\r\n\t\t\t// calculate the coordinates\r\n\t\t\tx=int(unit->x+gameWorld.screenX-(gameWorld.xCamera));\r\n\t\t\ty=int(unit->y+gameWorld.screenY-(gameWorld.yCamera));\r\n\t\t\tx2=int(unit->goingToPointX+\r\n\t\t\t\tgameWorld.screenX-(gameWorld.xCamera));\r\n\t\t\ty2=int(unit->goingToPointY+\r\n\t\t\t\tgameWorld.screenY-(gameWorld.yCamera));\r\n\t\t\tif (unit->isPosRelative){\r\n\t\t\t\tx2=int(unit->goingToPointX+gameWorld.screenX);\r\n\t\t\t\ty2=int(unit->goingToPointY+gameWorld.screenY);\r\n\t\t\t}// if\r\n\r\n\t\t\t// draw it\r\n\t\t\tgameWorld.srfGameScreen->drawLine(\r\n\t\t\t\tx, y,// 'from' coordinates\r\n\t\t\t\tx2, y2,// 'to' coordinates\r\n\t\t\t\t255,0, 0);// color\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// FOLLOWERS_TEST_BEGIN\r\n\t// draw the 'following' lines if needed\r\n\tif (drawFollowingLines){\r\n\t\tif (unit->objectType==FILE_GAMEDATA_GAMEOBJECT_ENEMY){\r\n\t\t\tenemyUnitStruct* unit1;\r\n\t\t\tenemyUnitStruct* unit2;\r\n\t\t\tint x, y;\r\n\t\t\tint x2, y2;\r\n\r\n\t\t\tswitch (unit->unitType){\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\t\t\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\t\t\tunit1=(enemyUnitStruct*)unit;\r\n\r\n\t\t\t\tif (unit1->aiSpecific.flockerData.unitToFollow.objectType\r\n\t\t\t\t\t!=FILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t\t\t\t// get the other unit...\r\n\t\t\t\t\tunit2=(enemyUnitStruct*)getUnitPointer(\r\n\t\t\t\t\t\tunit1->aiSpecific.flockerData.unitToFollow);\r\n\r\n\t\t\t\t\t// check for null pointers...\r\n\t\t\t\t\tif (unit2!=NULL){\r\n\t\t\t\t\t\t// some mini local variables\r\n\t\t\t\t\t\t// calculate the coordinates\r\n\t\t\t\t\t\tx=int(unit1->x+gameWorld.screenX-(gameWorld.xCamera));\r\n\t\t\t\t\t\ty=int(unit1->y+gameWorld.screenY-(gameWorld.yCamera));\r\n\t\t\t\t\t\tx2=int(unit2->x+gameWorld.screenX-(gameWorld.xCamera));\r\n\t\t\t\t\t\ty2=int(unit2->y+gameWorld.screenY-(gameWorld.yCamera));\r\n\r\n\t\t\t\t\t\t// draw it\r\n\t\t\t\t\t\tgameWorld.srfGameScreen->drawLine(\r\n\t\t\t\t\t\t\tx, y,// 'from' coordinates\r\n\t\t\t\t\t\t\tx2, y2,// 'to' coordinates\r\n\t\t\t\t\t\t\t0,0,255);// color\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\t\t}// if\r\n\t}// if\r\n\t// FOLLOWERS_TEST_END\r\n\r\n\t// draw the handler points if needed\r\n\tif (drawHandlerPoints){\r\n\t\t// some mini local variables\r\n\t\tint x, y;\r\n\t\tx=int(unit->x+gameWorld.screenX-(gameWorld.xCamera));\r\n\t\ty=int(unit->y+gameWorld.screenY-(gameWorld.yCamera));\r\n\r\n\t\t// draw the handler points if needed (as a red box with a\r\n\t\t// white pixel inside, marking the handler)\r\n\t\tgameWorld.srfGameScreen->fillRect(255,0,0,\r\n\t\t\tx-1, y-1, 3, 3);\r\n\t\tgameWorld.srfGameScreen->fillRect(255,255,255,\r\n\t\t\tx, y, 1, 1);\r\n\t}// if\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// drawUnit\r\n\r\n// ****************************\r\n// MAIN FUNCTIONS\r\n// Addressed as GameLoopCode::*\r\n// ****************************\r\n\r\n// drawFrame *************\r\n// Draw the current frame on screen.\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool GameLoopCode::drawFrame()\r\n{\r\n\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\tvectorListNodeStruct<enemyUnitStruct>* node;\r\n\tvectorListNodeStruct<bulletUnitStruct>* nodeB;\r\n\tvectorListNodeStruct<waveGenUnitStruct>* nodeWG;\r\n\tint x, y;\r\n\r\n\t// Draw the background\r\n\tif (!drawBackground()){\r\n\t\tlogger.logLine(\"Failed drawBackground\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Blt the bullets on screen...\r\n\tfor (nodeB=bulletList.getFirstNode(); nodeB!=NULL; nodeB=bulletList.getNextNode(nodeB)){\r\n\t\t// don't draw this unit if it's not active now\r\n\t\tif (!nodeB->data.nowActive) continue;\r\n\t\t// don't draw this utit if it's not visible now\r\n\t\tif (!nodeB->data.nowDrawable) continue;\r\n\r\n\t\t// draw this unit...\r\n\t\tdrawUnit(&(nodeB->data));\r\n\t}// for\r\n\r\n\t// Blt the enemies on screen...\r\n\tfor (node=enemyList.getFirstNode(); node!=NULL; node=enemyList.getNextNode(node)){\r\n\t\t// don't draw this unit if it's not active now\r\n\t\tif (!node->data.nowActive) continue;\r\n\t\t// don't draw this utit if it's not visible now\r\n\t\tif (!node->data.nowDrawable) continue;\r\n\r\n\t\t// draw this unit...\r\n\t\tdrawUnit(&(node->data));\r\n\t}// for\r\n\r\n\t// Blt the players on screen...\r\n\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t// don't draw this unit if it's not active now\r\n\t\tif (!nodeP->data.nowActive) continue;\r\n\t\t// don't draw this utit if it's not visible now\r\n\t\tif (!nodeP->data.nowDrawable) continue;\r\n\r\n\t\t// draw this unit...\r\n\t\tdrawUnit(&(nodeP->data));\r\n\t}// for\r\n\r\n\t// Now, over anything else, blt the wave generators on screen...\r\n\t// But only draw them if required\r\n\tif (drawWaveGenerators){\r\n\t\tfor (nodeWG=waveGenList.getFirstNode(); nodeWG!=NULL; nodeWG=waveGenList.getNextNode(nodeWG)){\r\n\t\t\t// don't draw this unit if it's not active now\r\n\t\t\tif (!nodeWG->data.nowActive) continue;\r\n\t\t\t// don't draw this utit if it's not visible now\r\n\t\t\tif (!nodeWG->data.nowDrawable) continue;\r\n\r\n\t\t\t// draw this unit...\r\n\t\t\tdrawUnit(&(nodeWG->data));\r\n\t\t}// for\r\n\t}// if\r\n\r\n\t// Now draw the foreground complementary information\r\n\tif (!drawForegroundComplements())\r\n\t\treturn false;\r\n\r\n\t// zoom if necessary\r\n\tif (gameWorld.zoomed){\r\n\t\tx=int(double(DD.getWidth())/gameWorld.zoomBy);// zoom width\r\n\t\ty=int(double(DD.getHeight())/gameWorld.zoomBy);// zoom height\r\n\r\n\t\t// let's zoom\r\n\t\tDD.stretchBltFrom(DD, 0, 0, DD.getWidth(), DD.getHeight(),\r\n\t\t\tgameWorld.zoomCX-(x/2), gameWorld.zoomCY-(y/2),\r\n\t\t\tx, y, false, false, false);\r\n\t}// if\r\n\r\n\t// If gameWorld.srfGameScreen wasn't DD, here we should blt\r\n\t// srfGameScreen to DD...\r\n\r\n\treturn true;// all ok\r\n}// drawFrame\r\n\r\n// executeFrame ***********\r\n// Execute a frame, without drawing it on screen. It's what I call\r\n// \"virtual frames\".\r\n// Only return false for non-recover errors.\r\nbool GameLoopCode::executeFrame(DWORD frameNumber)\r\n{\r\n\tint i;// for some small loops\r\n\tvectorListNodeStruct<playerUnitStruct> *unit;// for checking how many players are on screen\r\n\r\n\t// ANY PLAYERS?\r\n\t// Count the active players\r\n\tfor (unit=playerList.getFirstNode(), i=0; unit!=NULL; unit=playerList.getNextNode(unit)){\r\n\t\tif (!unit->data.nowActive) continue;// don't count inactive units\r\n\t\ti++;\r\n\t}// for\r\n\t// If there is no players alive, and the game isn't finishing right\r\n\t// now, start finishing it now\r\n\tif (i<=0 && gameWorld.gameFinishedTimeLeft==-1){\r\n\t\t// start finishing the game\r\n\t\tgameWorld.gameFinishedTimeLeft=gameWorld.maxGameFinishedTimeLeft;\r\n\t}// if\r\n\r\n/*\t// end the game if the escape key was pressed, or if the\r\n\t// time for finishing the game is zero (so meaning the game has to\r\n\t// end now)\r\n\tif (KEYEVENTDOWN(keyboard.keys, keyboard.latestKeys, DIK_ESCAPE)\r\n\t\t|| gameWorld.gameFinishedTimeLeft==0){\r\n\t\t// that's the end, go to the intro\r\n\t\tif (!switchToProgramZone(pgzon_gameMenues, 0, 0, true))\r\n\t\t\treturn false;\r\n\t}// if\r\n\r\n\t// check for the pause key...\r\n\tif (KEYEVENTDOWN(keyboard.keys, keyboard.latestKeys, DIK_P)){\r\n\t\t// switch the pause mode, only if console isn't open\r\n\t\tif (!showConsole)\r\n\t\t\tgameWorld.isGamePaused=!gameWorld.isGamePaused;\r\n\t}// if\r\n*/\r\n\t// check for pause mode... if we are in that mode, there is\r\n\t// nothing to do here\r\n\tif (gameWorld.isGamePaused)\r\n\t\treturn true;// all ok\r\n\r\n\t// increment our internal frame number counter\r\n\tnonPausedFrameNumber++;\r\n\r\n\t// move the camera at first\r\n\tif (!moveCamera()){\r\n\t\tlogger.logLine(\"Failed moveCamera\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// do the management of automatic stage advancement\r\n\tif (!manageAutomaticStaging(frameNumber)){\r\n\t\tlogger.logLine(\"Failed doing the automatic staging\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Game finish count down (or game over management)\r\n\tif (gameWorld.gameFinishedTimeLeft>0)\r\n\t\tgameWorld.gameFinishedTimeLeft--;\r\n\r\n\t// Move all the bullet units on the game world\r\n\t// It _has_ to be done before anything else is moved, so\r\n\t// spawned bullets don't move the first time.\r\n\tif (!moveBullets(frameNumber)){\r\n\t\tlogger.logLine(\"Failed moveBullets\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Now use the keyboard input for managing the player...\r\n\tif (!movePlayers(keyboard.keys)){\r\n\t\tlogger.logLine(\"Failed movePlayers\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Start the frame managing the enemy waves (that is, the addition\r\n\t// of new groups of enemies).\r\n\tif (!executeEnemyWaves(frameNumber)){\r\n\t\tlogger.logLine(\"Failed executeEnemyWaves\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Execute the enemy AI of all the units on the game world\r\n\tif (!executeEnemyAI(frameNumber)){\r\n\t\tlogger.logLine(\"Failed executeEnemyAI\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Now go check the collisions between the game objects...\r\n\tif (!checkCollisions()){\r\n\t\tlogger.logLine(\"Failed checkCollisions\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// executeFrame\r\n\r\n// beforeLoop **********\r\n// This is the code to be executed every time a program zone linked to\r\n// these functions is switched to.\r\nbool GameLoopCode::beforeLoop()\r\n{\r\n\t// set our internal frame counter to zero\r\n\tnonPausedFrameNumber=0;\r\n\r\n\t// initialize all for starting the game...\r\n\tif (!gameWorld.initializeGame(0))\r\n\t\treturn false;\r\n\r\n\treturn true;// all ok\r\n}// beforeLoop\r\n\r\n\r\n// afterLoop ***********\r\n// This is the code to be executed every time it's time to switch to\r\n// another program zone, being a program zone currently linked to\r\n// these functions.\r\nbool GameLoopCode::afterLoop()\r\n{\r\n/*\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\thighScoreStruct* highScore;\r\n\r\n\t// let's log the results...\r\n\tlogger.logLine(\"Maximum enemies on screen: %i\", true, true, true,\r\n\t\tenemyList.getMaxNodesUntilNow());\r\n\tlogger.logLine(\"Maximum players on screen: %i\", true, true, true,\r\n\t\tplayerList.getMaxNodesUntilNow());\r\n\tlogger.logLine(\"Maximum bullets on screen: %i\", true, true, true,\r\n\t\tbulletList.getMaxNodesUntilNow());\r\n\r\n\t// log the statistics\r\n\tlogger.logLine(\"Score in hits: %i\", true, true, true,\r\n\t\tgameWorld.scoreInHits);\r\n\tlogger.logLine(\"Score in free black sheeps: %i\", true, true, true,\r\n\t\tgameWorld.scoreInFreeBlackSheeps);\r\n\tlogger.logLine(\"Score in free white sheeps: %i\", true, true, true,\r\n\t\tgameWorld.scoreInFreeWhiteSheeps);\r\n\tlogger.logLine(\"Score in free heads: %i\", true, true, true,\r\n\t\tgameWorld.scoreInFreeHeads);\r\n\r\n\t// Do what's needed with every player\r\n\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t// log the score\r\n\t\tlogger.logLine(\"Player %i- Score : %i Energy: %i\",\r\n\t\t\ttrue, true, true,\r\n\t\t\tplayerList.getIndex(nodeP)+1,// player number\r\n\t\t\tint(nodeP->data.score),// score\r\n\t\t\tint(nodeP->data.energyLeft));// energy\r\n\r\n\t\t// if needed, add the score to the list of high scores\r\n\t\thighScore=\r\n\t\t\toptionsFileObject.highScoresOneManager->getLastNodeHSF();\r\n\t\tif (highScore==NULL){\r\n\t\t\t// error!\r\n\t\t\tlogger.logLine(\r\n\t\t\t\t\"Error in highScores.getLast\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t\tif (nodeP->data.score>=highScore->score){\r\n\t\t\t// the player will have to type his name now\r\n\t\t\tisCurrentlyTypingNameHS=true;// tells whether the player is currently typing his name for the high score list or not\r\n\t\t\thighScoreToTypeIn=highScore;// pointer to the node in the high scores list where to type in\r\n\r\n\t\t\t// update the list!\r\n\t\t\tstrcpy(highScore->name, \"_\");\r\n\t\t\thighScore->score=int(nodeP->data.score);\r\n\t\t\tif (!optionsFileObject.save())\r\n\t\t\t\tlogger.logLine(\"Couldn't save high score to disk\");\r\n\t\t}// if\r\n\t}// for\r\n*/\r\n\t// close the current zone\r\n\tgameWorld.deinitializeGame();\r\n\r\n\treturn true;// all ok\r\n}// afterLoop\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"gamedata.h\"\r\n#include \"globals.h\"// for using the program objects\r\n#include \"resmanager.h\"// for using the functions which manage the resources and operate their loading and unloading\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"players.h\"// for managing the players\r\n#include \"wavegens.h\"// for managing the wave generators\r\n#include \"staging.h\"// for the management of stages, levels, and the switching between these\r\n/*#include \"soundman.h\"// for using the functions related to sound management*/\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n/*#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions*/\r\n\r\n// WORLDDATACLASS methods\r\n\r\n// This method sets all up to start playing in a zone.\r\nbool worldDataClass::initializeGame(int gameZoneNumber)\r\n{\r\n\tlogger.logLine(\"Initializing game world data\");\r\n\r\n\t// set the basic stuff up\r\n\tisGamePaused=false;// don't pause it yet\r\n\r\n\t// Stage & level counting\r\n\tcurrentStage=gmstg_emptyStage;// current stage, cyclic value\r\n\tcurrentLevel=0;// current level, there are two stages per level\r\n\ttimeLeftToNextStage=0;// time left (in virtual frames), when it's zero, it's time to advance to the next stageLevel\r\n\t// timeLeftToNextStage can be anything actually, as it's changed later\r\n\r\n\t// Restart the game object ids counter before creating new object\r\n\tnextGameObjectID=FILE_GAMEDATA_FIRST_ID;\r\n\r\n\t// before starting, stop all the playing sounds (belonging to other\r\n\t// program zones)\r\n/*\tif (!stopAllSoundResources()) return false;\r\n\r\n\t// Play the music for the game starting now\r\n\texecuteIngameMusic(0);*/\r\n\r\n\t// set the graphical stuff\r\n\tsrfGameScreen=&DD;\r\n\tsrfBg=getSurfaceByResourceName(\"srfClassicLevelBg\");\r\n\txCamera=0; yCamera=0;\r\n\tscreenX=0; screenY=0;\r\n\twCamera=scriptMan.getIntVariable(\"screenWidth\");\r\n\thCamera=scriptMan.getIntVariable(\"screenHeight\");\r\n\tbgOffX=0; bgOffY=0;// background offset...\r\n\r\n\t// set the speed camera and background stuff\r\n\txSpeedCamera=0;\r\n\tySpeedCamera=0;\r\n\tbgSpeedX=0; bgSpeedY=0;// speed of the background offset\r\n\r\n\t// Set the zoom related stuff\r\n\tzoomed=false;// tells whether we zoom the screen or not\r\n\tzoomBy=1;// tells the multiplier used for zooming\r\n\tzoomCX=0; zoomCY=0;// tells the coordinates where zooming is centered\r\n\r\n\t// Data for the game over\r\n\tmaxGameFinishedTimeLeft=int(1*double(desiredFramesPerSecond));// value to set gameFinishedTimeLeft every time the game is finished\r\n\tgameFinishedTimeLeft=-1;// time left (in virtual frames) before the game is supposed to finish, -1 for 'not finishing'\r\n\tshowGameOverMessage=false;// is time to show the game over message?\r\n\r\n\t// Data for statistics\r\n\tscoreInHits=0;// how much of the score was got from hits to stuff carriers and other stuff?\r\n\tscoreInFreeWhiteSheeps=0;// how much of the score was got from free white sheeps?\r\n\tscoreInFreeBlackSheeps=0;// how much of the score was got from free black sheeps?\r\n\tscoreInFreeHeads=0;// how much of the score was got from free heads?\r\n\r\n\t// Set other in-game data\r\n\tyGround=// distance from the top to the ground\r\n\t\tscriptMan.getIntVariable(\"yGround\");\r\n\tyGroundForPlayer=// max distance from the top to the feet of the player\r\n\t\tscriptMan.getIntVariable(\"yGroundForPlayer\");\r\n\r\n\t// Set the data for falling objects\r\n\tminXFallenWSheeps=// minimum x for falling white sheeps\r\n\t\tscriptMan.getIntVariable(\"minXFallenWSheeps\");\r\n\tmaxXFallenWSheeps=// maximum x for falling white sheeps\r\n\t\tscriptMan.getIntVariable(\"maxXFallenWSheeps\");\r\n\tminXFallenBSheeps=// minimum x for falling black sheeps\r\n\t\tscriptMan.getIntVariable(\"minXFallenBSheeps\");\r\n\tmaxXFallenBSheeps=// maximum x for falling white sheeps\r\n\t\tscriptMan.getIntVariable(\"maxXFallenBSheeps\");\r\n\tminXFallenHeads=// minimum x for falling heads\r\n\t\tscriptMan.getIntVariable(\"minXFallenHeads\");\r\n\tmaxXFallenHeads=// maximum x for falling heads\r\n\t\tscriptMan.getIntVariable(\"maxXFallenHeads\");\r\n\r\n\t// Set up the players...\r\n\tif (!createPlayerObjects()){\r\n\t\tdeinitializeGame();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Set up the wave generators...\r\n\tif (!createWaveGenObjects()){\r\n\t\tdeinitializeGame();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Reset enemies and other game objects\r\n\t// Enemies\r\n\tif (!enemyList.resetList()){\r\n\t\tdeinitializeGame();\r\n\t\treturn false;\r\n\t}// if\r\n\t// Bullets\r\n\tif (!bulletList.resetList()){\r\n\t\tdeinitializeGame();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// And now, start in the first stageLevel\r\n\tif (!advanceStage()){\r\n\t\tdeinitializeGame();\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// initializeGame\r\n\r\n// Deinitialize everything (less resources) which was initialized in\r\n// startGame.\r\nbool worldDataClass::deinitializeGame()\r\n{\r\n/*\t// musical stuff first\r\n\twaveFileClass* muswavIcyMusic;\r\n\t// load the sound data...\r\n\tmuswavIcyMusic=getWaveSoundByResourceName(\"muswavIcyMusic\");\r\n\tif (muswavIcyMusic==NULL){\r\n\t\tlogger.logLine(\"muswavIcyMusic couldn't be get for playing\");\r\n\t\t\treturn 0;\r\n\t}// if\r\n\t// stop the sounds\r\n\tmuswavIcyMusic->stop();\r\n*/\r\n\t// free the players data...\r\n\tdestroyPlayerObjects();\r\n\r\n\t// free the wave generators data...\r\n\tdestroyWaveGenObjects();\r\n\r\n\treturn true;// all ok\r\n}// deinitializeGame\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"globals.h\"// for using the program objects\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include \"resinfoman.h\"// for managing the information related with the use of resources, ie: animation scripts\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include <string.h>\r\n\r\n// THIS GAME ONLY DATA\r\n// Our game world data...\r\nworldDataClass gameWorld;\r\n\r\n// Our script manager object\r\nscriptManagerClass scriptMan;\r\n\r\n// Some variables for debugging...\r\nbool dbgClipSprites=true;// Tells whether sprites are clipped out of the game world or not\r\n\r\n// This variables tell what's going to be the next ID for an game\r\n// object unit (enemy, bullet, player objects, etc)...\r\nDWORD nextGameObjectID;\r\n\r\n// Variables used for options and high scores management\r\noptionsFileClass optionsFileObject;// object used for managing the game and program options\r\nbool isCurrentlyTypingNameHS=false;// tells whether the player is currently typing his name for the high score list or not\r\nhighScoreStruct* highScoreToTypeIn=NULL;// pointer to the node in the high scores list where to type in\r\n\r\n// Variables related to program modes, ie those switched from the\r\n// console.\r\n// Bounding rectangles utilities\r\nbool drawBoundingRectangles=false;// tells whether the collision rectangles of the different game units should be drawn\r\nbool letSpritesTremble=true;// tells whether the trembling field of the units will be taken into account when drawing\r\n// Wave generators utilities\r\nbool drawWaveGenerators=true;// tells whether we should draw the wave generators or not... in normal mode, they have to be drawn\r\n// Virtual walls utilities\r\nbool drawVirtualWalls=false;// tells whether we should draw the virtual walls or not, for debugging purposes\r\n// Falling limits utilities\r\nbool drawFallingLimits=false;// tells whether we should draw the limits for falling objets or not, for debugging purposes\r\n// Units drawing utilities\r\nbool drawGoingToLines=false;// tells whether we should draw the lines showing the going to trajectories of the units or not\r\nbool drawFollowingLines=false;// tells whether we should draw the lines showing the following to trajectories of the units or not\r\nbool drawHandlerPoints=false;// tells whether we should draw the handler points for each unit on the screen\r\n// Screen shooting utilities\r\nbool takeASingleScreenshot=false;// tells if it's time to take a screenshot now\r\nbool keepTakingScreenshots=false;// tells whether we are in video capture mode (continuous screenshooting) or not\r\n\r\n// The lists of objects used in the game\r\nvectorListClass<playerUnitStruct> playerList;// list of players\r\nvectorListClass<enemyUnitStruct> enemyList;// list of enemies\r\nvectorListClass<bulletUnitStruct> bulletList;// list of bullets\r\nvectorListClass<waveGenUnitStruct> waveGenList;// list of wave generators\r\n\r\n// Now, the resource objects list.\r\n// The resource objects list itself\r\n#ifdef PROGMODE_SCREENSHOTS_DEMO_YES// is this a screenshots demo or not?\r\nresObjectDataStruct resObjectsList[]={\r\n\t// BUFFERS\r\n\t// Resource: srfScreenSizedBuffer\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfScreenSizedBuffer\",// resname\r\n\t\t\tNULL,// filename, null for empty resource\r\n\t\t\tfalse,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t800, 600),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// FONTS\r\n\t// Resource: srfDahFont\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfDahFont\",// resname\r\n\t\t\t\"data/demogfx/dahfont.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 1,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfEdiaFont\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfEdiaFont\",// resname\r\n\t\t\t\"data/demogfx/ediafont.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 1,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// INTRO IMAGES\r\n\t// Resource: srfIntroTmgLogo\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfIntroTmgLogo\",// resname\r\n\t\t\t\"data/demogfx/introtmg.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfIntroTmgLogo2\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfIntroTmgLogo2\",// resname\r\n\t\t\t\"data/demogfx/introtmg2.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfIntroRediaLogo\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfIntroRediaLogo\",// resname\r\n\t\t\t\"data/demogfx/splash_def.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// MENU IMAGES\r\n\t// Resource: srfBackIntroButton\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfBackIntroButton\",// resname\r\n\t\t\t\"data/demogfx/backintrobut.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuBackground3\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuBackground3\",// resname\r\n\t\t\t\"data/demogfx/backinthree.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfBackIntroButton3\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfBackIntroButton3\",// resname\r\n\t\t\t\"data/demogfx/backintrobuthree.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// SCREENSHOT IMAGES\r\n\t// Resource: srfMenuScreenshot1\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuScreenshot1\",// resname\r\n\t\t\t\"data/demogfx/sshot1.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuScreenshot2\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuScreenshot2\",// resname\r\n\t\t\t\"data/demogfx/sshot2.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuScreenshot3\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuScreenshot3\",// resname\r\n\t\t\t\"data/demogfx/sshot3.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuScreenshot4\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuScreenshot4\",// resname\r\n\t\t\t\"data/demogfx/sshot4.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuScreenshot5\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuScreenshot5\",// resname\r\n\t\t\t\"data/demogfx/sshot5.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// MISCELLANEOUS IMAGES\r\n\t// Resource: srfCursorImage\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"cursorImage\",// resname\r\n\t\t\t\"data/demogfx/cursor.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t8, 16,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t}/*,\r\n\t// INTRO SOUNDS\r\n\t// Resource: sndWavIntroSnd\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndWavIntroSnd\",// resname\r\n\t\t\t\"data/demosnd/intro.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/intro.wav\",// filename\r\n\t\t\t\"data/demosnd/intro.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\r\n\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavIngame150\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavIngame150\",// resname\r\n\t\t\t\"data/demosnd/ingame150.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/ingame150.wav\",// filename\r\n\t\t\t\"data/demosnd/ingame150.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx1\",// resname\r\n\t\t\t\"data/demosnd/menufx1.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/menufx1.wav\",// filename\r\n\t\t\t\"data/demosnd/menufx1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx2\",// resname\r\n\t\t\t\"data/demosnd/menufx2.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/menufx2.wav\",// filename\r\n\t\t\t\"data/demosnd/menufx2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx3\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx3\",// resname\r\n\t\t\t\"data/demosnd/menufx3.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/menufx3.wav\",// filename\r\n\t\t\t\"data/demosnd/menufx3.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx4\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx4\",// resname\r\n\t\t\t\"data/demosnd/menufx4.ogg\",// ogg filename\r\n\t\t\t\"data/demosnd/menufx4.wav\",// filename\r\n\t\t\t\"data/demosnd/menufx4.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t}*/\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#else// that is, PROGMODE_SCREENSHOTS_DEMO_NO\r\n// ********************************************\r\n// ********************************************\r\n// ********************************************\r\n// ********************************************\r\nresObjectDataStruct resObjectsList[]={\r\n\t// BUFFERS\r\n\t// Resource: srfScreenSizedBuffer\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfScreenSizedBuffer\",// resname\r\n\t\t\tNULL,// filename, null for empty resource\r\n\t\t\tfalse,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t800, 600),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// FONTS\r\n\t// Resource: srfDahFont\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfDahFont\",// resname\r\n\t\t\t\"data/graphics/dahfont.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 1,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfEdiaFont\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfEdiaFont\",// resname\r\n\t\t\t\"data/graphics/ediafont.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 1,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// INTRO IMAGES\r\n\t// Resource: srfIntroTmgLogo\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfIntroTmgLogo\",// resname\r\n\t\t\t\"data/graphics/introtmg.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfIntroRediaLogo\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfIntroRediaLogo\",// resname\r\n\t\t\t\"data/graphics/splash_def.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// MENU IMAGES\r\n\t// Resource: srfMenuBackground\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuBackground\",// resname\r\n\t\t\t\"data/graphics/backintro.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfBackIntroButton\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfBackIntroButton\",// resname\r\n\t\t\t\"data/graphics/backintrobut.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuBackground2\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuBackground2\",// resname\r\n\t\t\t\"data/graphics/backintwo.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuBackground2\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuBackground2\",// resname\r\n\t\t\t\"data/graphics/backintwo.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuBackground3\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuBackground3\",// resname\r\n\t\t\t\"data/graphics/backinthree.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfBackIntroButton3\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfBackIntroButton3\",// resname\r\n\t\t\t\"data/graphics/backintrobuthree.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfMenuCreditsPhotos\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfMenuCreditsPhotos\",// resname\r\n\t\t\t\"data/graphics/imgcredits.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\ttrue,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// MISCELLANEOUS IMAGES\r\n\t// Resource: srfCursorImage\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"cursorImage\",// resname\r\n\t\t\t\"data/graphics/cursor.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t8, 16,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// INGAME GRAPHICS\r\n\t// Resource: srfClassicLevelBg\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfClassicLevelBg\",// resname\r\n\t\t\t\"data/graphics/background.img\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\tfalse,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfClassicLevelFg\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfClassicLevelFg\",// resname\r\n\t\t\t\"data/graphics/foreground.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// IMAGES OF UNITS OF ANY KIND FOR THE GAME\r\n\t// Resource: srfPlayerJAvatar\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfPlayerJAvatar\",// resname\r\n\t\t\t\"data/graphics/prot_def2.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 1,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfeneHeadCarrier\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfeneHeadCarrier\",// resname\r\n\t\t\t\"data/graphics/et2_def.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t59, 58,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfeneSheepCarrier\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfeneSheepCarrier\",// resname\r\n\r\n\t\t\t\"data/graphics/et1_def.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srffndHead -- friendly head\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srffndHead\",// resname\r\n\t\t\t\"data/graphics/cabeza_def.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srffndBlackSheep\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srffndBlackSheep\",// resname\r\n\t\t\t\"data/graphics/cuerpo3.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srffndWhiteSheep\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srffndWhiteSheep\",// resname\r\n\t\t\t\"data/graphics/oveja1.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t1, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t},\r\n\t// Resource: srfbulPlayerFlame\r\n\t{\r\n\t\t// resource\r\n\t\tnew graphicResourceClass(\r\n\t\t\t\"srfbulPlayerFlame\",// resname\r\n\t\t\t\"data/graphics/rope_def.png\",// filename, null for empty resource\r\n\t\t\ttrue,// automatic video or system memory deciding?\r\n\t\t\tfalse,// videomem\r\n\t\t\ttrue, NULL,// file or resource, resource type\r\n\t\t\tfalse,// bmp or pcx\r\n\t\t\ttrue,// is transparent\r\n\t\t\tfalse,// uses transparent color components?\r\n\t\t\t0, 0, 0,// transparent color RGB components\r\n\t\t\t0, 0,// transparent color coordinates\r\n\t\t\t0, 0),// size (w,h) for the image if empty (filename=NULL)\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\tfalse,\r\n\t\t// reallocate always?\r\n\t\ttrue\r\n\t}/*,\r\n\t// INTRO SOUNDS\r\n\t// Resource: sndWavIntroSnd\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndWavIntroSnd\",// resname\r\n\t\t\t\"data/sound/intro/intro.ogg\",// ogg filename\r\n\t\t\t\"data/sound/intro/intro.wav\",// filename\r\n\t\t\t\"data/sound/intro/intro.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameIntro, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// INGAME MUSIC\r\n\t// Resource: musWavIngame140\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavIngame140\",// resname\r\n\t\t\t\"data/sound/ingamemus/ingame140.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamemus/ingame140.wav\",// filename\r\n\t\t\t\"data/sound/ingamemus/ingame140.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavIngame150\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavIngame150\",// resname\r\n\t\t\t\"data/sound/ingamemus/ingame150.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamemus/ingame150.wav\",// filename\r\n\t\t\t\"data/sound/ingamemus/ingame150.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavIngameFull\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavIngameFull\",// resname\r\n\t\t\t\"data/sound/ingamemus/ingamefull.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamemus/ingamefull.wav\",// filename\r\n\t\t\t\"data/sound/ingamemus/ingamefull.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavIngameIntro\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavIngameIntro\",// resname\r\n\t\t\t\"data/sound/ingamemus/ingameintro.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamemus/ingameintro.wav\",// filename\r\n\t\t\t\"data/sound/ingamemus/ingameintro.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// MENU SOUNDS\r\n\t// Resource: musWavMenuMusic\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuMusic\",// resname\r\n\t\t\t\"data/sound/menu/menumus.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menumus.wav\",// filename\r\n\t\t\t\"data/sound/menu/menumus.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuMusicSpecial\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuMusicSpecial\",// resname\r\n\t\t\t\"data/sound/menu/menumus-special.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menumus-special.wav\",// filename\r\n\t\t\t\"data/sound/menu/menumus-special.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx1\",// resname\r\n\t\t\t\"data/sound/menu/menufx1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menufx1.wav\",// filename\r\n\t\t\t\"data/sound/menu/menufx1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx2\",// resname\r\n\t\t\t\"data/sound/menu/menufx2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menufx2.wav\",// filename\r\n\t\t\t\"data/sound/menu/menufx2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx3\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx3\",// resname\r\n\t\t\t\"data/sound/menu/menufx3.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menufx3.wav\",// filename\r\n\t\t\t\"data/sound/menu/menufx3.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: musWavMenuFx4\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"musWavMenuFx4\",// resname\r\n\t\t\t\"data/sound/menu/menufx4.ogg\",// ogg filename\r\n\t\t\t\"data/sound/menu/menufx4.wav\",// filename\r\n\t\t\t\"data/sound/menu/menufx4.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// INGAME SOUNDS\r\n\t// Resource: sndIngameAy1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameAy1\",// resname\r\n\t\t\t\"data/sound/ingamefx/ay1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/ay1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/ay1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameAy2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameAy2\",// resname\r\n\t\t\t\"data/sound/ingamefx/ay2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/ay2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/ay2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog1\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog2\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog3\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog3\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog3.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog3.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog3.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog4\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog4\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog4.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog4.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog4.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog5\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog5\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog5.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog5.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog5.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog6\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog6\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog6.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog6.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog6.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog7\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog7\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog7.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog7.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog7.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog8\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog8\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog8.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog8.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog8.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog9\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog9\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog9.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog9.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog9.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog10\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog10\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog10.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog10.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog10.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameDog11\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameDog11\",// resname\r\n\t\t\t\"data/sound/ingamefx/dog11.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/dog11.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/dog11.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameLaughing1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameLaughing1\",// resname\r\n\t\t\t\"data/sound/ingamefx/laughing1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/laughing1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/laughing1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameLaughing2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameLaughing2\",// resname\r\n\t\t\t\"data/sound/ingamefx/laughing2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/laughing2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/laughing2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameLaughing3\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameLaughing3\",// resname\r\n\t\t\t\"data/sound/ingamefx/laughing3.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/laughing3.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/laughing3.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameMonster1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameMonster1\",// resname\r\n\t\t\t\"data/sound/ingamefx/monster1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/monster1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/monster1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameMonster2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameMonster2\",// resname\r\n\t\t\t\"data/sound/ingamefx/monster2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/monster2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/monster2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameUy1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameUy1\",// resname\r\n\t\t\t\"data/sound/ingamefx/uy1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/uy1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/uy1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameUy2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameUy2\",// resname\r\n\t\t\t\"data/sound/ingamefx/uy2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/uy2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/uy2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep1\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep1\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep1.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep1.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep1.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep2\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep2\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep2.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep2.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep2.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep3\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep3\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep3.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep3.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep3.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep4\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep4\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep4.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep4.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep4.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep5\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep5\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep5.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep5.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep5.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep6\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep6\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep6.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep6.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep6.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t},\r\n\t// Resource: sndIngameSheep7\r\n\t{\r\n\t\t// resource\r\n\t\tnew waveResourceClass(\r\n\t\t\t\"sndIngameSheep7\",// resname\r\n\t\t\t\"data/sound/ingamefx/sheep7.ogg\",// ogg filename\r\n\t\t\t\"data/sound/ingamefx/sheep7.wav\",// filename\r\n\t\t\t\"data/sound/ingamefx/sheep7.tmp\",// temp filename\r\n\t\t\tFILE_AUDIOWRAP_WAVE_DEFER),// hard or soft?\r\n\t\t// used in zones, finishes with pgzon_invalidZone\r\n\t\t{pgzon_actualGameRunning, pgzon_gameMenues, pgzon_invalidZone},\r\n\t\t// is the resource necessary?\r\n\t\ttrue,\r\n\t\t// never deallocate?\r\n\t\ttrue,\r\n\t\t// reallocate always?\r\n\t\tfalse\r\n\t}*/\r\n};// resObjectsList\r\n\r\n#endif// resources for full game...\r\n\r\n// Size of the resource objects list\r\nint resObjectsListSize=sizeof(resObjectsList)/sizeof(resObjectDataStruct);\r\n\r\n\r\n// The font objects...\r\nbitmappedFixedFontClass fntDahFont;\r\nbitmappedFixedFontClass fntEdiaFont;\r\nbitmappedFixedFontClass fntEdiaBigFont;\r\n\r\n\r\n\r\n// FRAMELISTSLIST info\r\n// This is a list where each node is actually a pointer (with some\r\n// extra information) to a list of frames.\r\nframeListDataStruct frameListsList[]={\r\n\t{// frplJAvatar\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frplJAvatar\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frenWhiteSheep\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frenWhiteSheep\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frenBlackSheep\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frenBlackSheep\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frenHumanHead\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frenHumanHead\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frenSheepCarrier\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frenSheepCarrier\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frenHeadCarrier\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frenHeadCarrier\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frblPlayerFlame\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frblPlayerFlame\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frwgWhiteSheeps\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frwgWhiteSheeps\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frwgBlackSheeps\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frwgBlackSheeps\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frwgHumanHeads\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frwgHumanHeads\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// frwgSheepsOut\r\n\tNULL,// a pointer to the list of frames itself\r\n\t\"frwgSheepsOut\",// a name for such frame list\r\n\t-1// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t},\r\n\t{// empty node, delimiting the end of the list\r\n\tNULL,// a pointer to the list of frames itself\r\n\tNULL,// a name for such frame list\r\n\t0// an integer value telling the size of the list of frames, excluding the last 'null' node when it's present\r\n\t}\r\n};// frameListsList\r\n\r\n\r\n\r\n// PLAYERTYPE info\r\n// Here is stored the information about the way the different player\r\n// types have to behave and work.\r\ngenericUnitTypeDataStruct playerType[]={\r\n\t// FILE_GAMEDATA_PLAYER_EMPTY 0\r\n\t{FILE_GAMEDATA_PLAYER_EMPTY,// int playerType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// Here used to be FILE_GAMEDATA_PLAYER_CLASSICBROWNSHIP 1\r\n\t{1,// int playerType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_PLAYER_SMALLBROWNSHIP 2\r\n\t{2,// int playerType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_PLAYER_BLUESUIT 3\r\n\t{3,// int playerType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_PLAYER_JAVATAR 4\r\n\t{FILE_GAMEDATA_PLAYER_JAVATAR,// int playerType\r\n\t\"javatarNormal\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frplJAvatar\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0}// pixels to tremble when untouchable (an even value)\r\n};// playerType\r\n\r\n// ENEMYTYPE info\r\n// Here is stored the information about the way the different enemy\r\n// types have to behave and work.\r\ngenericUnitTypeDataStruct enemyType[]={\r\n\t// FILE_GAMEDATA_ENEMY_EMPTY 0\r\n\t{FILE_GAMEDATA_ENEMY_EMPTY,// int enemyType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// Here used to be FILE_GAMEDATA_ENEMY_SMALLGREENSHIP 1\r\n\t{1,// int enemyType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// Here used to be FILE_GAMEDATA_ENEMY_GREENOCTOPUS 2\r\n\t{2,// int enemyType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_ENEMY_WHITESHEEP 3\r\n\t{FILE_GAMEDATA_ENEMY_WHITESHEEP,// int enemyType\r\n\t\"whiteSheepCarried\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frenWhiteSheep\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_ENEMY_BLACKSHEEP 4\r\n\t{FILE_GAMEDATA_ENEMY_BLACKSHEEP,// int enemyType\r\n\t\"blackSheepCarried\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frenBlackSheep\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_ENEMY_HUMANHEAD 5\r\n\t{FILE_GAMEDATA_ENEMY_HUMANHEAD,// int enemyType\r\n\t\"humanHeadCarriedByHeadCarrier\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frenHumanHead\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_ENEMY_SHEEPCARRIER 6\r\n\t{FILE_GAMEDATA_ENEMY_SHEEPCARRIER,// int enemyType\r\n\t\"sheepCarrierNormal\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frenSheepCarrier\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_ENEMY_HEADCARRIER 7\r\n\t{FILE_GAMEDATA_ENEMY_HEADCARRIER,// int enemyType\r\n\t\"headCarrierNormal\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frenHeadCarrier\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0}// pixels to tremble when untouchable (an even value)\r\n};// enemyType\r\n\r\n// BULLETTYPE info\r\n// Here is stored the information about the way the different bullet\r\n// types have to behave and work.\r\ngenericUnitTypeDataStruct bulletType[]={\r\n\t// FILE_GAMEDATA_BULLET_EMPTY 0\r\n\t{FILE_GAMEDATA_BULLET_EMPTY,// int bulletType\r\n\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t2},// pixels to tremble when untouchable (an even value)\r\n\t// Here used to be the FILE_GAMEDATA_BULLET_CLASSICPLAYER 1\r\n\t{1,// int bulletType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// Here used to be the FILE_GAMEDATA_BULLET_CLASSICOCTOPUS 2\r\n\t{2,// int bulletType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_BULLET_PLAYERFLAME 3\r\n\t{FILE_GAMEDATA_BULLET_PLAYERFLAME,// int bulletType\r\n\t\"flameBulletAppearing\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frblPlayerFlame\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t2}// pixels to tremble when untouchable (an even value)\r\n};// bulletType\r\n\r\n// WAVEGENTYPE info\r\n// Here is stored the information about the way the different wave\r\n// generators types have to behave and work.\r\ngenericUnitTypeDataStruct waveGenType[]={\r\n\t// FILE_GAMEDATA_WAVEGEN_EMPTY 0\r\n\t{FILE_GAMEDATA_WAVEGEN_EMPTY,// int waveGenType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_WAVEGEN_WHITESHEEPS 1\r\n\t{FILE_GAMEDATA_WAVEGEN_WHITESHEEPS,// int waveGenType\r\n\t\"waveGenWSheepsStart\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frwgWhiteSheeps\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS 2\r\n\t{FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS,// int waveGenType\r\n\t\"waveGenBSheepsStart\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frwgBlackSheeps\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_WAVEGEN_HUMANHEADS 3\r\n\t{FILE_GAMEDATA_WAVEGEN_HUMANHEADS,// int waveGenType\r\n\t\"waveGenHeadsStart\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frwgHumanHeads\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_WAVEGEN_SHEEPSOUT 4\r\n\t{FILE_GAMEDATA_WAVEGEN_SHEEPSOUT,// int waveGenType\r\n\t\"waveGenSheepsOutStart\",// name of the first frame, for calculating it\r\n\t-1,// first frame, load later\r\n\t\"frwgSheepsOut\",// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0},// pixels to tremble when untouchable (an even value)\r\n\t// FILE_GAMEDATA_WAVEGEN_UNDEFINED 10\r\n\t{FILE_GAMEDATA_WAVEGEN_UNDEFINED,// int waveGenType\r\n\tNULL,// name of the first frame, for calculating it\r\n\t0,// first frame\r\n\tNULL,// the name of the vector which contains the frames info\r\n\tNULL,// pointer to the frames info\r\n\t0}// pixels to tremble when untouchable (an even value)\r\n};// waveGenType\r\n\r\n\r\n// SET-UP'ers\r\n// ==========\r\n\r\n// setupGameDataStructures ********\r\n// This function manages the initialization of all the data\r\n// structures that are going to be used in the execution of the\r\n// game.\r\nbool setupGameDataStructures()\r\n{\r\n\t// set the unit type data structures up\r\n\tgenericUnitTypeDataStruct* typeList;\r\n\tint i, j, siz;\r\n\r\n\t// first, set up the resources information...\r\n\tif (!initializeResInfo()){\r\n\t\tlogger.logLine(\"Failed when executing initializeResInfo\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// let's load the firstFrame information of every unit\r\n\t// type\r\n\tfor (i=0; i<4; i++){\r\n\t\t// we select a types list each time...\r\n\t\tswitch(i){\r\n\t\tcase 0:\r\n\t\t\tsiz=sizeof(playerType)/sizeof(genericUnitTypeDataStruct);\r\n\t\t\ttypeList=playerType;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tsiz=sizeof(enemyType)/sizeof(genericUnitTypeDataStruct);\r\n\t\t\ttypeList=enemyType;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tsiz=sizeof(bulletType)/sizeof(genericUnitTypeDataStruct);\r\n\t\t\ttypeList=bulletType;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tsiz=sizeof(waveGenType)/sizeof(genericUnitTypeDataStruct);\r\n\t\t\ttypeList=waveGenType;\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\r\n\t\tfor (j=0; j<siz; j++){\r\n\t\t\t// set the first frame...\r\n\t\t\ttypeList[j].firstFrame=\r\n\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\ttypeList[j].firstFrameName);\r\n\t\t\t// set the frames list for this unit type\r\n\t\t\tif (typeList[j].frameListName!=NULL){\r\n\t\t\t\tchar* flname=typeList[j].frameListName;\r\n\r\n\t\t\t\ttypeList[j].frames=\r\n\t\t\t\t\tgetFrameListNodeByName(flname)->frameList;\r\n\t\t\t}// if\r\n\t\t}// for\r\n\t}// for\r\n\r\n\t// Time to initialize the game stuff...\r\n\t// The list of players...\r\n\tif (!playerList.initialize(5)){\r\n\t\t// error\r\n\t\tcloseAll(\"playerList.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// The list of enemies...\r\n\tif (!enemyList.initialize(400)){\r\n\t\t// error\r\n\t\tcloseAll(\"enemyList.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// The list of bullets...\r\n\tif (!bulletList.initialize(400)){\r\n\t\t// error\r\n\t\tcloseAll(\"bulletList.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// The list of wave generators...\r\n\tif (!waveGenList.initialize(10)){\r\n\t\t// error\r\n\t\tcloseAll(\"waveGenList.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Create the virtual walls\r\n\tif (!initializeVirtualWalls()){\r\n\t\t// error\r\n\t\tcloseAll(\"virtualWalls.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Create the game and program options management object\r\n\tif (!optionsFileObject.init() ||\r\n\t\t!optionsFileObject.createFileIfNeeded() ||\r\n\t\t!optionsFileObject.load()){\r\n\t\t// error\r\n\t\tcloseAll(\"optionsFileObject.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// Set the current language from the options file\r\n\tcurrentLanguage=\r\n\t\toptionsFileObject.getOptionsPointer()->selectedLanguage;\r\n\t// set the current language in lua\r\n\tscriptMan.setCurrentLanguageInLua(currentLanguage);\r\n\t// set the current sound state in the program\r\n/*\tprogramSoundEnabled=\r\n\t\toptionsFileObject.getOptionsPointer()->programSoundEnabled;\r\n\t// set the current sound state in lua\r\n\tscriptMan.setSoundEnabledInLua(\r\n\t\tprogramSoundEnabled, programSoundActive);\r\n*/\r\n\t// Log the time of use to the date\r\n\tlogger.logLine(\r\n\t\t\"Use to the date: %u\",\r\n\t\ttrue, false, true,\r\n\t\toptionsFileObject.getOptionsPointer()->usedTimeSeconds);\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// setupGameDataStructures\r\n\r\n// Methods for setting up units... (these functions have to be used\r\n// when creating a new unit, before setting all its data).\r\n\r\n// setupGenericUnit sets the usual data of units up, only to be used\r\n// internally by other specific set-up'ers\r\nbool setupGenericUnit(genericUnitStruct& unit, int unitType)\r\n{\r\n\t// set it all up\r\n\r\n\t// type related stuff\r\n\tunit.unitType=unitType;\r\n\r\n\t// general stuff\r\n\t// assignate an identifier to this enemy\r\n\tunit.id=nextGameObjectID;\r\n\tnextGameObjectID++;\r\n\r\n\t// set other values to default... most of the times it will be\r\n\t// meaningless though\r\n\tunit.speedX=0; unit.speedY=0;\r\n\tunit.minSpeedX=0; unit.maxSpeedX=0;\r\n\tunit.minSpeedY=0; unit.maxSpeedY=0;\r\n\tunit.linearSpeed=0;// linear speed to be used always, by the unit (per virtual frame)\r\n\tunit.vFramesPassed=0;\r\n\tunit.x=0; unit.y=0;\r\n\r\n\t// Set the relative position stuff (relative to camera)\r\n\tunit.isPosRelative=false;// are xFromCamera and yFromCamera used for relative position?\r\n\tunit.xFromCamera=0; unit.yFromCamera=0;// relative position to camera\r\n\r\n\t// Set the data telling the way this unit behaves\r\n\tunit.energyToDrop=0;// energy this unit has to drop when touching any other unit\r\n\tunit.decrementableEnergy=true;// tells whether the unit energy can become smaller or not\r\n\r\n\t// Set the data telling the current unit state\r\n\tunit.nowActive=true;// tells if the unit is active and playing right now\r\n\r\n\tunit.nowDrawable=true;// tells if the unit should be drew or not (only affects the drawing of a unit, not collision neither anything else), that is, a visibility state\r\n\tunit.trembling=false;// tells if the unit is trembling right now\r\n\r\n\t// Set the slave related stuff\r\n\tunit.slaveOf.objectType=FILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\tunit.slaveUnit.objectType=FILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\tunit.slaveOf.id=FILE_GAMEDATA_WHATEVER_ID;\r\n\tunit.slaveUnit.id=FILE_GAMEDATA_WHATEVER_ID;\r\n\r\n\t// Data for unintelligent unit movement\r\n\tunit.goingToPoint=false;// should the ai keep following that point now?\r\n\tunit.goingToPointX=0;// point the unit is going to, if any\r\n\tunit.goingToPointY=0;\r\n\r\n\treturn true;// all ok\r\n}// setupGenericUnit\r\n\r\n// setupEnemyUnit sets an enemy unit up, by making all the values in the\r\n// struct be the default values for that enemy type...\r\nbool setupEnemyUnit(enemyUnitStruct& unit, int unitType)\r\n{\r\n\t// set it all up\r\n\r\n\t// some score values, all together\r\n\tconst int headCarrierScore=\r\n\t\tscriptMan.getIntVariable(\"headCarrierScore\");// head carrier hit\r\n\tconst int sheepCarrierScore=\r\n\t\tscriptMan.getIntVariable(\"sheepCarrierScore\");// sheep carrier hit\r\n\tconst int headScore=\r\n\t\tscriptMan.getIntVariable(\"headScore\");// head by itself\r\n\tconst int wSheepScore=\r\n\t\tscriptMan.getIntVariable(\"wSheepScore\");// sheep by itself\r\n\tconst int wSheepScoreWithHead=\r\n\t\tscriptMan.getIntVariable(\"wSheepScoreWithHead\");// sheep + head\r\n\tconst int bSheepScore=\r\n\t\tscriptMan.getIntVariable(\"bSheepScore\");// sheep by itself\r\n\tconst int bSheepScoreWithHead=\r\n\t\tscriptMan.getIntVariable(\"bSheepScoreWithHead\");// sheep + head\r\n\r\n\t// first set the generic stuff up\r\n\tif (!setupGenericUnit(unit, unitType)) return false;\r\n\r\n\t// type related stuff\r\n\tunit.currentFrame=enemyType[unitType].firstFrame;\r\n\r\n\t// general stuff\r\n\tunit.objectType=FILE_GAMEDATA_GAMEOBJECT_ENEMY;// what object type is, FILE_GAMEDATA_GAMEOBJECT_*\r\n\r\n\t// set x to be, by default, just a pixel inside the screen\r\n\tunit.x=gameWorld.xCamera+gameWorld.wCamera+\r\n\t\tenemyType[unit.unitType].frames[unit.currentFrame].handlerX-1;\r\n\r\n\t// Set the data telling the way this unit behaves\r\n\tunit.untouchableTimeMax=int(0.4*double(desiredFramesPerSecond));// maximum value for untouchableTimeLeft\r\n\tunit.unarmedTimeMax=int(0.4*double(desiredFramesPerSecond));// maximum value for unarmedTimeLeft\r\n\tunit.energyToDrop=8;// energy this unit has to drop when touching any other unit\r\n\t// Generally, units aren't supposed to be out of the screen ever\r\n\tunit.timeOutsideTheScreenMax=0;// maximum value for timeOutsideTheScreenLeft\r\n\r\n\t// Set the data telling the current unit state\r\n\tunit.untouchableTimeLeft=0;// for how much more time (in vframes) the unit will be untouchable\r\n\tunit.unarmedTimeLeft=0;// for how much more time (in vframes) the unit won't be able to shoot\r\n\tunit.timeOutsideTheScreenLeft=0;// for how much more time (in vframes) the unit will be able to be outside the screen without being removed\r\n\tunit.justGoingOut=false;// tells whether the unit is just going out to the screen, or it's been there from some time (usually affects the state of the collision variables)\r\n\r\n\t// Data for collision checking\r\n\tunit.canBeHitByPlayers=true;// tells whether players can collide with it or not\r\n\tunit.canBeHitByBullets=true;// tells whether bullets can collide with it or not\r\n\r\n\t// set the values which difer for every enemy type\r\n\tswitch (unitType){\r\n\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\t// let's give those a larger untouchable time...\r\n\t\tunit.untouchableTimeMax=int(0.7*double(desiredFramesPerSecond));// maximum value for untouchableTimeLeft\r\n\r\n\t\tunit.energyLeft=30;// energy left for this unit... 0 for dead\r\n\t\tunit.decrementableEnergy=false;// tells whether the unit energy can become smaller or not\r\n\t\tunit.scoreToGivePerHit=headCarrierScore;// how much score it gives per hit\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\t\t// let's give those a larger untouchable time...\r\n\t\tunit.untouchableTimeMax=int(0.7*double(desiredFramesPerSecond));// maximum value for untouchableTimeLeft\r\n\r\n\t\tunit.energyLeft=30;// energy left for this unit... 0 for dead\r\n\t\tunit.decrementableEnergy=false;// tells whether the unit energy can become smaller or not\r\n\t\tunit.scoreToGivePerHit=sheepCarrierScore;// how much score it gives per hit\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_BLACKSHEEP:\r\n\tcase FILE_GAMEDATA_ENEMY_WHITESHEEP:\r\n\tcase FILE_GAMEDATA_ENEMY_HUMANHEAD:\r\n\t\t// Data for collision checking\r\n\t\tunit.canBeHitByPlayers=false;// tells whether players can collide with it or not\r\n\t\tunit.canBeHitByBullets=false;// tells whether bullets can collide with it or not\r\n\r\n\t\t// some general data\r\n\t\tunit.energyLeft=50;// energy left for this unit... 0 for dead\r\n\t\tunit.decrementableEnergy=false;// tells whether the unit energy can become smaller or not\r\n\t\tunit.scoreToGivePerHit=0;// how much score it gives per hit\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// AI related stuff...\r\n\t// Flocking\r\n\tswitch (unitType){\r\n\tcase FILE_GAMEDATA_ENEMY_WHITESHEEP:\r\n\t\t// About current falling state\r\n\t\tunit.aiSpecific.sheepData.nowFalling=false;// tells whether the unit is currently falling or not\r\n\t\tunit.aiSpecific.sheepData.nowJumpingForHigh=false;// tells whether the unit is currently jumping up or not\r\n\r\n\t\t// About the way a unit should jump\r\n\t\tunit.aiSpecific.sheepData.jumpHDistance=40;// horizontal distance in pixels, for the jumps\r\n\t\tunit.aiSpecific.sheepData.maxVarianceHD=5;// maximum variance in pixels for the horizontal jumping distance.. the maximum jump will be jumpHDistance+maxVarianceHD\r\n\t\tunit.aiSpecific.sheepData.jumpVDistance=20;// vertical distance in pixels, for the jumps\r\n\r\n\t\t// About score when freed\r\n\t\tunit.aiSpecific.sheepData.sheepScoreToGiveWhenFreed=\r\n\t\t\twSheepScore;\r\n\t\tunit.aiSpecific.sheepData.sheepScoreToGiveWhenFreedWithAHead=\r\n\t\t\twSheepScoreWithHead;\r\n\r\n\t\t// Some information about the way it falls\r\n\t\tunit.aiSpecific.sheepData.sheepSpeedWhenFalling=0;// linear speed the unit has when it falls\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_BLACKSHEEP:\r\n\t\t// About current falling state\r\n\t\tunit.aiSpecific.sheepData.nowFalling=false;// tells whether the unit is currently falling or not\r\n\t\tunit.aiSpecific.sheepData.nowJumpingForHigh=false;// tells whether the unit is currently jumping up or not\r\n\r\n\t\t// About the way a unit should jump\r\n\t\tunit.aiSpecific.sheepData.jumpHDistance=40;// horizontal distance in pixels, for the jumps\r\n\t\tunit.aiSpecific.sheepData.maxVarianceHD=5;// maximum variance in pixels for the horizontal jumping distance.. the maximum jump will be jumpHDistance+maxVarianceHD\r\n\t\tunit.aiSpecific.sheepData.jumpVDistance=20;// vertical distance in pixels, for the jumps\r\n\r\n\t\t// About score when freed\r\n\t\tunit.aiSpecific.sheepData.sheepScoreToGiveWhenFreed=\r\n\t\t\tbSheepScore;\r\n\t\tunit.aiSpecific.sheepData.sheepScoreToGiveWhenFreedWithAHead=\r\n\t\t\tbSheepScoreWithHead;\r\n\r\n\t\t// Some information about the way it falls\r\n\t\tunit.aiSpecific.sheepData.sheepSpeedWhenFalling=0;// linear speed the unit has when it falls\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_HUMANHEAD:\r\n\t\t// About current falling state\r\n\t\tunit.aiSpecific.headData.fallingHead=false;// tells whether the unit is currently falling or not\r\n\r\n\t\t// About score when freed\r\n\t\tunit.aiSpecific.headData.headScoreToGiveWhenFreed=headScore;\r\n\r\n\t\t// Some information about the way it falls\r\n\t\tunit.aiSpecific.headData.headSpeedWhenFalling=0;// linear speed the unit has when it falls\r\n\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_ENEMY_SHEEPCARRIER:\r\n\tcase FILE_GAMEDATA_ENEMY_HEADCARRIER:\r\n\t\t// For having followers and pursued units\r\n\t\t// Enemy unit this unit will have to follow (none in this case)\r\n\t\tunit.aiSpecific.flockerData.unitToFollow.objectType=\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\t\tunit.aiSpecific.flockerData.unitToFollow.id=\r\n\t\t\tFILE_GAMEDATA_WHATEVER_ID;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\treturn true;// all ok\r\n}// setupEnemyUnit\r\n\r\n// setupPlayerUnit sets an player unit up, by making all the values in the\r\n// struct be the default values for that player type...\r\nbool setupPlayerUnit(playerUnitStruct& unit, int unitType)\r\n{\r\n\t// set it all up\r\n\r\n\t// first set the generic stuff up\r\n\tif (!setupGenericUnit(unit, unitType)) return false;\r\n\r\n\r\n\t// type related stuff\r\n\tunit.currentFrame=playerType[unitType].firstFrame;\r\n\r\n\t// general stuff\r\n\tunit.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;// what object type is, FILE_GAMEDATA_GAMEOBJECT_*\r\n\r\n\t// set the keys to default...\r\n\tunit.userControlled=true;\r\n/*\tunit.keyUp=DIK_UP;\r\n\tunit.keyDown=DIK_DOWN;\r\n\tunit.keyLeft=DIK_LEFT;\r\n\tunit.keyRight=DIK_RIGHT;\r\n\tunit.keyShoot=DIK_LCONTROL;\r\n*/\r\n\t// Set the relative position stuff (relative to camera)\r\n\tunit.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\tunit.xFromCamera=60; unit.yFromCamera=210;// relative position to camera\r\n\r\n\t// set the coordinates to be equal to *FromCamera\r\n\tunit.x=unit.xFromCamera;\r\n\tunit.y=unit.yFromCamera;\r\n\r\n\t// Set the data telling the way this unit behaves\r\n\tunit.untouchableTimeMax=int(0.6*double(desiredFramesPerSecond));// maximum value for untouchableTimeLeft\r\n\tunit.energyToDrop=10;// energy this unit has to drop when touching any other unit\r\n\tunit.scoreToGivePerHit=20;// how much score it gives per hit\r\n\tunit.canBeHitByPlayers=true;// tells whether players can hurt it or not\r\n\tunit.playerUseAllKeyboard=false;// if it's set, we can use special key codes for making many keys do for the same function\r\n\r\n\t// We don't care about it now... we use events for ending the\r\n\t// unarmed thing\r\n\tunit.unarmedTimeMax=int(0.8*double(desiredFramesPerSecond));// maximum value for unarmedTimeLeft\r\n\r\n\t// Set the data telling the current unit state\r\n\tunit.nowEnteringGame=true;// tells whether the player is now entering the game area or not\r\n\tunit.energyLeft=100;// energy left for this unit... 0 for dead\r\n\tunit.untouchableTimeLeft=0;// for how much more time (in vframes) the unit will be untouchable\r\n\tunit.unarmedTimeLeft=0;// for how much more time (in vframes) the unit won't be able to shoot\r\n\tunit.score=0;// current score this unit has...\r\n\r\n\treturn true;// all ok\r\n}// setupPlayerUnit\r\n\r\n// setupBulletUnit sets a bullet unit up, by making all the values in the\r\n// struct be the default values for that bullet type...\r\nbool setupBulletUnit(bulletUnitStruct& unit, int unitType)\r\n{\r\n\t// set it all up\r\n\r\n\t// first set the generic stuff up\r\n\tif (!setupGenericUnit(unit, unitType)) return false;\r\n\r\n\t// type related stuff\r\n\tunit.currentFrame=bulletType[unitType].firstFrame;\r\n\r\n\t// general stuff\r\n\tunit.objectType=FILE_GAMEDATA_GAMEOBJECT_BULLET;// what object type is, FILE_GAMEDATA_GAMEOBJECT_*\r\n\r\n\t// Set the variables which tell what kind of units a given bullet\r\n\t// may hit\r\n\tunit.canCollideWithPlayers=false;// can this bullet unit collide with players?\r\n\tunit.canCollideWithEnemies=false;// can this bullet unit collide with enemies?\r\n\tunit.canCollideWithBullets=false;// can this bullet unit collide with other bullets?\r\n\tunit.canCollideWithTheOwner=false;// can this bullet unit collide with its owner?\r\n\r\n\t// Set the data telling the way this unit behaves\r\n\tunit.energyToDrop=10;// energy this unit has to drop when touching any other unit\r\n\t// Generally, units aren't supposed to be out of the screen ever\r\n\tunit.timeOutsideTheScreenMax=0;// maximum value for timeOutsideTheScreenLeft\r\n\r\n\t// Set the data telling the current unit state\r\n\tunit.timeOutsideTheScreenLeft=0;// for how much more time (in vframes) the unit will be able to be outside the screen without being removed\r\n\tunit.nowExploding=false;// tells whether this bullet is exploding or not\r\n\t// Zero all the owner stuff\r\n\t// this tells which unit dropped the bullet\r\n\tunit.owner.listIndex=0;\r\n\tunit.owner.objectType=FILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\tunit.owner.id=FILE_GAMEDATA_WHATEVER_ID;\r\n\r\n\t// set the values which difer for every bullet type\r\n\tswitch (unitType){\r\n\tcase FILE_GAMEDATA_BULLET_PLAYERFLAME:\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\treturn true;// all ok\r\n}// setupBulletUnit\r\n\r\n\r\n// setupWaveGenUnit sets a wave gen unit up, by making all the\r\n// values in the struct be the default values for that wave gen type...\r\nbool setupWaveGenUnit(waveGenUnitStruct& unit, int unitType)\r\n{\r\n\t// set it all up\r\n\r\n\t// first set the generic stuff up\r\n\tif (!setupGenericUnit(unit, unitType)) return false;\r\n\r\n\t// type related stuff\r\n\tunit.currentFrame=waveGenType[unitType].firstFrame;\r\n\r\n\t// general stuff\r\n\tunit.objectType=FILE_GAMEDATA_GAMEOBJECT_WAVEGENERATOR;// what object type is, FILE_GAMEDATA_GAMEOBJECT_*\r\n\r\n\t// More specific stuff\r\n\t// it's not generating units by default\r\n\tunit.generatingNow=false;\r\n\r\n\t// Enemy wave generation related stuff\r\n\t// This nextEnemyWaveX simulates the wave coming from the right,\r\n\t// so that every time it gets inside the screen, it's executed.\r\n\tunit.distanceBetweenWaves=1;// what's the distance which separates an enemy wave form another\r\n\tunit.virtualEnemyWavesSpeedX=1/double(desiredFramesPerSecond);\r\n\tunit.nextEnemyWaveX=gameWorld.xCamera+gameWorld.wCamera;// this tells where that virtual enemy wave object is.\r\n\t// If virtualEnemyWavesSpeedX is set that way, distance between\r\n\t// waves has to be the number of seconds (or fraction of seconds)\r\n\t// has to pass between one wave and the next one.\r\n\r\n\treturn true;// all ok\r\n}// setupWaveGenUnit\r\n\r\n\r\n// FRAME LIST MANAGEMENT methods\r\n// =============================\r\n\r\n\r\n// getFrameListIndexByName ******\r\n// Given a frame list name, this function returns the index of such\r\n// frame list in the frameListsList list, or -1 for error\r\nint getFrameListIndexByName(char* frameListName)\r\n{\r\n\tframeListDataStruct* flist;\r\n\r\n\tflist=frameListsList;\r\n\r\n\t// let's traverse the entire lists' list for such a name...\r\n\tfor(;!(flist->frameList==NULL && flist->listName==NULL); flist++){\r\n\t\tif (strcmp(flist->listName, frameListName)==0)\r\n\t\t\treturn flist-frameListsList;// found\r\n\t}// for\r\n\r\n\t// not found, return an error code\r\n\treturn -1;\r\n}// getFrameListIndexByName\r\n\r\n// getFrameListNodeByName ******\r\n// Given a frame list name, this function returns the corresponding\r\n// node of such frame list in the frameListsList list.\r\nframeListDataStruct* getFrameListNodeByName(char* frameListName)\r\n{\r\n\tint listIdx;\r\n\r\n\tlistIdx=getFrameListIndexByName(frameListName);\r\n\r\n\treturn (listIdx==-1?NULL:&(frameListsList[listIdx]));\r\n}// getFrameListNodeByName\r\n\r\n// getFramesCount ********\r\n// Given a frame list name, this function returns the amount of\r\n// different frame nodes that are present in such list, excluding\r\n// the last null node when it's present, or -1 for error\r\nint getFramesCount(char* frameListName)\r\n{\r\n\tframeListDataStruct* list;\r\n\r\n\tlist=getFrameListNodeByName(frameListName);\r\n\tif (list==NULL) return -1;// error, the list doesn't exist\r\n\t\r\n\treturn getFramesCount(list->frameList);\r\n}// getFramesCount\r\n\r\n// getFramesCount *****************\r\n// Obtain a number telling the amount of frames a frames list has.\r\nint getFramesCount(\r\n\tframeDataStruct* framesList)// enemy unit to obtain the current frame from\r\n{\r\n\tframeDataStruct* thisFrame;\r\n\r\n\t// traverse the list until finding the latest node, marked by\r\n\t// a NULL in the surface field\r\n\tfor (thisFrame=framesList; thisFrame->surface!=NULL; thisFrame++);\r\n\r\n\treturn thisFrame-framesList;\r\n}// getFramesCount\r\n\r\n// getFrameIndexByName *******\r\n// Given a frame list name, and the name of a specific frame, this\r\n// function returns the index of such frame in that specific frame\r\n// list, or -1 for error\r\nint getFrameIndexByName(char* frameListName, char* frameName)\r\n{\r\n\tframeListDataStruct* list;\r\n\tframeDataStruct* frame;\r\n\r\n\tlist=getFrameListNodeByName(frameListName);\r\n\tif (list==NULL) return -1;// error, the list doesn't exist\r\n\t\r\n\t// traverse that frame list for the frame named that way\r\n\t// (don't forget, it's valid to have a frame with no name)\r\n\tfor (frame=list->frameList;\r\n\tframe->surface!=NULL && (frame->frameName==NULL ||\r\n\t\tstrcmp(frame->frameName, frameName)!=0);\r\n\tframe++);\r\n\r\n\t// no such frame was found, it's an error\r\n\tif (frame->surface==NULL) return -1;\r\n\r\n\t// otherwise, we found the frame...\r\n\treturn frame-list->frameList;\r\n}// getFrameIndexByName\r\n\r\n// getFrameIndexAndListByName ********\r\n// Given a frame list name, and not the name of a specific frame in\r\n// this version, this function returns the index of such frame in\r\n// the specific frame list it's placed at, and a pointer to\r\n// such list, or -1 for error\r\nint getFrameIndexAndListByName(\r\n\tchar* frameName,// name of the frame we look for\r\n\tframeListDataStruct** foundList)// if not null, a pointer to a pointer that will be set to point to the frame list where it was found\r\n{\r\n\tframeListDataStruct* list;\r\n\tint idx;\r\n\r\n\tlist=frameListsList;\r\n\r\n\t// error, no frame is named with a NULL string\r\n\tif (frameName==NULL) return -1;\r\n\r\n\t// let's traverse the entire lists' list for such a frame...\r\n\tfor(;list->frameList!=NULL; list++){\r\n\t\tidx=getFrameIndexByName(list->listName, frameName);\r\n\t\tif (idx!=-1){\r\n\t\t\t// found!\r\n\t\t\tif (foundList!=NULL) *foundList=list;\r\n\t\t\treturn idx;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\t// not found, return an error code\r\n\tlogger.logLine(\"Error getting frame named: %s\",\r\n\t\ttrue, false, true, frameName);\r\n\treturn -1;\r\n}// getFrameIndexAndListByName \r\n\r\n\r\n// FRAME LIST MANAGEMENT methods 2: for special cases\r\n// ==================================================\r\n\r\n// getFrameIndexByNameInSheeps ********\r\n// Given a frame list name, and the name of a specific frame, this\r\n// function returns the index of such frame in that specific frame\r\n// list, or -1 for error, adding \"white\" or \"black\" to the\r\n// frame name, respecting the color marked by isSheepWhite...\r\nint getFrameIndexByNameInSheeps(\r\n\tbool isSheepWhite,\r\n\tchar* frameListName,\r\n\tchar* frameNamePart)\r\n{\r\n\tconst int fnStringLen=50;\r\n\tchar completeFrameName[fnStringLen];\r\n\tconst char* stringToAdd=\r\n\t\tisSheepWhite?\"white\":\"black\";\r\n\r\n\t// let's see if the string we get with the modifications would\r\n\t// be larger than our string buffer...\r\n\tif (strlen(frameNamePart)+strlen(stringToAdd)+1>fnStringLen)\r\n\t\treturn -1;// error\r\n\r\n\t// let's do the string modification\r\n\tsprintf(completeFrameName, \"%s%s\",\r\n\t\tstringToAdd, frameNamePart);\r\n\r\n\t// do the real work\r\n\treturn getFrameIndexByName(frameListName, completeFrameName);\r\n}// getFrameIndexByNameInSheeps\r\n\r\n// getFrameIndexAndListByNameInSheeps *********\r\n// Given a frame list name, and not the name of a specific frame in\r\n// this version, this function returns the index of such frame in\r\n// the specific frame list it's placed at, and a pointer to\r\n// such list, or -1 for error, adding \"white\" or \"black\" to the\r\n// frame name, respecting the color marked by isSheepWhite...\r\nint getFrameIndexAndListByNameInSheeps(\r\n\tbool isSheepWhite,\r\n\tchar* frameNamePart,\r\n\tframeListDataStruct** foundList)\r\n{\r\n\tframeListDataStruct* list;\r\n\tint idx;\r\n\r\n\tlist=frameListsList;\r\n\r\n\t// let's traverse the entire lists' list for such a frame...\r\n\tfor(;list->frameList!=NULL; list++){\r\n\t\tidx=getFrameIndexByNameInSheeps(\r\n\t\t\tisSheepWhite, list->listName, frameNamePart);\r\n\t\tif (idx!=-1){\r\n\t\t\t// found!\r\n\t\t\tif (foundList!=NULL) *foundList=list;\r\n\t\t\treturn idx;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\t// not found, return an error code\r\n\tlogger.logLine(\"Error getting frame named: %s\",\r\n\t\ttrue, false, true, frameNamePart);\r\n\treturn -1;\r\n}// getFrameIndexAndListByNameInSheeps\r\n\r\n\r\n\r\n// RESOURCE LIST GENERAL MANAGEMENT methods\r\n// ========================================\r\n\r\n// Given a resource name, this method returns the index of the\r\n// respective resource object in resObjectsList, or -1 if the resource\r\n// object isn't present.\r\nint getResObjectIndexByName(char* resname)\r\n{\r\n\tint nodeIdx;\r\n\r\n\t// check the resource name isn't null...\r\n\t// if it's null, it was a call looking for me to return the\r\n\t// 'no one' value, so we return this error value... but this\r\n\t// specific case isn't a real error but a not found return\r\n\tif (resname==NULL) return -1;\r\n\r\n\t// for every node in the objects list...\r\n\tfor (nodeIdx=0; nodeIdx<resObjectsListSize; nodeIdx++){\r\n\t\t// compare the two resource names\r\n\t\tif (strcmp(resObjectsList[nodeIdx].resObj->getResourceName(),\r\n\t\t\tresname)==0){\r\n\r\n\t\t\t// both are equal! this index is the right one\r\n\t\t\treturn nodeIdx;\r\n\t\t}// if\r\n\t}// for nodeIdx\r\n\r\n\t// log the fault...\r\n\tlogger.logLine(\"Error getting resource %s from the resources list\",\r\n\t\ttrue, false, true, resname);\r\n\r\n\t// no object has such name\r\n\treturn -1;\r\n}// getResObjectIndexByName\r\n\r\n\r\n// Given a resource name, this method returns a pointer to the\r\n// respective resource object in resObjectsList, or NULL if the resource\r\n// object isn't present.\r\nresourceClass* getResObjectByName(char* resname){\r\n\tint index;\r\n\r\n\t// obtain the index of that object\r\n\tindex=getResObjectIndexByName(resname);\r\n\r\n\tif (index==-1){\r\n\t\t// the object doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// return a pointer to the object itself\r\n\t\treturn resObjectsList[index].resObj;\r\n\t}// if\r\n}// getResObjectByName\r\n\r\n\r\n\r\n// Given a resource name, this method returns a pointer to the graphic\r\n// resource with that name, or NULL if the resource object isn't\r\n// present, or if it isn't of the expected type.\r\ngraphicResourceClass* getGraphicResourceByName(char* resname)\r\n{\r\n\tresourceClass* object;\r\n\r\n\t// obtain a pointer to the container object\r\n\tobject=getResObjectByName(resname);\r\n\r\n\tif (object==NULL){\r\n\t\t// the object doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// firstly, check the object type\r\n\t\tif (object->getType()!=FILE_RESOBJECTS_GRAPHIC) return NULL;\r\n\r\n\t\t// now return the object contained\r\n\t\treturn ((graphicResourceClass*)object);\r\n\t}// if\r\n}// getGraphicResourceByName\r\n/*\r\n\r\n// Given a resource name, this method returns a pointer to the wave\r\n// resource with that name, or NULL if the resource object isn't\r\n// present, or if it isn't of the expected type.\r\nwaveResourceClass* getWaveResourceByName(char* resname)\r\n{\r\n\tresourceClass* object;\r\n\r\n\t// obtain a pointer to the container object\r\n\tobject=getResObjectByName(resname);\r\n\r\n\tif (object==NULL){\r\n\t\t// the object doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// firstly, check the object type\r\n\t\tif (object->getType()!=FILE_RESOBJECTS_WAVE) return NULL;\r\n\r\n\t\t// now return the object contained\r\n\t\treturn ((waveResourceClass*)object);\r\n\t}// if\r\n}// getWaveResourceByName\r\n\r\n\r\n// Given a resource name, this method returns a pointer to the midi\r\n// resource with that name, or NULL if the resource object isn't\r\n// present, or if it isn't of the expected type.\r\nmidiResourceClass* getMidiResourceByName(char* resname)\r\n{\r\n\tresourceClass* object;\r\n\r\n\t// obtain a pointer to the container object\r\n\tobject=getResObjectByName(resname);\r\n\r\n\tif (object==NULL){\r\n\t\t// the object doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// firstly, check the object type\r\n\t\tif (object->getType()!=FILE_RESOBJECTS_MIDI) return NULL;\r\n\r\n\t\t// now return the object contained\r\n\t\treturn ((midiResourceClass*)object);\r\n\t}// if\r\n}// getMidiResourceByName\r\n*/\r\n// Given a resource name, this method returns a pointer to the\r\n// surface contained by the graphic resource that has that name,\r\n// or NULL if the resource object isn't present, or if it isn't of\r\n// the expected type.\r\nddSpriteClass* getSurfaceByResourceName(char* resname)\r\n{\r\n\tgraphicResourceClass* resource;\r\n\r\n\t// first we obtain the graphic resource\r\n\tresource=getGraphicResourceByName(resname);\r\n\r\n\tif (resource==NULL){\r\n\t\t// the graphic resource doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// the resource exists, return the contained surface\r\n\t\treturn resource->getObjectPointer();\r\n\t}// if\r\n}// getSurfaceByResourceName\r\n\r\n/*\r\n// Given a resource name, this method returns a pointer to the\r\n// wave contained by the wave resource that has that name,\r\n// or NULL if the resource object isn't present, or if it isn't of\r\n// the expected type.\r\nwaveFileClass* getWaveSoundByResourceName(char* resname)\r\n{\r\n\twaveResourceClass* resource;\r\n\r\n\t// first we obtain the wave resource\r\n\tresource=getWaveResourceByName(resname);\r\n\r\n\tif (resource==NULL){\r\n\t\t// the wave resource doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// the resource exists, return the contained wave\r\n\t\treturn resource->getObjectPointer();\r\n\t}// if\r\n}// getWaveSoundByResourceName\r\n\r\n\r\n// Given a resource name, this method returns a pointer to the\r\n// midi contained by the midi resource that has that name,\r\n// or NULL if the resource object isn't present, or if it isn't of\r\n// the expected type.\r\nmidiMusicClass* getMidiMusicByResourceName(char* resname)\r\n{\r\n\tmidiResourceClass* resource;\r\n\r\n\t// first we obtain the midi resource\r\n\tresource=getMidiResourceByName(resname);\r\n\r\n\tif (resource==NULL){\r\n\t\t// the midi resource doesn't exist\r\n\t\treturn NULL;\r\n\t}else{\r\n\t\t// the resource exists, return the contained wave\r\n\t\treturn resource->getObjectPointer();\r\n\t}// if\r\n}// getMidiMusicByResourceName\r\n*/\r\n// OTHER USEFUL FUNCTIONS FOR THE RESOURCE OBJECTS\r\n\r\n// This function tells whether a given resource is in a given\r\n// program zone.\r\nbool isResObjectInProgramZone(\r\n\tresObjectDataStruct* resObject,// resource object structure to tell\r\n\tprogramZonesEnum programZone)// program zone\r\n{\r\n\tprogramZonesEnum* ptrPz;\r\n\r\n\t// Check the entire zones list of this object to know whether\r\n\t// the given zone uses it or not.\r\n\t// Remember the list finishes with pgzon_invalidZone always.\r\n\tfor (ptrPz=resObject->usedInZones;\r\n\t*ptrPz!=pgzon_invalidZone; ptrPz++)\r\n\t{\r\n\t\t// check if this zone is the zone we look for\r\n\t\tif (*ptrPz==programZone){\r\n\t\t\treturn true;\r\n\t\t}// if\r\n\t}// for ptrPz\r\n\r\n\t// The resource isn't used by this zone\r\n\treturn false;\r\n}// isResObjectInProgramZone\r\n\r\n// This function is to be used only once, when closing the program, for\r\n// freeing the memory used in the resource classes\r\nbool destroyAllResourcesData()\r\n{\r\n\tint nodeIdx;\r\n\r\n\t// for every node in the objects list...\r\n\tfor (nodeIdx=0; nodeIdx<resObjectsListSize; nodeIdx++){\r\n\t\t// delete it\r\n\t\tdelete resObjectsList[nodeIdx].resObj;\r\n\t}// for nodeIdx\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// destroyAllResourcesData\r\n\r\n// logAllResourcesState\r\n// This function logs the name of every resource that is currently\r\n// loaded in memory.\r\nbool logAllResourcesState()\r\n{\r\n\tint nodeIdx;// node in the resources list\r\n\tresourceClass* theObject;// a resource object...\r\n\r\n\t// for every node in the objects list...\r\n\tfor (nodeIdx=0; nodeIdx<resObjectsListSize; nodeIdx++){\r\n\t\ttheObject=resObjectsList[nodeIdx].resObj;\r\n\r\n\t\t// log the information\r\n\t\tlogger.logLine(\r\n\t\t\t\"Resname: %s - Loaded: %s - Needs to be reloaded: %s\",\r\n\t\t\ttrue, true, true,\r\n\t\t\ttheObject->getResourceName(),\r\n\t\t\t(theObject->isLoaded()?\"yes\":\"no\"),\r\n\t\t\t(theObject->needsToBeReloaded()?\"yes\":\"no\"));\r\n\t}// for nodeIdx\r\n\r\n\treturn true;// all ok\r\n}// logAllResourcesState\r\n\r\n// OTHER GENERAL USEFUL FUNCTIONS...\r\n\r\n// getTypeDataStruct *******\r\n// This function returns the type data struct of a given unit type\r\ngenericUnitTypeDataStruct* getTypeDataStruct(int objectType)\r\n{\r\n\tswitch(objectType){\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_PLAYER:\r\n\t\treturn playerType;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_ENEMY:\r\n\t\treturn enemyType;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_BULLET:\r\n\t\treturn bulletType;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_WAVEGENERATOR:\r\n\t\treturn waveGenType;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\treturn NULL;// failed\r\n}// getTypeDataStruct\r\n\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nSCRIPTMAN.*:\r\n(functions for managing the game scripts)\r\n\r\n\r\nThese files contain the scriptMan object, which is used for accessing\r\nto the scripts used in the game.\r\n\r\n*/\r\n\r\n#ifndef FILE_SCRIPTMAN_INCLUDED\r\n#define FILE_SCRIPTMAN_INCLUDED\r\n\r\n#define FILE_SCRIPTMAN_VERSION \"2-8-2003-H\"// last modification: dd/mm/yy\r\n\r\n\r\n// header files for using lua\r\nextern \"C\"{\r\n\t#include <lua.h>\r\n}// extern\r\n\r\n// other useful includes...\r\n#include \"globals.h\"// for using the program objects\r\n\r\n\r\n// scriptManagerClass\r\nclass scriptManagerClass{\r\nprivate:\r\n\tbool ready;// has it been properly initialized\r\n\tlua_State* lstate;// lua state object\r\npublic:\r\n\t// constructor / destructor\r\n\tscriptManagerClass():ready(false){}\r\n\t~scriptManagerClass(){}\r\n\r\n\t// init / deinit\r\n\tbool init();\r\n\tbool close();\r\n\r\n\t// some general purpose interfaces\r\n\tbool isReady(){return ready;}\r\n\tlua_State* getLuaObject(){return lstate;}\r\n\tint getIntVariable(char* varName, bool* errCode=NULL);\r\n\tdouble getDoubleVariable(char* varName, bool* errCode=NULL);\r\n\tchar* getStringValue(char* varName, bool* errCode=NULL);\r\n\tbool doString(char* string);\r\n\r\n\t// some interfaces specific for this game...\r\n\tbool setCurrentLanguageInLua(enum languageEnum lang);\r\n\tbool setSoundEnabledInLua(bool nowEnabled, bool soundActive);\r\n};// scriptManagerClass\r\n\r\n#endif// FILE_SCRIPTMAN_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nOPTIONFILE.*:\r\n\r\nThese files contain all the functions related to the management of\r\nthe game options that are saved in files, including those related to\r\nthe list of high scores\r\n\r\n*/\r\n\r\n#ifndef FILE_OPTIONSFILE_INCLUDED\r\n#define FILE_OPTIONSFILE_INCLUDED\r\n\r\n#define FILE_OPTIONSFILE_VERSION \"2-1-2003-H\"// last modification: dd/mm/yy\r\n\r\n// Some useful files to include\r\n#include \"win-constants.h\"// for using DWORD and that stuff\r\n#include \"globals.h\"// for using the program objects\r\n\r\n// Some useful defines\r\n#define FILE_HSCORES_SCORES_ONE_MAXNAMES 10// maximum amount of persons in the high scores list One\r\n#define FILE_HSCORES_SCORES_ONE_NAMELEN 20// maximum length of the string containing the name of somebody in the high scores list One, including the trailing zero\r\n// maximum allowed length of the string containing the name of\r\n// somebody in the high scores list\r\n// (this has to be always at least two bytes lower than NAMELEN)\r\n#define FILE_HSCORES_SCORES_ONE_VIRTUAL_NAMELEN 18\r\n\r\n\r\n// HIGH SCORE STRUCT\r\n// This structure stores the data of a person in the list of high scores.\r\nstruct highScoreStruct{\r\n\tchar name[FILE_HSCORES_SCORES_ONE_NAMELEN];\r\n\tint score;\r\n};// highScoreStruct\r\n\r\n// OPTIONS STRUCT\r\n// Structure where all the data is stored\r\nstruct optionsStruct{\r\n\tWORD header;// the header HO, from HHM's Options\r\n\tDWORD authenticityNumber;// something like a CRC, for checking authenticity\r\n\r\n\t// the language to use\r\n\tlanguageEnum selectedLanguage;\r\n\t// is the sound active?\r\n\tbool programSoundEnabled;\r\n\r\n\t// some statistics\r\n\tDWORD usedTimeSeconds;// time, in seconds, the program has been used\r\n\r\n\t// the high scores lists data\r\n\t// First list: the most commonly used\r\n\thighScoreStruct highScoresOne[FILE_HSCORES_SCORES_ONE_MAXNAMES];\r\n};// optionsStruct\r\n\r\n// HIGH SCORES MANAGER CLASS\r\n// A class that manages all the data and stuff related to the high\r\n// scores list, through the optionsFileClass object\r\nclass highScoresManagerClass{\r\nprivate:\r\n\t// some useful data\r\n\tbool initialized;// was it already initialized?\r\n\thighScoreStruct* hScoresList;// list of high scores\r\n\tint listSize;// size of the list pointed by hScoresList\r\npublic:\r\n\t// constructor / destructor\r\n\thighScoresManagerClass():initialized(false){}\r\n\tvirtual ~highScoresManagerClass(){}\r\n\r\n\t// initialization / deinitialization\r\n\tbool init(highScoreStruct* hScoresList, int listSize);\r\n\tbool end();\r\n\r\n\t// methods for working with the high scores list\r\n\tbool resetList();\r\n\r\n\t// Methods fpr traversing the high scores list:\r\n\t// First, the methods for Higher Score First (HSF), the most useful\r\n\t// order for typical high scores lists.\r\n\thighScoreStruct* getFirstNodeHSF();\r\n\thighScoreStruct* getNextNodeHSF(highScoreStruct* since);\r\n\thighScoreStruct* getLastNodeHSF();\r\n};// highScoresManagerClass\r\n\r\n// OPTIONS FILE CLASS\r\n// This is the object that manages the game options stored in files.\r\nclass optionsFileClass{\r\nprivate:\r\n\tbool initialized;// was it already initialized?\r\n\toptionsStruct* options;// the options of this object\r\npublic:\r\n\t// constructors / destructors\r\n\toptionsFileClass():initialized(false){}\r\n\tvirtual ~optionsFileClass(){if (isReady()) end();}\r\n\r\n\t// init / deinit\r\n\tbool init();\r\n\tbool end();\r\n\r\n\t// working on the file\r\n\tbool load();\r\n\tbool save();\r\n\tbool createFileIfNeeded();\r\n\r\n\t// working with the struct\r\n\tbool resetOptions();\r\n\r\n\t// encryption / authenticity\r\n\tbool crypt();\r\n\tbool decrypt();\r\n\tbool checkAuthenticity(){\r\n\t\tif (options->authenticityNumber!=calculateAuthenticityNumber())\r\n\t\t\treturn false;\r\n\t\telse\r\n\t\t\treturn true;\r\n\t}// checkAuthenticity\r\n\tbool setAuthenticityNumber(){\r\n\t\toptions->authenticityNumber=calculateAuthenticityNumber();\r\n\t\treturn true;\r\n\t}// setAuthenticityNumber\r\n\tDWORD calculateAuthenticityNumber(bool* errorCode=NULL){\r\n\t\tif (errorCode!=NULL) *errorCode=true;\r\n\t\treturn 'MH';\r\n\t}// calculateAuthenticityNumber\r\n\r\n\t// simple getters / setters\r\n\tbool isReady(){return initialized;}\r\n\toptionsStruct* getOptionsPointer(){return options;}\r\n\r\n\t// objects that manage the multiple high score lists\r\n\thighScoresManagerClass* highScoresOneManager;\r\n};// optionsFileClass\r\n\r\n\r\n#endif// FILE_OPTIONSFILE_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nRESOBJECTS.*:\r\n\r\n\r\nThese files contain the classes hierarchy for resource objects, where\r\nresource objects are actually objects that contain, for example, a\r\nddSpriteClass, midiMusicClass, or waveFileClass object.\r\n\r\n*/\r\n\r\n#ifndef FILE_RESOBJECTS_INCLUDED\r\n#define FILE_RESOBJECTS_INCLUDED\r\n\r\n#define FILE_RESOBJECTS_VERSION \"1-10-2002-H\"// last modification: dd/mm/yy\r\n\r\n// some useful header files\r\n#include \"ddwrap.h\"\r\n/*#include \"audiowrap.h\"*/\r\n\r\n// These are the possible types for a resourceClass object.\r\nenum resourceTypeEnum {\r\n\tFILE_RESOBJECTS_GRAPHIC,// it's a ddSurfaceClass object\r\n\tFILE_RESOBJECTS_MIDI,// it's a midiMusicClass object\r\n\tFILE_RESOBJECTS_WAVE// it's a waveFileClass object\r\n};// resourceTypeEnum\r\n\r\n\r\n// RESOURCE CLASS\r\n// This is the class whose objects contain one of multiple resource\r\n// types.\r\nclass resourceClass{\r\nprivate:\r\nprotected:\r\n\t// Some characteristics of the object\r\n\tchar* resourceName;// the name of this resource\r\npublic:\r\n\t// Constructor / destructor\r\n\tresourceClass():resourceName(NULL){}\r\n\tvirtual ~resourceClass(){}\r\n\r\n\t// Some basic interfaces\r\n\tvirtual bool needsToBeReloaded()=0;// tells whether it should be reloaded before using\r\n\tvirtual bool isLoaded()=0;// tells whether the object is currently loaded or not\r\n\tvirtual resourceTypeEnum getType()=0;// tells the type of this resource\r\n\tvirtual char* getResourceName(){return resourceName;}// tell the name of this resource\r\n\r\n\t// Basic object manipulation\r\n\tvirtual bool load()=0;// loads the resource\r\n\tvirtual bool reload()=0;// reloads the resource\r\n\tvirtual bool unload()=0;// unloads the resource\r\n};// resourceClass\r\n\r\n\r\n// GRAPHIC RESOURCE CLASS\r\n// This is the class for graphic objects\r\nclass graphicResourceClass:public resourceClass{\r\nprivate:\r\n\tddSpriteClass surface;// surface where the graphic is stored\r\n\r\n\t// Information for loading\r\n\tchar* fileName;// file from where we'll take the graphic when loading\r\n\tchar* resourceType;// if the graphic is stored in a pcx resource, it could need to know the resource type\r\n\tbool isFileOrResource;// true if it's a file, and not a resource\r\n\tbool allocateInTheFastestMemory;// let the object decide whether to go to video or system memory, according to where it should blt faster? it supposes isTransparent=true if it's going to be blt transparently always\r\n\tbool useVideoMemory;// should the surface be stored in video memory, whenever possible?\r\n\tbool isBMPorPCX;// true if it's a bmp file, and not a pcx file\r\n\tbool isTransparent;// does it use a transparent background?\r\n\tbool usesTransparentRGB;// does it use the three color components for the transparent color, or just the color coordinates? true for a dword\r\n\tint xTransparent, yTransparent;// coordinates of the transparent color\r\n\tint transparentR, transparentG, transparentB;// components of the transparent color\r\n\tint desiredWidth, desiredHeight;// desired width and height for the image, in the case filename=false\r\n\r\n\t// Some auxiliary functions\r\n\tvirtual bool rawLoad();// load the resource itself, and nothing more\r\nprotected:\r\npublic:\r\n\t// Constructor / destructor\r\n\tgraphicResourceClass(char* resName, char* fileName, bool allocateInTheFastestMemory, bool useVideoMemory, bool isFileOrResource, char* resourceType, bool isBMPorPCX, bool isTransparent, bool usesTransparentRGB, int transparentR, int transparentG, int transparentB, int xTransparent, int yTransparent, int desiredWidth, int desiredHeight);\r\n\tvirtual ~graphicResourceClass(){unload();}\r\n\r\n\t// Some basic interfaces\r\n\tvirtual bool needsToBeReloaded(){return surface.isLost();}// tells whether it should be reloaded before using\r\n\tvirtual bool isLoaded(){return surface.isReady();};// tells whether the object is currently loaded or not\r\n\tvirtual resourceTypeEnum getType(){return FILE_RESOBJECTS_GRAPHIC;}// tells the type of this resource\r\n\tddSpriteClass* getObjectPointer(){return &surface;}// get a pointer to the surface object this resource contains\r\n\r\n\t// Basic object manipulation\r\n\tvirtual bool load();// loads the resource\r\n\tvirtual bool reload();// reloads the resource\r\n\tvirtual bool unload();// unloads the resource\r\n};// graphicResourceClass\r\n\r\n/*\r\n// WAVE RESOURCE CLASS\r\n// This is the class for wave sound objects\r\nclass waveResourceClass:public resourceClass{\r\nprivate:\r\n\twaveFileClass waveFile;\r\n\r\n\t// Information for loading\r\n\tchar* fileName;// file from where we'll take the wave when loading\r\n\tchar* fileOgg;// name for the file in ogg version\r\n\tchar* fileTemp;// name for the file in its temporary version... (ogg decoding)\r\n\tchar hardOrSoft;// a char telling where sounds will go, options are FILE_AUDIOWRAP_WAVE_DEFER, FILE_AUDIOWRAP_WAVE_HARDWARE and FILE_AUDIOWRAP_WAVE_SOFTWARE\r\n\r\n\t// Some auxiliary functions\r\n\tvirtual bool rawLoad();// load the resource itself, and nothing more\r\nprotected:\r\npublic:\r\n\t// Constructors / destructor\r\n\twaveResourceClass(char* resName, char* fileName, char hardOrSoft);\r\n\twaveResourceClass(char* resName, char* oggFileName, char* fileName, char* fileTemp, char hardOrSoft);\r\n\tvirtual ~waveResourceClass(){unload();}\r\n\r\n\t// Some functions to tell what the file names are...\r\n\tchar* getFileName(){return fileName;}// get the name of the file...\r\n\tchar* getFileTemp(){return fileTemp;}// get the name of the file...\r\n\tchar* getOggFileName(){return fileOgg;}// get the name of the file in ogg version...\r\n\r\n\t// Some basic interfaces\r\n\tvirtual bool needsToBeReloaded(){return waveFile.isLost();}// tells whether it should be reloaded before using\r\n\tvirtual bool isLoaded(){return waveFile.isReady();};// tells whether the object is currently loaded or not\r\n\tvirtual resourceTypeEnum getType(){return FILE_RESOBJECTS_WAVE;}// tells the type of this resource\r\n\twaveFileClass* getObjectPointer(){return &waveFile;}// get a pointer to the surface object this resource contains\r\n\r\n\t// Basic object manipulation\r\n\tvirtual bool load();// loads the resource\r\n\tvirtual bool reload();// reloads the resource\r\n\tvirtual bool unload();// unloads the resource\r\n};// waveResourceClass\r\n\r\n\r\n// MIDI RESOURCE CLASS\r\n// This is the class for midi music objects\r\nclass midiResourceClass:public resourceClass{\r\nprivate:\r\n\tmidiMusicClass midiMusic;\r\n\r\n\t// Information for loading\r\n\tchar* fileName;// file from where we'll take the midi when loading\r\nprotected:\r\npublic:\r\n\t// Constructor / destructor\r\n\tmidiResourceClass(char* resName, char* fileName);\r\n\tvirtual ~midiResourceClass(){unload();}\r\n\r\n\t// Some basic interfaces\r\n\tvirtual bool needsToBeReloaded(){return false;}// tells whether it should be reloaded before using\r\n\tvirtual bool isLoaded(){return midiMusic.isReady();};// tells whether the object is currently loaded or not\r\n\tvirtual resourceTypeEnum getType(){return FILE_RESOBJECTS_MIDI;}// tells the type of this resource\r\n\tmidiMusicClass* getObjectPointer(){return &midiMusic;}// get a pointer to the midi music object this resource contains\r\n\r\n\t// Basic object manipulation\r\n\tvirtual bool load();// loads the resource\r\n\tvirtual bool reload(){return isLoaded();}// reloads the resource\r\n\tvirtual bool unload();// unloads the resource\r\n};// midiResourceClass\r\n*/\r\n\r\n#endif// FILE_RESOBJECTS_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include <math.h>// for using sqrt\r\n\r\n// setSpeedForLinealMove *****\r\n// This method calculates speedX and speedY for moving a unit lineally.\r\nbool setSpeedForLinealMove(\r\n\tgenericUnitStruct* unit,// enemy unit to move\r\n\tlong double xTo,// coordinates of destination point\r\n\tlong double yTo,\r\n\tdouble linealSpeed)// speed to use in the lineal movement\r\n{\r\n\tlong double dx, dy, dDiagonal;// delta x, y and diagonal\r\n\tdouble ratio;// ratio between distances\r\n\r\n\t// calculate our delta and other initial data\r\n\tdx=xTo-(unit->x);\r\n\tdy=yTo-(unit->y);\r\n\tdDiagonal=sqrt((dx*dx)+(dy*dy));// by Pythagoras theorem\r\n\tlinealSpeed=ABS(linealSpeed);// forget about negative quantities\r\n\r\n\t// let's avoid divisions by zero\r\n\tif (dDiagonal==0){\r\n\t\tunit->speedX=0;\r\n\t\tunit->speedY=0;\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// calculate the ratio between the distance to travel by in total,\r\n\t// and the distance to travel every piece of time (velocity)\r\n\tratio=linealSpeed/dDiagonal;\r\n\r\n\t// now calculate the definitive horizontal and vertical speed...\r\n\tunit->speedX=dx*ratio;\r\n\tunit->speedY=dy*ratio;\r\n\r\n\treturn true;// all ok\r\n}// setSpeedForLinealMove\r\n\r\n\r\n// unintelligentLinealMove ******\r\n// This method executes the movement of a generic unit, if it's required\r\n// that the unit should be moved to a given point\r\nbool unintelligentLinealMove(\r\n\tgenericUnitStruct* unit)// enemy unit to move\r\n{\r\n\tlong double gx=unit->goingToPointX;// point to go coordinates\r\n\tlong double gy=unit->goingToPointY;\r\n\r\n\t// check it's necessary to move the unit such way\r\n\tif (!unit->goingToPoint) return true;\r\n\r\n\t// we assume the speed has already been calculated\r\n\tdouble sx=unit->speedX;// for desired speed\r\n\tdouble sy=unit->speedY;\r\n\r\n\t// check for relative coordinates\r\n\tif (unit->isPosRelative){\r\n\t\tgx+=gameWorld.xCamera;\r\n\t\tgy+=gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// move it, checking that it doesn't surpass the destine\r\n\t// point\r\n\t// x movement\r\n\tif (ABS(gx-unit->x)<=ABS(sx)){\r\n\t\t// reached the desired point\r\n\t\tunit->x=gx;\r\n\t}else{\r\n\t\t// move it\r\n\t\tunit->x+=sx;\r\n\t}// if\r\n\t// y movement\r\n\tif (ABS(gy-unit->y)<=ABS(sy)){\r\n\t\t// reached the desired point\r\n\t\tunit->y=gy;\r\n\t}else{\r\n\t\t// move it\r\n\t\tunit->y+=sy;\r\n\t}// if\r\n\r\n\t// point reached?\r\n\tif (unit->x==gx && unit->y==gy){\r\n\t\tunit->goingToPoint=false;\r\n\t\tunit->speedX=0;\r\n\t\tunit->speedY=0;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// unintelligentLinealMove\r\n\r\n\r\n// getUnitFramesList ************\r\n// Obtain the list of frames of the generic unit, or NULL if that cannot\r\n// be done.\r\nframeDataStruct* getUnitFramesList(\r\n\tgenericUnitStruct* unit)// enemy unit to obtain the current frame from\r\n{\r\n\tgenericUnitTypeDataStruct* typeDataList;\r\n\tgenericUnitTypeDataStruct* myUnitType;\r\n\r\n\ttypeDataList=getTypeDataStruct(unit->objectType);\r\n\r\n\tif (typeDataList==NULL) return NULL;\r\n\r\n\tmyUnitType=&(typeDataList[unit->unitType]);\r\n\r\n\treturn myUnitType->frames;\r\n}// getUnitFramesList\r\n\r\n// getUnitFrame *****************\r\n// Obtain the current frame of the generic unit, or NULL if that cannot\r\n// be done.\r\nframeDataStruct* getUnitFrame(\r\n\tgenericUnitStruct* unit)// enemy unit to obtain the current frame from\r\n{\r\n\tframeDataStruct* frames;\r\n\r\n\tframes=getUnitFramesList(unit);\r\n\r\n\tif (frames==NULL)\r\n\t\treturn frames;\r\n\telse\r\n\t\treturn &(frames[unit->currentFrame]);\r\n}// getUnitFrame\r\n\r\n// constructContainerFrame ******\r\n// Create a frame structure whose information is such that the created\r\n// frame is bigger than any other frame used by the unit (that is, that\r\n// a frame with such dimensions would cover any other frame, so ensuring\r\n// that pixels won't ever be written outside these coordinates in a\r\n// given unit)\r\n// Only the handle coordinates and the frame size are set up in this\r\n// fake frame\r\n// Big collision coordinates aren't calculated.\r\nbool constructContainerFrame(\r\n\tgenericUnitStruct* unit,// enemy unit to obtain the current frame from\r\n\tframeDataStruct* frameToWrite)// frame struct to write to\r\n{\r\n\tframeDataStruct* frames;\r\n\tint framesCount;\r\n\tframeDataStruct* thisFrame;\r\n\r\n\t// these are: distance from the x handle to the left and right border,\r\n\t// and distance to the y handle to the top and bottom border. These\r\n\t// four values will be maximized.\r\n\tint wToLeft=0, wToRight=0, hToTop=0, hToBottom=0;\r\n\tint tempWToLeft, tempWToRight, tempHToTop, tempHToBottom;\r\n\r\n\t// calculate some things\r\n\tframes=getUnitFramesList(unit);\r\n\tif (frames==NULL || frameToWrite==NULL)\r\n\t\treturn false;// error!\r\n\tframesCount=getFramesCount(frames);\r\n\tif (framesCount<=0) return false;// we don't like zero frames!\r\n\r\n\t// now go set up the fields according to the data of all the forms\r\n\tfor (thisFrame=frames; thisFrame-frames<framesCount; thisFrame++){\r\n\t\t// calculate the new four values\r\n\t\ttempWToLeft=thisFrame->handlerX;\r\n\t\ttempWToRight=thisFrame->w-thisFrame->handlerX;\r\n\t\ttempHToTop=thisFrame->handlerY;\r\n\t\ttempHToBottom=thisFrame->h-thisFrame->handlerY;\r\n\r\n\t\t// obtain the most important values of those\r\n\t\twToLeft=(wToLeft>tempWToLeft?wToLeft:tempWToLeft);\r\n\t\twToRight=(wToRight>tempWToRight?wToRight:tempWToRight);\r\n\t\thToTop=(hToTop>tempHToTop?hToTop:tempHToTop);\r\n\t\thToBottom=(hToBottom>tempHToBottom?hToBottom:tempHToBottom);\r\n\t}// for\r\n\r\n\t// write the final frame data\r\n\tframeToWrite->handlerX=wToLeft;\r\n\tframeToWrite->handlerY=hToTop;\r\n\tframeToWrite->w=wToLeft+wToRight;\r\n\tframeToWrite->h=hToTop+hToBottom;\r\n\r\n\treturn true;// all ok...\r\n}// constructContainerFrame\r\n\r\n// Another version of this function, that passes the frame information\r\n// directly through the stack...\r\nframeDataStruct constructContainerFrame(\r\n\tgenericUnitStruct* unit)// enemy unit to obtain the current frame from\r\n{\r\n\tframeDataStruct frame;\r\n\r\n\tconstructContainerFrame(unit, &frame);// don't care about errors\r\n\r\n\t// ready, we did the same that constructContainerFrame, but returning\r\n\t// the frame through stack\r\n\treturn frame;\r\n}// constructContainerFrame\r\n\r\n\r\n// constructSlaverFullFrame ******\r\n// Compose the frame information of a unit and all its recursive slaves,\r\n// so that the composed frame information has the combined boundaries\r\n// of all the slaves and the unit itself. This way, a frameDataStruct\r\n// is created containing the smallest boundaries that let all these\r\n// units fit there.\r\n// Only the handle coordinates and the frame size are set up in this\r\n// fake frame\r\n// Combined collision coordinates aren't calculated.\r\nbool constructSlaverFullFrame(\r\n\tgenericUnitStruct* unit,// slaver enemy unit to obtain the current frame from\r\n\tframeDataStruct* frameToWrite)// frame struct to write to\r\n{\r\n\tframeDataStruct* unitFrame;\r\n\tframeDataStruct slaveFrame;\r\n\tgenericUnitStruct* slave;\r\n\r\n\t// these are: distance from the x handle to the left and right border,\r\n\t// and distance to the y handle to the top and bottom border. These\r\n\t// four values will be calculated, once for visibility boundaries,\r\n\t// and then for collision boundaries.\r\n\tint wToLeft=0, wToRight=0, hToTop=0, hToBottom=0;\r\n\tint tempWToLeft, tempWToRight, tempHToTop, tempHToBottom;\r\n\tint xOff, yOff;\r\n\r\n\t// get the frame of this unit\r\n\tunitFrame=getUnitFrame(unit);\r\n\tif (unitFrame==NULL) return false;// check for errors\r\n\r\n\t// does it have any slaves?\r\n\tif (unit->slaveUnit.objectType==FILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\t\t// base case, no more slaves!\r\n\t\t// return the information of the current frame \r\n\t\t(*frameToWrite)=(*unitFrame);\r\n\t}else{\r\n\t\t// get the slave first\r\n\t\tslave=getUnitPointer(unit->slaveUnit);\r\n\t\tif (slave==NULL) return false;// check for errors\r\n\r\n\t\t// write in slaveFrame the information of the slave unit first\r\n\t\tif (!constructSlaverFullFrame(slave, &slaveFrame)) return false;\r\n\r\n\t\t// now combine the information of this unit with the one of\r\n\t\t// the slave\r\n\t\t// VISIBILITY CALCULATION\r\n\t\t// calculate the displacement between the slave and the unit\r\n\t\txOff=(unitFrame->adherenceX)-(slaveFrame.adherenceX);\r\n\t\tyOff=(unitFrame->adherenceY)-(slaveFrame.adherenceY);\r\n\t\t// calculate the new four values, for the unit\r\n\t\twToLeft=unitFrame->handlerX;\r\n\t\twToRight=unitFrame->w-unitFrame->handlerX;\r\n\t\thToTop=unitFrame->handlerY;\r\n\t\thToBottom=unitFrame->h-unitFrame->handlerY;\r\n\t\t// and for the slave (displaced as needed)\r\n\t\ttempWToLeft=slaveFrame.handlerX-xOff;\r\n\t\ttempWToRight=slaveFrame.w-slaveFrame.handlerX+xOff;\r\n\t\ttempHToTop=slaveFrame.handlerY-yOff;\r\n\t\ttempHToBottom=slaveFrame.h-slaveFrame.handlerY+yOff;\r\n\r\n\t\t// obtain the combination of both values\r\n\t\twToLeft=(wToLeft>tempWToLeft?wToLeft:tempWToLeft);\r\n\t\twToRight=(wToRight>tempWToRight?wToRight:tempWToRight);\r\n\t\thToTop=(hToTop>tempHToTop?hToTop:tempHToTop);\r\n\t\thToBottom=(hToBottom>tempHToBottom?hToBottom:tempHToBottom);\r\n\r\n\t\t// write the final frame data\r\n\t\tframeToWrite->handlerX=wToLeft;\r\n\t\tframeToWrite->handlerY=hToTop;\r\n\t\tframeToWrite->w=wToLeft+wToRight;\r\n\t\tframeToWrite->h=hToTop+hToBottom;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// constructSlaverFullFrame\r\n\r\n\r\n// Another version of this function, that passes the frame information\r\n// directly through the stack...\r\nframeDataStruct constructSlaverFullFrame(\r\n\tgenericUnitStruct* unit)// slaver enemy unit to obtain the current frame from\r\n{\r\n\tframeDataStruct frame;\r\n\r\n\tconstructSlaverFullFrame(unit, &frame);// don't care about errors\r\n\r\n\t// ready, we did the same that constructContainerFrame, but returning\r\n\t// the frame through stack\r\n\treturn frame;\r\n}// constructContainerFrame\r\n\r\n// This functions frees the slave units (if there are any) of a given\r\n// unit\r\nbool freeSlavesOf(genericUnitStruct* unit)\r\n{\r\n\tgenericUnitStruct* slave;\r\n\r\n\tif (unit->slaveUnit.objectType==FILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\t\t// nothing to do\r\n\t\treturn true;// all ok\r\n\t}else{\r\n\t\t// get the slave unit\r\n\t\tslave=getUnitPointer(unit->slaveUnit);\r\n\t\tif (slave==NULL) return false;\r\n\r\n\t\t// unlink both objects\r\n\t\tunit->slaveUnit.objectType=FILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\t\tunit->slaveUnit.id=FILE_GAMEDATA_WHATEVER_ID;\r\n\t\tslave->slaveOf.objectType=FILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\t\tslave->slaveOf.id=FILE_GAMEDATA_WHATEVER_ID;\r\n\r\n\t\t// make the unlinked slave visible\r\n\t\tslave->nowDrawable=true;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// freeSlaveOf\r\n\r\n// This function returns the pointer to the unit unitInfo points to,\r\n// or null if such unit does not exist anymore.\r\ngenericUnitStruct* getUnitPointer(\r\n\tgameObjectPointerStruct unitInfo)\r\n{\r\n\tgenericUnitStruct* unit;\r\n\r\n\t// look for it, following the object type information\r\n\tswitch(unitInfo.objectType){\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_EMPTY:\r\n\t\t// the unit does not exist\r\n\t\tunit=NULL;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_PLAYER:\r\n\t\tunit=&(playerList.getNode(unitInfo.listIndex)->data);\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_BULLET:\r\n\t\tunit=&(bulletList.getNode(unitInfo.listIndex)->data);\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_ENEMY:\r\n\t\tunit=&(enemyList.getNode(unitInfo.listIndex)->data);\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_GAMEOBJECT_WAVEGENERATOR:\r\n\t\tunit=&(waveGenList.getNode(unitInfo.listIndex)->data);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// bad news, that type isn't allowed!\r\n\t\tunit=NULL;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// invalidate the unit if the id doesn't match\r\n\tif (unit!=NULL && unit->id!=unitInfo.id) unit=NULL;\r\n\r\n\t// all ok, return the unit (it could be NULL)\r\n\treturn unit;\r\n}// getUnitPointer\r\n\r\n// autoFrameUnit *******\r\n// This function does the automatic frame switch tasks that are supposed\r\n// to be done once per virtual frame. Basically, all it does is to\r\n// make the unit animation to continue until its frame information is\r\n// changed from outside.\r\nbool autoFrameUnit(genericUnitStruct* unit)\r\n{\r\n\tframeDataStruct* myUnitFrame=getUnitFrame(unit);\r\n\r\n\t// auto frame it if we should...\r\n\tif (myUnitFrame->autoShowVirtualFrames!=0){\r\n\t\tunit->vFramesPassed++;\r\n\t\tif (unit->vFramesPassed>=(myUnitFrame->autoShowVirtualFrames)){\r\n\t\t\t// go to the next frame\r\n\t\t\tunit->currentFrame=myUnitFrame->autoNextFrame;\r\n\r\n\t\t\t// continue auto framing\r\n\t\t\tunit->vFramesPassed=0;\r\n\t\t}// if\r\n\t}//if\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// autoFrameUnit\r\n\r\n// moveWithOwner *********\r\n// This function moves the given unit with the camera and parent unit\r\n// if it's needed.\r\nbool moveWithOwner(genericUnitStruct* unit)\r\n{\r\n\tframeDataStruct* myUnitFrame;\r\n\tgenericUnitStruct* slave;\r\n\tframeDataStruct* slaveFrame;\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(unit);\r\n\r\n\t// if this unit has a slave, it should move it to its own\r\n\t// position\r\n\tif (unit->slaveUnit.objectType!=FILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t// get the slave unit and its frame information...\r\n\t\tif ((slave=getUnitPointer(unit->slaveUnit))==NULL)\r\n\t\t\treturn false;\r\n\t\tslaveFrame=getUnitFrame(slave);\r\n\r\n\t\t// set the slave coordinates\r\n\t\tslave->x=(unit->x)+\r\n\t\t\t(myUnitFrame->adherenceX)-(slaveFrame->adherenceX);\r\n\t\tslave->y=(unit->y)+\r\n\t\t\t(myUnitFrame->adherenceY)-(slaveFrame->adherenceY);\r\n\t}// if\r\n\t\r\n\treturn true;// all ok\r\n}// moveWithCameraAndOwner\r\n\r\n// isUnitInsideTheScreen\r\n// This function tells whether a given unit is inside the screen (visible)\r\n// or not.\r\nbool isUnitInsideTheScreen(genericUnitStruct* unit)\r\n{\r\n\tframeDataStruct combFrame;\r\n\r\n\tif (!constructSlaverFullFrame(unit, &combFrame)) return false;\r\n\r\n\t// calculate the intersection of the biggest frame with the\r\n\t// screen rectangle\r\n\treturn INTERSECTINGRECTANGLES(\r\n\t\tunit->x-(combFrame.handlerX),\r\n\t\tunit->y-(combFrame.handlerY),\r\n\t\tunit->x+(combFrame.w)-(combFrame.handlerX)-1,\r\n\t\tunit->y+(combFrame.h)-(combFrame.handlerY)-1,\r\n\t\tgameWorld.xCamera, gameWorld.yCamera,\r\n\t\tgameWorld.xCamera+gameWorld.wCamera-1,\r\n\t\tgameWorld.yCamera+gameWorld.hCamera-1);\r\n}// isUnitInsideTheScreen\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include <SDL.h>\r\n#include \"globals.h\"// for using the program objects\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"postinstall.h\"// for using the functions related to post-installation tasks\r\n#include \"resfonts.h\"// for accessing to the font resources\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n/*#include \"resmanager.h\"// for using the functions which manage the resources and operate their loading and unloading\r\n#include \"filenames.h\"// for defining the file names\r\n#include \"winutil.h\"// for accessing to some useful functions related to low level windows specific code\r\n#include \"vorbis2wav.h\"// for converting ogg vorbis files to wav*/\r\n#include \"resinfoman.h\"// for managing the information related with the use of resources, ie: animation scripts\r\n\r\n// The definitions...\r\n\r\n// Variables and stuff for language switching\r\nlanguageEnum currentLanguage;// language currently selected\r\n\r\n// Program compiled version info (a string containing such information)\r\nchar programVersionInfoString[]=PROGINFO_FULLVERSIONTEXT;\r\n// A string containing the copyright information.\r\nchar programCopyrightString[]=PROGINFO_COPYRIGHT;\r\n/*\r\n// Data for the windows management\r\nHWND hwnd;\r\nHINSTANCE hInstance;\r\nint nCmdShow;\r\n*/\r\n\r\n// Our directDraw object\r\ndirectDrawClass DD;\r\n\r\n// Our keyboard and mouse objects\r\ndiKeyboardClass keyboard;\r\ndiMouseClass mouse;\r\n\r\n// Data for the console\r\nconsoleClass console;\r\nconLoggerClass logger;\r\n\r\n// Is the sound currently active? Global for the entire program.\r\n// Notice this boolean doesn't tell if the sound is active or not in\r\n// a given moment, it tells whether sound can or cannot be used\r\n// during the entire execution of the program.\r\nbool programSoundActive=true;\r\n// This other boolean tells, instead, whether the sound could be\r\n// used or not in a given moment, according to the current program\r\n// configuration\r\nbool programSoundEnabled=true;\r\n\r\n// Data for the console... conditional compilation depending on the\r\n// developing compilation mode on or off.\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\tbool showConsole=false;\r\n#else// PROGMODE_DEVELOPER_NO\r\n\tbool showConsole=false;\r\n#endif// PROGMODE_DEVELOPER_YES\r\n\r\n// Our time object\r\ntimeWrapperClass time;\r\n\r\n// Frames per second\r\n// This value is the amount of frames that have to be executed\r\n// every second (executeFrame), without caring about the real amount of\r\n// frames (drawFrame) drawn.\r\nconst int desiredFramesPerSecond=200;\r\n\r\n// These consts store the max amount of frames which can be executed\r\n// without drawing a frame on screen. ByTime is used together with\r\n// desiredFramesPerSecond to know the real amount.\r\n// Both are used to enable a mechanism which avoids program halts\r\n// when executeFrame is very slow, then if the program executes too\r\n// much frames at once, it'll go even slower, which will make the program\r\n// execute even more frames, and so on until falling in a deadlock.\r\n// To avoid this, we put this limit to the frames executed (so, if\r\n// either executeFrame or drawFrame goes too much slow, the amount of\r\n// frames skipped -executed- will stop being proportional to the time\r\n// elapsed for every physic frame).\r\n// This system has been tested and works very well.\r\nconst double maxExecutedFramesWithoutDrawingByTime=1;// 1 seconds max, change this number according to the use\r\nconst int maxExecutedFramesWithoutDrawing=// unchangable... use maxExecutedFramesWithoutDrawingByTime instead\r\n\t(int)(maxExecutedFramesWithoutDrawingByTime*desiredFramesPerSecond);\r\n\r\n\r\n// Here follows some variables which store information related to the\r\n// program itself.\r\nmainLoopClass mainLoopObject;// this is the object used for executing the main program loop\r\n\r\n// Program sections:\r\nint currentProgramZone=pgzon_emptyZone;// program zone the program is currently in\r\nint currentProgramSubZone=0;// program sub zone the program is currently in\r\nint currentProgramSubSubZone=0;// program sub sub zone the program is currently in\r\n// Previous program sections:\r\nint previousProgramZone=pgzon_invalidZone;// previous program zone the program was in\r\nint previousProgramSubZone=0;// previous program sub zone the program was in\r\nint previousProgramSubSubZone=0;// previous program sub sub zone the program was in\r\n\r\n// Some global functions related to the resources in globals.*.\r\n\r\n// initializeFirst ******\r\n// initialize the first resources needed (on program start)\r\nbool initializeFirst()\r\n{\r\n\t// initialize our logger (only for files for a while)\r\n\tlogger.init(\"data/logs.txt\");\r\n\tlogger.logLine(\"\");\r\n\tlogger.logLine(\"************\");\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Logging in developer mode.\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t// Log the compilation information\r\n\tlogger.logLine(\"Executable info: %s\",\r\n\t\ttrue, true, true,// file, console, noUnselError\r\n\t\tprogramVersionInfoString);\r\n\t// tell it was started without sound\r\n\tif (!programSoundActive) logger.logLine(\"Sound disabled\");\r\n\t// Log the date and time...\r\n\tlogDateAndTime(\"New execution at %s, %s\");\r\n/*\r\n\t// Initialize the random number generator\r\n\tsrand((unsigned int)(GetTickCount()));\r\n*/\r\n\t// Initialize the game script manager\r\n\tif (!scriptMan.init()){\r\n\t\tcloseAll(\"Script manager initialization failed\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\r\n\t// Game initialization\r\n\t// Let's set the data structures up first...\r\n\tif (!setupGameDataStructures()){\r\n\t\tcloseAll(\"setupGameDataStructures failed\");\r\n\t\treturn false;\r\n\t}// if\r\n/*\r\n\t// Create a directory for screenshots\r\n\tCreateDirectory(\"sshots\", NULL);\r\n\r\n\t// We create a window first.\r\n\t::hInstance=hInstance;\r\n\thwnd=WinUtilCode::createWindow(\r\n\t\thInstance, nCmdShow, &WndProc,\r\n\t\tPROGINFO_WINCLASSNAME,// class name\r\n\t\tPROGINFO_WINDOWTEXT);// windows text\r\n*/\r\n\r\n\tSDL_Init(SDL_INIT_VIDEO);\r\n\r\n\t// Init DirectDraw.\r\n\tif (!DD.init()){\r\n\t\t// error\r\n\t\tcloseAll(\"DD.init failed.\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// set 800x600x16 video mode, with an only backbuffer.\r\n\tif (!DD.setVideoMode(\r\n\t\tscriptMan.getIntVariable(\"screenWidth\"),\r\n\t\tscriptMan.getIntVariable(\"screenHeight\"),\r\n\t\tscriptMan.getIntVariable(\"screenBpp\"), 1)){\r\n\t\t// error\r\n\t\tcloseAll(\"DD.setVideoMode failed.\");\r\n\t\treturn false;\r\n\t}\r\n\t// let's fill all with black\r\n\tDD.fillAllDword(0);\r\n\tDD.flip();\r\n\r\n\t// Time to do all those tasks that are remaining just after\r\n\t// installation, showing the messages that are necessary...\r\n\tif (!executePostInstallTasks(true)){\r\n\t\t// error\r\n\t\tcloseAll(\"executePostInstallTasks failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n/*\r\n\t// let's initialize the audio system\r\n\t// taking the parameters from a wave file...\r\n\tif (programSoundActive){\r\n\t\tif (!generalAudioClass::initializeAudioFromWave(\r\n\t\t\thwnd, FILE_FILENAMES_WAV_INITWAV, true)){\r\n\t\t\t// error\r\n\t\t\tif (true){\r\n\t\t\t\t// don't close the program, rather deactivate the\r\n\t\t\t\t// sound execution\r\n\t\t\t\tlogger.logLine(\"generalAudioClass::initializeAudioFromWave failed. Going never sound instead.\");\r\n\t\t\t\tprogramSoundActive=false;\r\n\r\n\t\t\t\t// set the current sound state in lua\r\n\t\t\t\tscriptMan.setSoundEnabledInLua(\r\n\t\t\t\tprogramSoundEnabled, programSoundActive);\r\n\t\t\t}else{\r\n\t\t\t\t// we used to close the program... now we are nicer\r\n\t\t\t\tcloseAll(\"generalAudioClass::initializeAudioFromWave failed.\");\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// if\r\n*/\r\n\tif (!keyboard.init()){\r\n\t\t// error\r\n\t\tcloseAll(\"keyboard.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\tif (!mouse.init()){\r\n\t\t// error\r\n\t\tcloseAll(\"mouse.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\tif (!mouse.setUpMouse() || !keyboard.setUpKeyboard()){\r\n\t\t// error\r\n\t\tcloseAll(\"setUpMouse and keyword failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\tif (!console.init(400, 100)){\r\n\t\t// error\r\n\t\tcloseAll(\"console.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// initialize our time object\r\n\tif (!time.init()){\r\n\t\t// error\r\n\t\tcloseAll(\"time.init failed.\");\r\n\t\treturn false;\r\n\t}// if\r\n/*\r\n\t// attach the console to our logger\r\n\tif (!logger.attachConsole(&console)){\r\n\t\tlogger.logLine(\"con-logger attach failed.\");\r\n\t}// if\r\n\r\n\t// Log the hardware capabilities\r\n\tlogger.logLine(\"Hardware info:\");\r\n\tlogger.logLine(\"Hardware blts: %s\", true, true, true,\r\n\t\t(DD.doesHardwareBlt()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Hardware transparent blts: %s\", true, true, true,\r\n\t\t(DD.doesHardwareTransparentBlt()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Hardware stretch x: %s\", true, true, true,\r\n\t\t(DD.doesHardwareStretchX()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Hardware stretch y: %s\", true, true, true,\r\n\t\t(DD.doesHardwareStretchY()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Hardware mirror x: %s\", true, true, true,\r\n\t\t(DD.doesHardwareMirrorX()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Hardware mirror y: %s\", true, true, true,\r\n\t\t(DD.doesHardwareMirrorY()?\"Yes\":\"No\"));\r\n\r\n\t// let's see what's the color info this time\r\n\tlogger.logLine(\"Palettized: %s\", true, true, true,\r\n\t\t(DD.isPalettized()?\"Yes\":\"No\"));\r\n\tlogger.logLine(\"Red info: mask %i, offset %i, size %i\",\r\n\t\ttrue, true, true,// log everywhere\r\n\t\tDD.rMask, DD.rOff, DD.rSize);\r\n\tlogger.logLine(\"Green info: mask %i, offset %i, size %i\",\r\n\t\ttrue, true, true,// log everywhere\r\n\t\tDD.gMask, DD.gOff, DD.gSize);\r\n\tlogger.logLine(\"Blue info: mask %i, offset %i, size %i\",\r\n\t\ttrue, true, true,// log everywhere\r\n\t\tDD.bMask, DD.bOff, DD.bSize);\r\n*/\r\n\t// Set up the fonts\r\n\tif (!setUpProgramFonts(false)){\r\n\t\tlogger.logLine(\"set up of program fonts failed\");\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// initializeFirst\r\n\r\n// checkLostResources ******\r\n// Check lost surfaces and buffers, and take care of them...\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool checkLostResources()\r\n{\r\n/*\t// \"Return true\" is used here when the resources can't be restored\r\n\t// yet, but will be in the future (seemingly)\r\n\r\n\t// GRAPHIC RESOURCES\r\n\t// graphic surfaces\r\n\tif (DD.isReady() && DD.isLost()){\r\n\t\tlogger.logLine(\"Screen lost\");\r\n\t\tif (!DD.restore()) return true;\r\n\t}// if\r\n\tif (console.isReady() && console.isLost())\r\n\t\tif (!console.restore()) return true;\r\n\r\n\t// SOUND RESOURCES\r\n\t// Restore the main buffer\r\n\tif (programSoundActive){\r\n\t\tif (generalAudioClass::isAudioSystemReady() &&\r\n\t\t\tgeneralAudioClass::isLostMain()){\r\n\r\n\t\t\tlogger.logLine(\"Audio lost\");\r\n\t\t\tif (!generalAudioClass::restoreMain()) return true;\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// Reload all the resources in the resources object list.\r\n\tif (!reloadAllLostResources()) return false;\r\n*/\r\n\t// all ok\r\n\treturn true;\r\n}// checkLostResources\r\n\r\n// closeAll *************\r\n// destroy all the opened resources\r\nbool closeAll(char* errorText)\r\n{\r\n\t// log date and time first\r\n\tlogDateAndTime(\"Closing at %s, %s\");\r\n\r\n\tif (errorText!=NULL) logger.logLine(errorText);\r\n\r\n\t// save the time and end it\r\n\tif (optionsFileObject.isReady() && time.isReady()){\r\n\t\toptionsFileObject.getOptionsPointer()->usedTimeSeconds+=\r\n\t\t\t(time.getTime()/1000);\r\n\t}// if\r\n\ttime.end();\r\n\r\n\t// save the game options and leave\r\n\tif (optionsFileObject.isReady()){\r\n\t\tif (!optionsFileObject.save())\r\n\t\t\tlogger.logLine(\"Couldn't execute optionsFileObject.save\");\r\n\t\toptionsFileObject.end();\r\n\t}// if\r\n\r\n\t// game stuff...\r\n\tplayerList.end();\r\n\tenemyList.end();\r\n\tbulletList.end();\r\n\tdeinitializeVirtualWalls();\r\n\tcloseResourcesInfo();\r\n\tdestroyAllResourcesData();\r\n\r\n\t// general stuff\r\n\tscriptMan.close();\r\n\tsetUpProgramFonts(true);// destroy the program fonts\r\n\tconsole.end();\r\n\tmouse.end();\r\n\tkeyboard.end();\r\n/*\tif (programSoundActive) generalAudioClass::closeAudio();\r\n*/\r\n\t// shut down the screen...\r\n\tDD.closeVideoMode();\r\n\tDD.end();\r\n\r\n\t// finish the logger, at last...\r\n\tlogger.logLine(\"And closed with no errors\", true, false, true);\r\n\tlogger.end();\r\n\r\n\treturn true;// all ok\r\n}// closeAll\r\n\r\n// shows the console on screen\r\nbool drawConsole()\r\n{\r\n\t// let's show the console\r\n\tif (showConsole)\r\n\t\tif (!console.draw(DD, 10, 10)) return false;\r\n\r\n\treturn true;// all ok\r\n}// showConsole\r\n\r\n\r\n// GLOBAL LOOP MODIFIERS\r\n// Some globals functions which modify the software state, whatever the\r\n// loop in execution is.\r\n\r\n// globalExit *****************\r\n// exits the program whatever its state is\r\nbool globalExit(){\r\n\t// switch to the null zone\r\n\r\n\t// now quit the loop itself\r\n\tmainLoopObject.exitLoop();\r\n\r\n\treturn true;\r\n}// globalExit\r\n\r\n// globalSetActiveState *******\r\n// sets the paused state of the entire software (useful for alt tabs)\r\nbool globalSetActiveState(bool actived){\r\n\tmainLoopObject.setActiveState(actived);\r\n\r\n\treturn true;\r\n}// globalPause\r\n\r\n// Other useful functions\r\n\r\n// logDateAndTime ******\r\n// This function logs the date and time together with a text...\r\n// String to use has to contain %s first, for the date, and %s, for the\r\n// time strings to be added there.\r\nbool logDateAndTime(char* stringToUse)\r\n{\r\n\t// log the date and time\r\n/*\t#define DATETIME_BUFFERSIZE 200\r\n\tchar dateStr[DATETIME_BUFFERSIZE];\r\n\tchar timeStr[DATETIME_BUFFERSIZE];\r\n\r\n\tif (!WinUtilCode::getTimeString(timeStr, DATETIME_BUFFERSIZE) ||\r\n\t\t!WinUtilCode::getDateString(true, dateStr, DATETIME_BUFFERSIZE))\r\n\t\treturn false;\r\n\r\n\tlogger.logLine(stringToUse, true, true, true,\r\n\t\tdateStr, timeStr);\r\n*/\r\n\tlogger.logLine(\"[DATE]-[TIME]:\");// NEW 2010\r\n\tlogger.logLine(stringToUse, true, true, true, \"--\", \"--\");// NEW 2010\r\n\r\n\treturn true;// all ok\r\n}// logDateAndTime\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#ifndef FILE_DIWRAP_INCLUDED\r\n#define FILE_DIWRAP_INCLUDED\r\n\r\n#define FILE_DIWRAP_VERSION \"11-11-2002-H\"// last modification: dd/mm/yy\r\n\r\n// FILES TO ADD TO THE PROJECT FILE:\r\n// This wrapper needs dinput.lib and dxguid.lib\r\n// from the \"lib\" directory of your compiler,\r\n// to be added to the project it's being used in,\r\n// otherwise it won't compile.\r\n\r\n#include <SDL.h>\r\n#include \"win-constants.h\"\r\n#include \"types.h\"\r\n\r\n// If you want your code to be fully compatible with DX 5, keep this line\r\n// uncommented... Otherwise, you'll need to comment it, and the generated\r\n// code will only work for DirectX 7 and above.\r\n// For code compatible with DX 6, keep this line uncommented.\r\n// You can also try changing this number to make it be other values.\r\n#define DIRECTINPUT_VERSION 0x0500 // comment it if necessary\r\n#ifndef DIRECTINPUT_VERSION\r\n\t#define DIRECTINPUT_VERSION 0x0700\r\n#endif // DIRECTINPUT_VERSION\r\n\r\ntypedef Uint8 FILE_DIWRAP_KEYS_TYPE;\r\ntypedef int FILE_DIWRAP_SINGLEKEY_TYPE;\r\n\r\n// Macros for the keyboard\r\n// buffer is: keyObject.keys\r\n// or keyObject.latestKeys if looking for the information of the latest\r\n// state of the keyboard\r\n// Is a given key pressed?\r\n#define KEYDOWN(buffer, key) ((buffer)[(key)])\r\n// The following macros are useful for obtaining the dynamic keyboard\r\n// state rather than the static one. All of these need to compare the\r\n// new buffer with the old one (keyObject.keys vs. keyObject.latestKeys).\r\n// Was that key just pressed?\r\n#define KEYEVENTDOWN(newBuffer, oldBuffer, key) \\\r\n\t((KEYDOWN((newBuffer), (key))) && (!KEYDOWN((oldBuffer), (key))))\r\n// Was that key just released?\r\n#define KEYEVENTUP(newBuffer, oldBuffer, key) \\\r\n\t((!KEYDOWN((newBuffer), (key))) && (KEYDOWN((oldBuffer), (key))))\r\n\r\n#define MOUSE_BUTTON_LEFT 1\r\n\r\n// Macros for the mouse\r\n// buffer is: mouseObject.mouseData\r\n// or mouseObject.latestMouseData if looking for the information of the\r\n// latest mouse state\r\n// Is a given mouse button pressed?\r\n#define MOUSEDOWN(buffer, button) (((buffer).mouse_state) & SDL_BUTTON(button))\r\n// What are the current mouse coordinates?\r\n#define MOUSEX(buffer) ((buffer).mouse_x)\r\n#define MOUSEY(buffer) ((buffer).mouse_y)\r\n// The following macros are useful for obtaining the dynamic mouse\r\n// state rather than the static one. All of these need to compare the\r\n// new buffer with the old one (mouseObject.mouseData vs.\r\n// mouseObject.latestMouseData).\r\n// Was that button just pressed?\r\n#define MOUSEEVENTDOWN(newBuffer, oldBuffer, button) \\\r\n\t((MOUSEDOWN((newBuffer), (button))) && (!MOUSEDOWN((oldBuffer), (button))))\r\n// Was that button just released?\r\n#define MOUSEEVENTUP(newBuffer, oldBuffer, button) \\\r\n\t((!MOUSEDOWN((newBuffer), (button))) && (MOUSEDOWN((oldBuffer), (button))))\r\n\r\n// used for storing the buffered mouse data\r\nstruct mouseDataStruct{\r\n\tint mouse_x, mouse_y;// relative position\r\n\tint mouse_abs_x, mouse_abs_y;// absolute position\r\n\tUint8 mouse_state;\r\n};\r\n\r\n// directInputBaseClass\r\n// That's the pure virtual class that wraps the init and ending\r\n// of the DirectInput object\r\nclass directInputBaseClass{\r\nprivate:\r\n\tstatic int initCount;\r\nprotected:\r\n/*#if DIRECTINPUT_VERSION < 0x0700\r\n\tstatic LPDIRECTINPUT lpDI;\r\n#else// DIRECTINPUT_VERSION\r\n\tstatic LPDIRECTINPUT7 lpDI;\r\n#endif// DIRECTINPUT_VERSION*/\r\n\tbool init();\r\n\tbool end();\r\npublic:\r\n\tdirectInputBaseClass(){}\r\n\tvirtual ~directInputBaseClass(){}\r\n\r\n\tvirtual bool isReady()=0;\r\n};\r\n\r\n// diKeyboardClass\r\n// That's the class that wraps the use of the keyboard through\r\n// DirectInput.\r\nclass diKeyboardClass:public directInputBaseClass{\r\nprivate:\r\n\tbool initializedDI;// is dinput initialized?\r\n\tbool initializedKB;// is the keyboard initialized?\r\n\r\n\tint maxNumKeysUsed;\r\n/*\tLPDIRECTINPUTDEVICE lpDev;*/\r\n\r\n\tFILE_DIWRAP_KEYS_TYPE *createKeysArray(int numkeys);\r\n\r\n\t// the = operator shouln't be used\r\n\t// the same with the copy constructor\r\n\tdiKeyboardClass& operator=(diKeyboardClass& from){return *this;}\r\n\tdiKeyboardClass(diKeyboardClass& from){}\r\npublic:\r\n\tFILE_DIWRAP_KEYS_TYPE *latestKeys;\r\n\tFILE_DIWRAP_KEYS_TYPE *keys;// buffer for the latest keys, previous to the ones at keys\r\n\r\n\tdiKeyboardClass():initializedDI(false), initializedKB(false){}\r\n\t~diKeyboardClass(){end();}\r\n\r\n\tbool isReady(){return initializedDI && initializedKB;}\r\n\r\n\tbool init();\r\n\tbool end();\r\n\r\n\tbool setUpKeyboard();\r\n\tbool closeKeyboard();\r\n\r\n\tbool acquire();\r\n\tbool unacquire();\r\n\r\n\tbool getKeys(bool* isLost=NULL);\r\n};\r\n\r\n// diMouseClass\r\n// That's the class that wraps the use of the mouse through\r\n// DirectInput\r\nclass diMouseClass:public directInputBaseClass{\r\nprivate:\r\n\tbool initializedDI;// is dinput initialized?\r\n\tbool initializedM;// is the mouse initialized?\r\n\r\n/*\tLPDIRECTINPUTDEVICE lpDev;*/\r\n\r\n\t// the = operator shouln't be used\r\n\t// the same with the copy constructor\r\n\tdiMouseClass& operator=(diMouseClass& from){return *this;}\r\n\tdiMouseClass(diMouseClass& from){}\r\npublic:\r\n/*\tDIMOUSESTATE mouseData;\r\n\tDIMOUSESTATE latestMouseData;// buffer for the latest mouse info, previous to the ones at mouseData*/\r\n\tmouseDataStruct mouseData;// buffer for the latest mouse info, previous to the ones at mouseData\r\n\tmouseDataStruct latestMouseData;// buffer for the latest mouse info, previous to the ones at mouseData\r\n\r\n\tdiMouseClass():initializedDI(false), initializedM(false){}\r\n\t~diMouseClass(){end();}\r\n\r\n\tbool isReady(){return initializedDI && initializedM;}\r\n\r\n\tbool init();\r\n\tbool end();\r\n\r\n\tbool setUpMouse();\r\n\tbool closeMouse();\r\n\r\n\tbool acquire();\r\n\tbool unacquire();\r\n\r\n\tbool getState(bool* isLost=NULL);\r\n};\r\n\r\n#endif // FILE_DIWRAP_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#ifndef FILE_CONSOLE_INCLUDED\r\n#define FILE_CONSOLE_INCLUDED\r\n\r\n#define FILE_CONSOLE_VERSION \"10-6-2002-H\"// last modification: dd/mm/yy\r\n\r\n#include \"scrolltext.h\"\r\n\r\nclass consoleClass{\r\nprivate:\r\n\t// our scroll text object\r\n\tscrollTextClass scroll;\r\n\r\n\tbool initialized;\r\n\r\n\t// console data\r\n\tint maxChars;// max amount of chars + 1 for zero\r\n\tchar* lastLine;// where to place the typed string\r\n\tint currentLetter;// pointer to the next byte to be written in lastLine\r\n\tchar* textParam;// where to copy the text params\r\n\tint nextParam;// pointer to the next byte to be read\r\n\tbool lastLineBuffered;// tells if lastLine contains the current or old typed text\r\n\r\n\t// used when getting the params\r\n\tbool skipSpaces();\r\npublic:\r\n\t// some useful methods\r\n\tbool init(int width, int height, int maxChars=200);\r\n\tbool end();\r\n\tbool clear();\r\n\tbool keyUp(char key);\r\n\tbool draw(ddSurfaceClass& srf, int x, int y);\r\n\tbool writeLine(char* text);\r\n\tbool getTextParam(char* &param);\r\n\tbool getNoSpacedTextParam(char* &param);\r\n\tbool getIntegerParam(int &param);\r\n\tbool resetParamPointer();\r\n\r\n\t// methods for dealing with lost surfaces\r\n\tbool isLost(bool* errorCode=NULL);\r\n\tbool restore();\r\n\r\n\t// simple methods\r\n\tbool isReady(){return initialized;}\r\n\r\n\t// constructor / destructor\r\n\tconsoleClass():initialized(false){}\r\n\t~consoleClass(){end();}\r\n};// consoleClass\r\n\r\n#endif// FILE_CONSOLE_INCLUDED\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#ifndef FILE_CONLOGGER_INCLUDED\r\n#define FILE_CONLOGGER_INCLUDED\r\n\r\n#define FILE_CONLOGGER_VERSION \"10-6-2002-H\"// last modification: dd/mm/yy\r\n\r\n#include \"console.h\"\r\n\r\nclass conLoggerClass{\r\nprivate:\r\n\tbool initialized;\r\n\r\n\tchar* fileName;// name of the selected file\r\n\tchar* strBuffer;// buffer for the conversion to string Z\r\n\tint strBufferSize;// size of strBuffer\r\n\tconsoleClass* conPtr;// pointer to a console to log to\r\n\tbool fileReady;// was a file selected?\r\n\r\n\t// some logging private methods\r\n\tbool logToFile(char* text, bool noUnselError=true);\r\n\tbool logToConsole(char* text, bool noUnselError=true);\r\npublic:\r\n\t// some useful methods\r\n\tbool init(char* name=NULL,\r\n\t\tconsoleClass* console=NULL, int bytesBufferName=100,\r\n\t\tint bytesStrBuffer=200);\r\n\tbool end();\r\n\tbool attachConsole(consoleClass* console);\r\n\tbool selectFile(char* name);\r\n\tbool logLine(char* text, bool file=true, bool console=true,\r\n\t\tbool noUnselError=true, ...);\r\n\r\n\t// constructor / destructor\r\n\tconLoggerClass():initialized(false){}\r\n\t~conLoggerClass(){end();}\r\n};// conLoggerClass\r\n\r\n#endif// FILE_CONLOGGER_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n/*\r\nTIMEWRAP.*:\r\n\r\n\r\nThese files are the time wrapper, that's a small time library with a\r\nvery useful extra feature: the posibility of pausing time, for example,\r\nevery time the window focus is lost, and to continue it when the focus\r\nis back.\r\n\r\n*/\r\n\r\n#ifndef FILE_TIMEWRAP_INCLUDED\r\n#define FILE_TIMEWRAP_INCLUDED\r\n\r\n#define FILE_TIMEWRAP_VERSION \"1-1-2003-H\"// last modification: dd/mm/yy\r\n\r\n// Include some useful header files\r\n#include \"win-constants.h\"\r\n\r\n// timeWrapperClass\r\n// that's our class for time\r\nclass timeWrapperClass{\r\nprivate:\r\n\t// some important flags\r\n\tbool initialized;\r\n\tbool paused;\r\n\r\n\t// info for the clock state\r\n\t// Time at which the clock is supposed to have been started\r\n\tDWORD startTime;\r\n\t// Time to be added to obtain the actual current time\r\n\t// (used because of the pause and \"wrap-around\" functions)\r\n\tDWORD plusTime;\r\n\t// This variable tells the value by which time since startTime has\r\n\t// to be multiplied. Normal state is 1, values bigger than 1 define\r\n\t// faster time resolutions, and values smaller than 1 define slower\r\n\t// time resolutions. For example, with multiplier=2, the time\r\n\t// tells 2 seconds for every real second.\r\n\tdouble multiplier;\r\nprotected:\r\npublic:\r\n\ttimeWrapperClass():initialized(false){}\r\n\tvirtual ~timeWrapperClass(){end();}\r\n\r\n\tbool isReady(){return initialized;}\r\n\tbool isPaused(){return paused;}\r\n\r\n\tbool init();\r\n\tbool end();\r\n\tbool pause();\r\n\tbool reset();\r\n\tbool play();// let the clock continue working, after being paused...\r\n\tDWORD getTime(bool* errorCode=NULL);// returns the time in milliseconds\r\n\tdouble getMultiplier(){return multiplier;}\r\n\tbool setMultiplier(double newmul);\r\n};\r\n\r\n#endif// FILE_TIMEWRAP_INCLUDED\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nMAINLOOP.*:\r\n\r\nHere goes the code which interfaces directly with the loop wrapper, and\r\nwhich decides what kind of frame is going to be executed and drawn next\r\n(game frame, intro frame, etc).\r\n\r\n*/\r\n\r\n#ifndef FILE_MAINLOOP_INCLUDED\r\n#define FILE_MAINLOOP_INCLUDED\r\n\r\n#define FILE_MAINLOOP_VERSION \"14-7-2002-H\"// last modification: dd/mm/yy\r\n\r\n// Include some useful header files\r\n#include \"win-constants.h\"\r\n#include \"loopwrap.h\"// for generic frame loops code\r\n\r\n// This is the class which manages the main loop for the program.\r\n// The code related to the frames management is actually in the\r\n// loopWrapperClass definition.\r\nclass mainLoopClass:public loopWrapperClass{\r\nprivate:\r\nprotected:\r\npublic:\r\n\t// constructors / destructors\r\n\tmainLoopClass(){}\r\n\tvirtual ~mainLoopClass(){}\r\n\r\n\t// Methods which are pure virtual at the base class\r\n\tvirtual bool executeFrame(DWORD frameNumber);// method called once per frame\r\n\tvirtual bool drawFrame();// method called every time a frame has to be drawn in the screen\r\n\tvirtual bool beforeLoop();// method called just before starting the main loop\r\n\tvirtual bool afterLoop();// method called just after finishing with the main loop\r\n\tvirtual bool informFramesPerSecond(double fps);// method called every time the frames por second information is calculated, in a timely basis\r\n};// mainLoopClass\r\n\r\n#endif// FILE_MAINLOOP_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n/*\r\nLOOPWRAP.*:\r\n\r\n\r\nThese files contain the generic code to be used in frame loops which\r\nrequire independence from the computer speed (measured in frames per\r\nsecond). Through C++ inheritance, these files allows to implement such\r\nframe loops just by derivating classes from loopWrapperClass.\r\n\r\n*/\r\n\r\n#ifndef FILE_LOOPWRAP_INCLUDED\r\n#define FILE_LOOPWRAP_INCLUDED\r\n\r\n#define FILE_LOOPWRAP_VERSION \"7-6-2002-H\"// last modification: dd/mm/yy\r\n\r\n#include \"timewrap.h\"// for using the time wrapper class\r\n\r\n// loopWrapperClass\r\n// that's our class for generic frame loops code.\r\nclass loopWrapperClass{\r\nprivate:\r\n\t// internal timer object\r\n\ttimeWrapperClass timer;\r\n\r\n\t// stores the amount of frames to be executed every second\r\n\tint framesToExecutePerSecond;\r\n\r\n\tvolatile bool externalEnded;// to know when it's time to stop the main loop\r\n\tvolatile bool activeLoop;// to know when it's time to pause the main loop, for reasons like the app losing the user focus\r\nprotected:\r\npublic:\r\n\t// constructors / destructors\r\n\tloopWrapperClass(){}\r\n\tvirtual ~loopWrapperClass(){end();}\r\n\r\n\t// loop management methods\r\n\tvirtual bool executeMainLoop(int desiredFramesPerSecond, int maxExecutedFramesWithoutDrawing, DWORD msecToCalculateFPS);\r\n\tvirtual bool end(){exitLoop(); return true;}\r\n\r\n\t// some simple interfaces\r\n\tvirtual void exitLoop(){externalEnded=true;}\r\n\tvirtual bool isLoopActive(){return activeLoop;}\r\n\tvirtual void setActiveState(bool active){activeLoop=active;}\r\n\tvirtual timeWrapperClass* getTimerObject(){return &timer;}\r\n\tvirtual int getFramesToExecutePerSecond(){return framesToExecutePerSecond;}\r\n\r\n\t// Methods to be inherited\r\n\t// All of them have to return true if all went right, otherwise, false\r\n\t// for fatal errors.\r\n\tvirtual bool executeFrame(DWORD frameNumber)=0;// method called once per frame\r\n\tvirtual bool drawFrame()=0;// method called every time a frame has to be drawn in the screen\r\n\tvirtual bool beforeLoop()=0;// method called just before starting the main loop\r\n\tvirtual bool afterLoop()=0;// method called just after finishing with the main loop\r\n\tvirtual bool informFramesPerSecond(double fps)=0;// method called every time the frames por second information is calculated, in a timely basis\r\n};// loopWrapperClass\r\n\r\n#endif// FILE_LOOPWRAP_INCLUDED\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#ifndef FILE_SCROLLTEXT_INCLUDED\r\n#define FILE_SCROLLTEXT_INCLUDED\r\n\r\n#define FILE_SCROLLTEXT_VERSION \"23-5-2002-H\"// last modification: dd/mm/yy\r\n\r\n#include \"ddwrap.h\"\r\n\r\nclass scrollTextClass {\r\nprivate:\r\n\tbool initialized;\r\n//\tddSpriteClass surface;\r\n\r\n\tint r, g, b;// color of the text\r\n\tint rB, gB, bB;// color of the background\r\n\tint fontHeight, numLines;// numLines: amount of lines\r\npublic:\r\n\t// main methods\r\n\tbool init(int width, int height, int r, int g, int b, int rB, int gB, int bB, bool videoMemory=false);\r\n\tbool end();\r\n\tbool scrollLines(int lines);\r\n\tbool writeLatestLine(char* text);\r\n\tbool blt(ddSurfaceClass& srf, int x, int y);\r\n\tbool clearSurface();\r\n\r\n\t// methods to manage lost surfaces\r\n\tbool isLost(bool* errorCode=NULL);\r\n\tbool restore();\r\n\r\n\t// constructor / destructor\r\n\tscrollTextClass():initialized(false){}\r\n\t~scrollTextClass(){end();}\r\n\r\n\t// simple interfaces\r\n\t// most are self explaining\r\n\tbool isReady(){return initialized;}\r\n\tint getFontHeight(){return fontHeight;}\r\n\tint getNumLines(){return numLines;}// get the amount of lines\r\n//\tddSpriteClass* getSurfacePointer(){return &surface;}// use with care\r\n\tvoid getTextColor(int& rT, int& gT, int& bT){rT=r; gT=g; bT=b;}\r\n\tvoid getBackgroundColor(int& rB, int& gB, int& bB)\r\n\t{\r\n\t\trB=scrollTextClass::rB;\r\n\t\tgB=scrollTextClass::g;\r\n\t\tbB=scrollTextClass::b;\r\n\t}// getBackgroundColor\r\n};\r\n\r\n#endif// FILE_SCROLLTEXT_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"humanheadai.h\"// for managing the AI of a specific type of enemies, the human heads\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n\r\n// headLinearMovementDoneEvent *******\r\n// This is the code to be executed when a head finishes with the\r\n// execution of a linear movement.\r\nbool headLinearMovementDoneEvent(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)\r\n{\r\n\t// check what kind of switch it was\r\n\tif (unit.data.aiSpecific.headData.fallingHead){\r\n\t\t// it was falling, and has just stopped the free fall\r\n\t\tunit.data.aiSpecific.headData.fallingHead=false;\r\n\r\n\t\t// set another frame\r\n\t\tunit.data.currentFrame=\r\n\t\t\tgetFrameIndexAndListByName(\"humanHeadNormal\");// common frame\r\n\t}// if\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// headLinearMovementDoneEvent\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"introcode.h\"// for accesing to the methods related to the program zone corresponding to the intro\r\n#include \"gameglobals.h\"// for using the game objects\r\n/*#include \"generalmaths.h\"// for mathematical functions*/\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include <SDL.h>\r\n#include <string.h>\r\n/*#include \"optionsfile.h\"// for the management of the files where the game options are saved\r\n#include \"soundman.h\"// for using the functions related to sound management*/\r\n\r\n// *****************************\r\n// MAIN FUNCTIONS\r\n// Addressed as IntroLoopCode::*\r\n// *****************************\r\n\r\n// English texts\r\nstatic char* presText_en=\"H. Hern�n Moraldo productions\\nis proud to present\";\r\nstatic char* finalText_en=\"- - R A N D O M E D I A - -\";\r\nstatic char* skipText_en=\"(PRESS SPACE TO SKIP)\";\r\nstatic char* loadingText_en=\"R A N D O M E D I A\\n\\nNow loading...\";\r\n\r\n// Spanish texts\r\nstatic char* presText_sp=\"H. Hern�n Moraldo productions\\npresenta con extremo orgullo\";\r\nstatic char* finalText_sp=\"- - R A N D O M E D I A - -\";\r\nstatic char* skipText_sp=\"(PRESIONE ESPACIO PARA OMITIR LA INTRO)\";\r\nstatic char* loadingText_sp=\"R A N D O M E D I A\\n\\nCargando...\";\r\n\r\n// Some other variables\r\nstatic char* textToShow;\r\nstatic double textLightness;// 0 to 255, lightness factor\r\nstatic double lightingSpeedPres;// how much to light per frame\r\nstatic double obscuringSpeedPres;// how much to obscure per frame\r\nstatic double lightingSpeedFinal;// how much to light per frame\r\nstatic double obscuringSpeedFinal;// how much to obscure per frame\r\nstatic int framesToWaitPres;// how much to wait there\r\nstatic int framesToWaitFinal;// how much to wait there\r\nstatic enum {nowObscuringPres, nowWaitingPres, nowLightingPres, nowObscuringFinal, nowWaitingFinal, nowLightingFinal}\r\n\tactionInProcess;\r\nstatic int framesWaitingLeft;\r\n\r\n// drawFrame *************\r\n// Draw the current frame on screen.\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool IntroLoopCode::drawFrame()\r\n{\r\n\tddSpriteClass* buffer;\r\n\r\n\t// get the buffer's surface\r\n\tbuffer=getSurfaceByResourceName(\"srfScreenSizedBuffer\");\r\n\r\n\t// draw either a text or the logo images\r\n\tif (false){\r\n\t\t// draw a black blackground\r\n\t\tbuffer->fillAllDword(0);\r\n\r\n\t\t// draw the intro text\r\n\t\tfntDahFont.drawMultilineText(\r\n\t\t\t*(buffer),// where to draw the text to\r\n\t\t\ttextToShow,// text to draw\r\n\t\t\tstrlen(textToShow),// text size\r\n\t\t\t0,// horizontal position\r\n\t\t\t0,// vertical position, changed to be somewhat higher in the screen\r\n\t\t\tDD.getWidth(), DD.getHeight(),// text size\r\n\t\t\ttrue, FILE_DDWRAP_ALIGN_CENTER,// transparency, alignment\r\n\t\t\tFILE_DDWRAP_VALIGN_CENTER);// vertical alignment\r\n\t}else{\r\n\t\tDWORD color;\r\n\t\tddSurfaceClass* srf;\r\n\r\n\t\tswitch(actionInProcess){\r\n\t\tcase nowLightingPres:\r\n\t\tcase nowWaitingPres:\r\n\t\tcase nowObscuringPres:\r\n\t\t\tsrf=getSurfaceByResourceName(\"srfIntroTmgLogo\");\r\n\r\n\t\t\t// draw a white blackground\r\n\t\t\tbuffer->getDwordFromRGB(255, 255, 255, color);\r\n\t\t\tbuffer->fillAllDword(color);\r\n\r\n\t\t\t// draw the The Moraldo Games logo\r\n\t\t\tbuffer->bltFrom(*srf,\r\n\t\t\t\t(buffer->getWidth()-srf->getWidth())/2,\r\n\t\t\t\t(buffer->getHeight()-srf->getHeight())/2);\r\n\t\t\tbreak;\r\n\t\tcase nowLightingFinal:\r\n\t\tcase nowWaitingFinal:\r\n\t\tcase nowObscuringFinal:\r\n\t\t\tsrf=getSurfaceByResourceName(\"srfIntroRediaLogo\");\r\n\r\n\t\t\t// draw the Randomedia logo\r\n\t\t\tbuffer->bltFrom(*srf, 0, 0);\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t}// if\r\n\r\n\t// now blt the buffer to the screen, obscured\r\n\tDD.obscuredBltFrom(*(buffer),// surface\r\n\t\t0, 0,// coordinates\r\n\t\t(unsigned char)(textLightness),// lightness\r\n\t\tfalse);// transparent?\r\n\r\n\t// draw a black rectangle\r\n\t{\r\n\tint x, y, w, h;\r\n\tfntEdiaFont.calculateMultilineTextSize(\r\n\t\tDD,// where to draw the text to\r\n\t\tLAN_SEL(skipText_sp,skipText_en),// text to draw\r\n\t\tstrlen(LAN_SEL(skipText_sp,skipText_en)),// text size\r\n\t\t0,// horizontal position\r\n\t\t0,// vertical position, changed to be somewhat higher in the screen\r\n\t\tDD.getWidth(), DD.getHeight()-40,// text size\r\n\t\tFILE_DDWRAP_ALIGN_CENTER,// alignment\r\n\t\tFILE_DDWRAP_VALIGN_BOTTOM,// vertical alignment\r\n\t\t&x, &y, &w, &h);\r\n\tDD.fillRect(0, 0, 0, x-2, y-2, w+4, h+4);\r\n\t}// block\r\n\r\n\t// draw the text telling how to skip\r\n\tfntEdiaFont.drawMultilineText(\r\n\t\tDD,// where to draw the text to\r\n\t\tLAN_SEL(skipText_sp,skipText_en),// text to draw\r\n\t\tstrlen(LAN_SEL(skipText_sp,skipText_en)),// text size\r\n\t\t0,// horizontal position\r\n\t\t0,// vertical position, changed to be somewhat higher in the screen\r\n\t\tDD.getWidth(), DD.getHeight()-40,// text size\r\n\t\ttrue, FILE_DDWRAP_ALIGN_CENTER,// transparency, alignment\r\n\t\tFILE_DDWRAP_VALIGN_BOTTOM);// vertical alignment\r\n\r\n\treturn true;// all ok\r\n}// drawFrame\r\n\r\n// executeFrame ***********\r\n// Execute a frame, without drawing it on screen. It's what I call\r\n// \"virtual frames\".\r\n// Only return false for non-recover errors.\r\nbool IntroLoopCode::executeFrame(DWORD frameNumber)\r\n{\r\n\t// do whatever is needed now\r\n\tswitch(actionInProcess){\r\n\tcase nowLightingPres:\r\n\t\t// start lighting the text\r\n\t\ttextLightness+=lightingSpeedPres;\r\n\r\n\t\t// check when it's done\r\n\t\tif (textLightness>=255){\r\n\t\t\ttextLightness=255;\r\n\r\n\t\t\t// go to the waiting stage\r\n\t\t\tactionInProcess=nowWaitingPres;\r\n\t\t\tframesWaitingLeft=framesToWaitPres;\r\n\t\t}// if\r\n\t\tbreak;\r\n\tcase nowWaitingPres:\r\n\t\t// wait some time\r\n\t\tframesWaitingLeft--;\r\n\t\tif (framesWaitingLeft==0) actionInProcess=nowObscuringPres;\r\n\t\tbreak;\r\n\tcase nowObscuringPres:\r\n\t\t// obscure it\r\n\t\ttextLightness-=obscuringSpeedPres;\r\n\r\n\t\t// when it's done, go to the final stage\r\n\t\tif (textLightness<=0){\r\n\t\t\ttextLightness=0;\r\n\t\t\ttextToShow=LAN_SEL(finalText_sp, finalText_en);\r\n\r\n\t\t\t// go to the waiting stage\r\n\t\t\tactionInProcess=nowLightingFinal;\r\n\t\t}// if\r\n\t\tbreak;\r\n\tcase nowLightingFinal:\r\n\t\t// start lighting the text\r\n\t\ttextLightness+=lightingSpeedFinal;\r\n\r\n\t\t// when it's done, go to the waiting stage\r\n\t\tif (textLightness>=255){\r\n\t\t\ttextLightness=255;\r\n\r\n\t\t\t// wait\r\n\t\t\tactionInProcess=nowWaitingFinal;\r\n\t\t\tframesWaitingLeft=framesToWaitFinal;\r\n\t\t}// if\r\n\t\tbreak;\r\n\tcase nowWaitingFinal:\r\n\t\t// wait some time\r\n\t\tframesWaitingLeft--;\r\n\t\tif (framesWaitingLeft==0) actionInProcess=nowObscuringFinal;\r\n\t\tbreak;\r\n\tcase nowObscuringFinal:\r\n\t\t// obscure it\r\n\t\ttextLightness-=obscuringSpeedFinal;\r\n\r\n\t\t// when it's done, go to the menues\r\n\t\tif (textLightness<=0){\r\n\t\t\ttextLightness=0;\r\n\r\n\t\t\tif (!switchToProgramZone(pgzon_gameMenues, 0, 0, true))\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t\tbreak;\r\n\t}// if\r\n\r\n\t// Check for keys...\r\n\t// Space and escape go to menues\r\n\tif (!showConsole  &&\r\n\t\tKEYEVENTDOWN(keyboard.keys, keyboard.latestKeys, SDLK_SPACE) ||\r\n\t\tKEYEVENTDOWN(keyboard.keys, keyboard.latestKeys, SDLK_ESCAPE)){\r\n\r\n\t\t// go to the menues\r\n\t\tif (!switchToProgramZone(pgzon_gameMenues, 0, 0, true))\r\n\t\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// executeFrame\r\n\r\n// beforeLoop **********\r\n// This is the code to be executed every time a program zone linked to\r\n// these functions is switched to.\r\nbool IntroLoopCode::beforeLoop()\r\n{\r\n\tdouble secLightPres=0.8;\r\n\tdouble waitPres=2.46-secLightPres;\r\n\tdouble secObsPres=3.2-(secLightPres+waitPres);\r\n\tdouble secLightFinal=4.0-(secLightPres+waitPres+secObsPres);\r\n\tdouble waitFinal=6.0-(secLightPres+waitPres+secObsPres+secLightFinal);\r\n\tdouble secObsFinal=9.0-(secLightPres+waitPres+secObsPres+secLightFinal+waitFinal);\r\n\r\n\t// before starting, stop all the playing sounds (belonging to other\r\n\t// program zones)\r\n/*\tif (!stopAllSoundResources()) return false;*/\r\n\r\n\t// calculate the speeds for pres\r\n\t// obscure all in secObsPres seconds\r\n\tobscuringSpeedPres=(255/double(desiredFramesPerSecond))/secObsPres;\r\n\t// wait waitPres seconds\r\n\tframesToWaitPres=int(waitPres*desiredFramesPerSecond);\r\n\t// light all in secLightPres seconds\r\n\tlightingSpeedPres=(255/double(desiredFramesPerSecond))/secLightPres;\r\n\r\n\t// calculate the speeds for final\r\n\t// obscure all in secObsFinal seconds\r\n\tobscuringSpeedFinal=(255/double(desiredFramesPerSecond))/secObsFinal;\r\n\t// wait waitFinal seconds\r\n\tframesToWaitFinal=int(waitFinal*desiredFramesPerSecond);\r\n\t// light all in secLightFinal seconds\r\n\tlightingSpeedFinal=(255/double(desiredFramesPerSecond))/secLightFinal;\r\n\r\n\t// reset the lightness information\r\n\ttextLightness=0;\r\n\ttextToShow=LAN_SEL(presText_sp,presText_en);\r\n\tactionInProcess=nowLightingPres;\r\n\r\n\t// start playing the intro sound now\r\n/*\tplaySoundResource(\"sndWavIntroSnd\");*/\r\n\r\n\treturn true;// all ok\r\n}// beforeLoop\r\n\r\n\r\n// afterLoop ***********\r\n// This is the code to be executed every time it's time to switch to\r\n// another program zone, being a program zone currently linked to\r\n// these functions.\r\nbool IntroLoopCode::afterLoop()\r\n{\r\n\tchar* textToShow=LAN_SEL(loadingText_sp, loadingText_en);\r\n\r\n\t// write a 'now loading message on the screen'\r\n\t// draw a black blackground\r\n\tDD.fillAllDword(0);\r\n\r\n\t// draw the intro text\r\n\tfntDahFont.drawMultilineText(\r\n\t\t\tDD,// where to draw the text to\r\n\t\t\ttextToShow,// text to draw\r\n\t\t\tstrlen(textToShow),// text size\r\n\t\t\t0,// horizontal position\r\n\t\t\t0,// vertical position, changed to be somewhat higher in the screen\r\n\t\t\tDD.getWidth(), DD.getHeight(),// text size\r\n\t\t\ttrue, FILE_DDWRAP_ALIGN_CENTER,// transparency, alignment\r\n\t\t\tFILE_DDWRAP_VALIGN_CENTER);// vertical alignment\r\n\r\n\t// show it\r\n\tDD.flip();\r\n\r\n\treturn true;// all ok\r\n}// afterLoop\r\n\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#include \"loopwrap.h\"// for generic frame loops code\r\n\r\n\r\n// Methods for managing the loop\r\n\r\n// executeMainLoop *\r\n// This method is used to execute the loop itself. It's supposed to return\r\n// only when the loop has ended. If it returns false, it means there has\r\n// been a fatal error during the execution...\r\n// Params are:\r\n// framesToExecutePerSecond: a value telling how many frames how to be\r\n// \"executed\" per second.\r\n// maxExecutedFramesWithoutDrawing: value used to enable a mechanism which\r\n// avoids program halts when executeFrame is very slow. In that case, if\r\n// the program executes too much frames at once, it'll go even slower, which\r\n// will make the program execute even more frames, and so on until falling\r\n// in a deadlock.\r\n// To avoid this, we put this limit to the frames executed (so, if\r\n// either executeFrame or drawFrame goes too much slow, the amount of\r\n// frames skipped -executed- will stop being proportional to the time\r\n// elapsed for every physic frame).\r\n// This system has been tested and works very well. Values of 1 or 2 seconds\r\n// are usual.\r\n// msecToCalculateFPS: tells how many milliseconds have to pass before\r\n// informFramesPerSecond() is called.\r\nbool loopWrapperClass::executeMainLoop(\r\n\tint framesToExecutePerSecond,// This value is the amount of frames that have to be executed every second (executeFrame), without caring about the real amount of frames (drawFrame) drawn.\r\n\tint maxExecutedFramesWithoutDrawing,// see above\r\n\tDWORD msecToCalculateFPS)// how many milliseconds have to pass before informing the current amount of frames per second\r\n{\r\n\t// declare some variables...\r\n\tint i;// for repetitive control structures\r\n/*\tMSG msg;*/\r\n\tbool ended=false;\r\n\r\n\t// some other for measuring the frames per second\r\n\tDWORD timeInit, timeEnd, frames;\r\n\r\n\t// some other for maintaining a fixed \"virtual\" frame rate\r\n\tDWORD lastFrameNumber, frameNumber;\r\n\tDWORD lastFrameTime, frameTime;\r\n\tint skippedFrames;\r\n\r\n\t// initialize some useful variables...\r\n\tloopWrapperClass::framesToExecutePerSecond=framesToExecutePerSecond;\r\n\texternalEnded=false;\r\n\tactiveLoop=true;\r\n\tif (!timer.isReady()){timer.init();}// the timer too\r\n\r\n\t// get the timer for the first time\r\n\ttimeInit=timer.getTime();\r\n\r\n\t// For measuring frames per second only\r\n\tframes=0;\r\n\r\n\t// The frames for us, drawFrame and executeFrame start from zero\r\n\t// every time this method is called\r\n\tDWORD framesExecuted=0;\r\n\r\n\t// set all for the independant frame rate\r\n\tlastFrameTime=timeInit;// timer.getTime()\r\n\t// current frame number, actually\r\n\tlastFrameNumber=(framesToExecutePerSecond*lastFrameTime)/1000;\r\n\r\n\t// execute what's required before the first frame\r\n\tif (!beforeLoop()) return false;\r\n\r\n\t// MAIN LOOP\r\n\twhile(!ended){\r\n\t\t// draw the current frame\r\n\t\tif (!drawFrame()) return false;\r\n\r\n\t\t// continue the timer, even if it wasn't paused\r\n\t\ttimer.play();\r\n\r\n\t\t// Check desired fps and execute the necessary amount of frames...\r\n\t\t// Check desired FPS and calculate the frames to \"skip\" (execute)\r\n\t\tframeTime=timer.getTime();\r\n\t\tframeNumber=(framesToExecutePerSecond*frameTime)/1000;\r\n\t\tskippedFrames=(int)(frameNumber-lastFrameNumber);\r\n\t\t// There is a maximum for skippedFrames, to avoid time deadlocks...\r\n\t\tif (skippedFrames>maxExecutedFramesWithoutDrawing)\r\n\t\t\tskippedFrames=maxExecutedFramesWithoutDrawing;\r\n\r\n\t\t// Execute the frames\r\n\t\tfor (i=0; i<skippedFrames; i++){\r\n\t\t\t// execute a virtual frame\r\n\t\t\tif (!executeFrame(framesExecuted)) return false;\r\n\t\t\tframesExecuted++;\r\n\t\t}// for i\r\n\t\tlastFrameNumber=frameNumber;\r\n\t\tlastFrameTime=frameTime;\r\n\r\n\t\t// check the frames per second, and inform that value...\r\n\t\tframes++;\r\n\t\ttimeEnd=frameTime;\r\n\t\tif (timeEnd-timeInit>msecToCalculateFPS){\r\n\r\n\t\t\tif (!informFramesPerSecond(\r\n\t\t\t\tdouble(frames)/(double(timeEnd-timeInit)/1000.0)))\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// reset it all\r\n\t\t\ttimeInit=timer.getTime();\r\n\t\t\tframes=0;\r\n\t\t}// if\r\n\r\n\t\t// while there are messages to get, dispatch them\r\n/*\t\twhile (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)){\r\n\t\t\tif (msg.message == WM_QUIT)  // exit main loop on WM_QUIT\r\n\t\t\t\tended=true;\r\n\r\n\t\t\tTranslateMessage(&msg);\r\n\t\t\tDispatchMessage(&msg);\r\n\t\t}// while peeking\r\n*/\r\n\t\t// pause the timer if our app isn't active...\r\n\t\tif (!activeLoop) timer.pause();\r\n\r\n/*\t\t// if our app isn't active, keep dispatching messages only\r\n\t\t// (unless it's execution has ended)\r\n\t\twhile (!activeLoop && !ended){\r\n\t\t\tGetMessage(&msg, NULL, 0, 0);\r\n\r\n\t\t\tif (msg.message == WM_QUIT)  // exit main loop on WM_QUIT\r\n\t\t\t\tended=true;\r\n\r\n\t\t\tTranslateMessage(&msg);\r\n\t\t\tDispatchMessage(&msg);\r\n\t\t}// if\r\n*/\r\n\t\t// Exit the loop if necessary\r\n\t\tif (externalEnded) ended=true;\r\n\t}// while ended\r\n\r\n\t// execute what's required after the last frame\r\n\tif (!afterLoop()) return false;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// executeMainLoop\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n#include <SDL.h>\r\n#include \"ddwrap.h\"\r\n#include \"console.h\"\r\n#include \"con-logger.h\"\r\n#include \"globals.h\"// for using the program objects\r\n#include \"postinstall.h\"// for using the functions related to post-installation tasks\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include \"gameglobals.h\"// for using the game objects\r\n\r\n#include <string.h>\r\n\r\n/*\r\n#include <windows.h>\r\n#include <stdio.h>\r\n#include \"diwrap.h\"\r\n#include \"audiowrap.h\"\r\n#include \"gamecode.h\"// for accessing to the code related only with the game\r\n#include \"resmanager.h\"// for using the functions which manage the resources and operate their loading and unloading\r\n#include \"winutil.h\"// for accessing to some useful functions related to low level windows specific code\r\n#include \"staging.h\"// for the management of stages, levels, and the switching between these\r\n#include \"introcode.h\"// for accesing to the methods related to the program zone corresponding to the intro\r\n#include \"menucode.h\"// for accesing to the methods related to the program zone corresponding to the game menues\r\n\r\nLRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\r\n{\r\n\ttimeWrapperClass* timePtr;// for using in the multiplier command\r\n\r\n\tswitch (message){\r\n\tcase WM_KEYDOWN:\r\n\t\tswitch (wParam){\r\n\t\tcase VK_F12:// extremely fast exit\r\n\t\t\tDestroyWindow(hwnd);\r\n\t\t\treturn 0;\r\n\t\t}//switch\r\n\t\tbreak;\r\n\tcase WM_CHAR:\r\n\t\t// manage the showing / hiding the console\r\n\t\tif (wParam=='\\t'){\r\n\t\t\tshowConsole=!showConsole;\r\n\r\n\t\t\tbreak;// don't let this key go to the console\r\n\t\t}// if\r\n\r\n\t\t// manage the high score name typing\r\n\t\tif (!showConsole && isCurrentlyTypingNameHS){\r\n\t\t\tif (!executeHighScoreTyping(wParam)){\r\n\t\t\t\t// error, just log it\r\n\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\"Error while managing the score name typing\");\r\n\t\t\t}// if\r\n\t\t}// if\r\n\r\n\t\tif (!showConsole) break;\r\n\r\n\t\t// filter some control keys\r\n\t\tif (wParam==VK_ESCAPE) break;\r\n\r\n\t\tconsole.keyUp(wParam);\r\n\r\n\t\tif (wParam=='\\r'){\r\n\t\t\t// check the command\r\n\t\t\tchar* parammie;\r\n\r\n\t\t\tif (!console.getTextParam(parammie)) return 0;\r\n\t\t\tparammie=strlwr(parammie);\r\n\r\n\t\t\t// CLIPSPRITES\r\n\t\t\t// Command for deciding whether the sprites are\r\n\t\t\t// clipped or not. Useful for test purposes.\r\n\t\t\tif (strcmp(\"clipsprites\", parammie)==0){\r\n\t\t\t\t// change the clip sprites flag\r\n\t\t\t\tdbgClipSprites=!dbgClipSprites;\r\n\r\n\t\t\t\t// inform the change\r\n\t\t\t\tlogger.logLine(\"Clip sprites from game world: %s\",\r\n\t\t\t\t\ttrue, true, true, dbgClipSprites?\"true\":\"false\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// ADVANCESTAGE\r\n\t\t\t// Command for advancing once in the stageLevels succession\r\n\t\t\tif (strcmp(\"advancestage\", parammie)==0){\r\n\t\t\t\t// tell in advance what we'll do\r\n\t\t\t\tlogger.logLine(\"advanceStage command executed:\");\r\n\r\n\t\t\t\t// advance the stage level!\r\n\t\t\t\tif (!advanceStage()){\r\n\t\t\t\t\t// error, notice it\r\n\t\t\t\t\tlogger.logLine(\"Couldn't advance the stageLevel.\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// DONTEVERDIE\r\n\t\t\t// Command for deciding whether the player's energy is going\r\n\t\t\t// to be decrementable or not\r\n\t\t\tif (strcmp(\"donteverdie\", parammie)==0){\r\n\t\t\t\tbool last;\r\n\r\n\t\t\t\t// change the inmortality flag on the players\r\n\t\t\t\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\t\t\t\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t\t\t\tnodeP->data.decrementableEnergy=!\r\n\t\t\t\t\t\tnodeP->data.decrementableEnergy;\r\n\t\t\t\t\tlast=nodeP->data.decrementableEnergy;\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\t// inform the change\r\n\t\t\t\tif (last){\r\n\t\t\t\t\tlogger.logLine(\"DontEverDie: player won't ever die\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"DontEverDie: player's energy decrementability is on\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// FULLENERGY\r\n\t\t\t// Command for giving full energy to every player.\r\n\t\t\tif (strcmp(\"fullenergy\", parammie)==0){\r\n\t\t\t\t// add much energy to every player\r\n\t\t\t\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\t\t\t\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t\t\t\tnodeP->data.energyLeft=1000;\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"FullEnergy command executed\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// ONELIFE\r\n\t\t\t// Command for making the player have an only life\r\n\t\t\tif (strcmp(\"onelife\", parammie)==0){\r\n\t\t\t\t// make every player be almost death\r\n\t\t\t\tvectorListNodeStruct<playerUnitStruct>* nodeP;\r\n\t\t\t\tfor (nodeP=playerList.getFirstNode(); nodeP!=NULL; nodeP=playerList.getNextNode(nodeP)){\r\n\t\t\t\t\tnodeP->data.energyLeft=1;\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"OneLife command executed\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// WAVEGENACTIVE\r\n\t\t\t// Command for switching the \"nowGenerating\" flag of a given\r\n\t\t\t// wave generator (1 and 2 for sheeps, 3 for brains)\r\n\t\t\tif (strcmp(\"wavegenactive\", parammie)==0){\r\n\t\t\t\tint wavegenNum;\r\n\r\n\t\t\t\t// get the wave generator number\r\n\t\t\t\tif (!console.getIntegerParam(wavegenNum)){\r\n\t\t\t\t\tlogger.logLine(\"WaveGenActive requires a numeric parameter\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\tif (wavegenNum<1 && wavegenNum>3) wavegenNum=1;\r\n\r\n\t\t\t\t// add much energy to every player\r\n\t\t\t\tvectorListNodeStruct<waveGenUnitStruct>* nodeWG;\r\n\t\t\t\tfor (nodeWG=waveGenList.getFirstNode(); nodeWG!=NULL; nodeWG=waveGenList.getNextNode(nodeWG)){\r\n\t\t\t\t\tswitch(wavegenNum){\r\n\t\t\t\t\tcase 1:// white sheeps\r\n\t\t\t\t\t\tif (nodeWG->data.unitType==\r\n\t\t\t\t\t\t\tFILE_GAMEDATA_WAVEGEN_WHITESHEEPS){\r\n\r\n\t\t\t\t\t\t\tnodeWG->data.generatingNow=\r\n\t\t\t\t\t\t\t\t!nodeWG->data.generatingNow;\r\n\t\t\t\t\t\t}// if\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:// black sheeps\r\n\t\t\t\t\t\tif (nodeWG->data.unitType==\r\n\t\t\t\t\t\t\tFILE_GAMEDATA_WAVEGEN_BLACKSHEEPS){\r\n\r\n\t\t\t\t\t\t\tnodeWG->data.generatingNow=\r\n\t\t\t\t\t\t\t\t!nodeWG->data.generatingNow;\r\n\t\t\t\t\t\t}// if\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:// brains\r\n\t\t\t\t\t\tif (nodeWG->data.unitType==\r\n\t\t\t\t\t\t\tFILE_GAMEDATA_WAVEGEN_HUMANHEADS){\r\n\r\n\t\t\t\t\t\t\tnodeWG->data.generatingNow=\r\n\t\t\t\t\t\t\t\t!nodeWG->data.generatingNow;\r\n\t\t\t\t\t\t}// if\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}// switch\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"waveGenActive command executed for %i\",\r\n\t\t\t\t\ttrue, true, true, wavegenNum);\r\n\t\t\t}// if\r\n\r\n\t\t\t// STOPWAVEGENS\r\n\t\t\t// Command for making all the wave generators stop generating\r\n\t\t\t// stuff\r\n\t\t\tif (strcmp(\"stopwavegens\", parammie)==0){\r\n\t\t\t\t// stop all the wave gens\r\n\t\t\t\tvectorListNodeStruct<waveGenUnitStruct>* nodeWG;\r\n\t\t\t\tfor (nodeWG=waveGenList.getFirstNode(); nodeWG!=NULL; nodeWG=waveGenList.getNextNode(nodeWG)){\r\n\t\t\t\t\t\tnodeWG->data.generatingNow=false;\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\t// stop the automatic level switching too\r\n\t\t\t\tgameWorld.timeLeftToNextStage=0;\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"StopWaveGens command executed\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// GOZOOM\r\n\t\t\t// Command for starting the screen zoom\r\n\t\t\tif (strcmp(\"gozoom\", parammie)==0){\r\n\t\t\t\t// execute zooming if it's not yet activate\r\n\t\t\t\tif (gameWorld.zoomed){\r\n\t\t\t\t\t// no more zoom\r\n\t\t\t\t\tgameWorld.zoomed=false;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// activate the zoom\r\n\t\t\t\t\tgameWorld.zoomed=true;\r\n\t\t\t\t\tgameWorld.zoomCX=DD.getWidth()/2;\r\n\t\t\t\t\tgameWorld.zoomCY=DD.getHeight()/2;\r\n\t\t\t\t\tgameWorld.zoomBy=2;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"GoZoom command executed\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// TREMBLERS\r\n\t\t\t// Command for switching on and of the letSpritesTremble flag\r\n\t\t\tif (strcmp(\"tremblers\", parammie)==0){\r\n\t\t\t\t// switch the letSpritesTremble value\r\n\t\t\t\tletSpritesTremble=\r\n\t\t\t\t\t!letSpritesTremble;\r\n\r\n\t\t\t\tif (letSpritesTremble){\r\n\t\t\t\t\tlogger.logLine(\"Tremblers: trembling sprites active\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"Tremblers: trembling sprites inactive\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// GOINGTOLINES\r\n\t\t\t// Command for switching on and off the\r\n\t\t\t// drawGoingToLines flag\r\n\t\t\tif (strcmp(\"goingtolines\", parammie)==0\r\n\t\t\t\t|| strcmp(\"gtl\", parammie)==0){\r\n\t\t\t\t// switch the drawGoingToLines value\r\n\t\t\t\tdrawGoingToLines=\r\n\t\t\t\t\t!drawGoingToLines;\r\n\r\n\t\t\t\tif (drawGoingToLines){\r\n\t\t\t\t\tlogger.logLine(\"goingToLines: 'going to' lines will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"goingToLines: 'going to' lineswon't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// FOLLOWINGLINES\r\n\t\t\t// Command for switching on and off the\r\n\t\t\t// drawFollowingLines flag\r\n\t\t\tif (strcmp(\"followinglines\", parammie)==0\r\n\t\t\t\t|| strcmp(\"fl\", parammie)==0){\r\n\t\t\t\t// switch the drawGoingToLines value\r\n\t\t\t\tdrawFollowingLines=\r\n\t\t\t\t\t!drawFollowingLines;\r\n\r\n\t\t\t\tif (drawFollowingLines){\r\n\t\t\t\t\tlogger.logLine(\"followingLines: 'following' lines will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"followingLines: 'following' lineswon't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// HANDLERPOINTS\r\n\t\t\t// Command for switching on and off the\r\n\t\t\t// drawHandlerPoints flag\r\n\t\t\tif (strcmp(\"handlerpoints\", parammie)==0\r\n\t\t\t\t|| strcmp(\"hp\", parammie)==0){\r\n\t\t\t\t// switch the drawHandlerPoints value\r\n\t\t\t\tdrawHandlerPoints=\r\n\t\t\t\t\t!drawHandlerPoints;\r\n\r\n\t\t\t\tif (drawHandlerPoints){\r\n\t\t\t\t\tlogger.logLine(\"handlerPoints: handler points will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"handlerPoints: handler points won't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// BOUNDRECTS\r\n\t\t\t// Command for switching on and off the\r\n\t\t\t// drawBoundingRectangles flag\r\n\t\t\tif (strcmp(\"boundrects\", parammie)==0){\r\n\t\t\t\t// switch the drawBoundingRectangles value\r\n\t\t\t\tdrawBoundingRectangles=\r\n\t\t\t\t\t!drawBoundingRectangles;\r\n\r\n\t\t\t\tif (drawBoundingRectangles){\r\n\t\t\t\t\tlogger.logLine(\"BoundRects: bounding rects will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"BoundRects: bounding rects won't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// DRAWWAVEGENS\r\n\t\t\t// Command for switching on and off the drawWaveGenerators\r\n\t\t\t// flag, which tells whether we should draw the wave\r\n\t\t\t// generators (ie, the foreground) or not\r\n\t\t\tif (strcmp(\"drawwavegens\", parammie)==0){\r\n\t\t\t\t// switch the drawWaveGenerators value\r\n\t\t\t\tdrawWaveGenerators=\r\n\t\t\t\t\t!drawWaveGenerators;\r\n\r\n\t\t\t\tif (drawWaveGenerators){\r\n\t\t\t\t\tlogger.logLine(\"DrawWaveGens: wave generators will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"DrawWaveGens: wave generators won't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// DRAWVIRTUALWALLS\r\n\t\t\t// Command for switching on and off the drawVirtualWalls\r\n\t\t\t// flag, which tells whether we should draw the virtual\r\n\t\t\t// walls (that is, their boundaries) or not\r\n\t\t\tif (strcmp(\"drawvirtualwalls\", parammie)==0 ||\r\n\t\t\t\tstrcmp(\"dvw\", parammie)==0){\r\n\r\n\t\t\t\t// switch the drawVirtualWalls value\r\n\t\t\t\tdrawVirtualWalls=\r\n\t\t\t\t\t!drawVirtualWalls;\r\n\r\n\t\t\t\tif (drawVirtualWalls){\r\n\t\t\t\t\tlogger.logLine(\"DrawVirtualWalls: virtual walls will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"DrawVirtualWalls: virtual walls won't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// DRAWFALLINGLIMITS\r\n\t\t\t// Command for switching on and off the drawFallingLimits\r\n\t\t\t// flag, which tells whether we should draw the\r\n\t\t\t// limits for the falling objets or not\r\n\t\t\tif (strcmp(\"drawfallinglimits\", parammie)==0 ||\r\n\t\t\t\tstrcmp(\"dfl\", parammie)==0){\r\n\t\t\t\t// switch the drawFallingLimits value\r\n\t\t\t\tdrawFallingLimits=\r\n\t\t\t\t\t!drawFallingLimits;\r\n\r\n\t\t\t\tif (drawFallingLimits){\r\n\t\t\t\t\tlogger.logLine(\"DrawFallingLimits: falling limits will be drawn\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"DrawFallingLimits: falling limits won't be drawn\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// VIDEOCAPTURE\r\n\t\t\t// Command for switching on and off the video capture\r\n\t\t\t// (continuous screenshooting)\r\n\t\t\tif (strcmp(\"videocapture\", parammie)==0){\r\n\t\t\t\t// switch the keepTakingScreenshots value\r\n\t\t\t\tkeepTakingScreenshots=\r\n\t\t\t\t\t!keepTakingScreenshots;\r\n\r\n\t\t\t\tif (keepTakingScreenshots){\r\n\t\t\t\t\tlogger.logLine(\"VideoCapture: started saving images to disk\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlogger.logLine(\"BoundRects: stopped saving images to disk\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// MULTIPLIER\r\n\t\t\t// Command for changing the value of the time multiplier\r\n\t\t\tif (strcmp(\"multiplier\", parammie)==0){\r\n\t\t\t\ttimePtr=mainLoopObject.getTimerObject();\r\n\t\t\t\tif (timePtr->getMultiplier()==1){\r\n\t\t\t\t\t// change the multiplier value\r\n\t\t\t\t\ttimePtr->setMultiplier(0.25);// slow\r\n\r\n\t\t\t\t\t// inform it\r\n\t\t\t\t\tlogger.logLine(\"Multiplier set to 0.25\");\r\n\t\t\t\t}else if (timePtr->getMultiplier()==0.25){\r\n\t\t\t\t\t// change the multiplier value\r\n\t\t\t\t\ttimePtr->setMultiplier(4);// fast\r\n\r\n\t\t\t\t\t// inform it\r\n\t\t\t\t\tlogger.logLine(\"Multiplier set to 4\");\r\n\t\t\t\t}else{// for 4\r\n\t\t\t\t\t// change the multiplier value\r\n\t\t\t\t\ttimePtr->setMultiplier(1);// common\r\n\r\n\t\t\t\t\t// inform it\r\n\t\t\t\t\tlogger.logLine(\"Multiplier set to 1\");\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// WAYSLOW\r\n\t\t\t// Command for setting the time multiplier to an extremely\r\n\t\t\t// slow speed\r\n\t\t\tif (strcmp(\"wayslow\", parammie)==0 ||\r\n\t\t\t\tstrcmp(\"ws\", parammie)==0){\r\n\r\n\t\t\t\ttimePtr=mainLoopObject.getTimerObject();\r\n\r\n\t\t\t\t// change the multiplier value\r\n\t\t\t\ttimePtr->setMultiplier(0.05);\r\n\r\n\t\t\t\t// inform the change\r\n\t\t\t\tlogger.logLine(\"WaySlow: Multiplier set to %f\",\r\n\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\ttimePtr->getMultiplier());\r\n\t\t\t}// if\r\n\r\n\t\t\t// ULTRAFAST\r\n\t\t\t// Command for setting the time multiplier to an extremely\r\n\t\t\t// fast speed\r\n\t\t\tif (strcmp(\"ultrafast\", parammie)==0){\r\n\t\t\t\ttimePtr=mainLoopObject.getTimerObject();\r\n\r\n\t\t\t\t// change the multiplier value\r\n\t\t\t\ttimePtr->setMultiplier(20);\r\n\r\n\t\t\t\t// inform the change\r\n\t\t\t\tlogger.logLine(\"UltraFast: Multiplier set to %f\",\r\n\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\ttimePtr->getMultiplier());\r\n\t\t\t}// if\r\n\r\n\t\t\t// LANGSWITCH\r\n\t\t\t// Command for switching the language currently active\r\n\t\t\tif (strcmp(\"langswitch\", parammie)==0){\r\n\t\t\t\tswitch(currentLanguage){\r\n\t\t\t\tcase language_spanish:\r\n\t\t\t\t\t// switch it...\r\n\t\t\t\t\tcurrentLanguage=language_english;\r\n\r\n\t\t\t\t\t// inform the change\r\n\t\t\t\t\tlogger.logLine(\"Language switched to english...\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase language_english:\r\n\t\t\t\t\t// switch it...\r\n\t\t\t\t\tcurrentLanguage=language_spanish;\r\n\r\n\t\t\t\t\t// inform the change\r\n\t\t\t\t\tlogger.logLine(\"Language switched to spanish...\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}// switch\r\n\r\n\t\t\t\t// set the current language in lua\r\n\t\t\t\tscriptMan.setCurrentLanguageInLua(currentLanguage);\r\n\r\n\t\t\t\t// save the change in the options file\r\n\t\t\t\toptionsFileObject.getOptionsPointer()->selectedLanguage=\r\n\t\t\t\t\tcurrentLanguage;\r\n\t\t\t\toptionsFileObject.save();\r\n\t\t\t}// if\r\n\r\n\t\t\t// STATEOFRESOURCES\r\n\t\t\t// Command for retrieving the state of all the resources\r\n\t\t\tif (strcmp(\"stateofresources\", parammie)==0){\r\n\t\t\t\t// execute the action\r\n\t\t\t\tlogAllResourcesState();\r\n\r\n\t\t\t\t// inform it\r\n\t\t\t\tlogger.logLine(\"stateOfResources command executed\");\r\n\t\t\t}// if\r\n\r\n\t\t\t// LUACMD\r\n\t\t\t// Command for executing a lua command\r\n\t\t\tif (strcmp(\"luacmd\", parammie)==0){\r\n\t\t\t\tchar* command;\r\n\r\n\t\t\t\tif (!console.getNoSpacedTextParam(command)){\r\n\t\t\t\t\tlogger.logLine(\"This command requires an extra text parameter\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// execute the lua command\r\n\t\t\t\t\tif (!scriptMan.doString(command)){\r\n\t\t\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\t\t\"Failed executing the lua command\");\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\r\n\t\t\t// COMMANDLIST\r\n\t\t\t// Command for obtaining a list of commands\r\n\t\t\tif (strcmp(\"commandlist\", parammie)==0){\r\n\t\t\t\t// give the list of commands\r\n\t\t\t\tlogger.logLine(\"1: clipSprites fullEnergy oneLife waveGenActive\");\r\n\t\t\t\tlogger.logLine(\"2: langSwitch stateOfResources\");\r\n\t\t\t\tlogger.logLine(\"3: goZoom tremblers boundRects drawWaveGens\");\r\n\t\t\t\tlogger.logLine(\"4: videoCapture multiplier waySlow commandList\");\r\n\t\t\t\tlogger.logLine(\"5: dontEverDie drawVirtualWalls ultraFast\");\r\n\t\t\t\tlogger.logLine(\"6: goingToLines advanceStage stopWaveGens\");\r\n\t\t\t\tlogger.logLine(\"7: followingLines handlerPoints drawFallingLimits\");\r\n\t\t\t\tlogger.logLine(\"8: luaCmd\");\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t\treturn 0;\r\n    case WM_SETCURSOR:\r\n\t\t// i don't want a cursor\r\n \t    SetCursor(NULL);// set cursor...\r\n\t\t// further processing halted\r\n\t    return TRUE;\r\n\tcase WM_DESTROY:\r\n\t\tPostQuitMessage(0);\r\n\t\treturn 0;\r\n\tcase WM_ACTIVATEAPP:\r\n\t\t// Mark as active app or inactive app\r\n\t\tglobalSetActiveState(BOOL(wParam)==TRUE);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\treturn DefWindowProc(hwnd, message, wParam, lParam);\r\n}\r\n*/\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n/*\t// we save the data we got...\r\n\t::hInstance=hInstance;\r\n\t::nCmdShow=nCmdShow;\r\n*/\r\n\t// let's see what parameters are here for us...\r\n\t// -FINISHINSTALL is used for making the program go the\r\n\t// finishing installation mode\r\n//\tif (argc>1 && strcmp(strlwr(argv[1]), \"-finishinstall\")==0){\r\n\tif (argc>1 && strcmp(argv[1], \"-finishinstall\")==0){\r\n\t\t// it's time to finish the installation and go away\r\n\t\tlogger.init(\"data/logs.txt\");\r\n\t\tlogger.logLine(\"\");\r\n\t\tlogger.logLine(\"************\");\r\n\t\tlogDateAndTime(\"Just installed at %s %s, executing post installation\");\r\n\r\n\t\tif (!executePostInstallTasks(false))\r\n\t\t\tlogger.logLine(\"Bad post installation process...\");\r\n\r\n\t\tlogger.logLine(\"***** INSTALLATION READY *****\");\r\n\t\tlogger.end();\r\n\t\treturn 0;\r\n\t}// if\r\n\r\n\t// -NEVERSOUND is used for making the program execute in an\r\n\t// absolutely silent mode, not only temporarily disabling sound\r\n\t// but also never letting the program active the sound again\r\n\t// for the entire session.\r\n//\tif (strcmp(strlwr(szCmdLine), \"-neversound\")==0){\r\n\tif (argc>1 && strcmp(argv[1], \"-neversound\")==0){\r\n\t\t// go to silent mode\r\n\t\tprogramSoundActive=false;\r\n\t}// if\r\n\r\n\t// initialize all what's needed\r\n\tif (!initializeFirst()){\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Initialize first ok\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t// Go to the first zone to be executed\r\n\tif (!switchToProgramZone(pgzon_gameIntro, 0, 0, true)){\r\n\t\t// time to go away...\r\n\t\tcloseAll(\"Could not set up first program zone...\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Switch to first program zone ok\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t// go start the game\r\n\tif (!mainLoopObject.executeMainLoop(desiredFramesPerSecond,\r\n\t\tmaxExecutedFramesWithoutDrawing, 5000))\r\n\t\tlogger.logLine(\"Bad game execution!\");\r\n\r\n\t// Terminate...\r\n\tcloseAll(\"Time to go away...\");\r\n\r\n\treturn 0;\r\n}\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"mainloop.h\"// for accessing to the main loop object\r\n#include \"console.h\"\r\n#include \"con-logger.h\"\r\n#include \"introcode.h\"// for accesing to the methods related to the program zone corresponding to the intro*/\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n/*#include \"gameglobals.h\"// for using the game objects*/\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gamecode.h\"// for accessing to the code related only with the game\r\n#include \"menucode.h\"// for accesing to the methods related to the program zone corresponding to the game menues\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include <SDL.h>\r\n\r\n// MAINLOOPCLASS METHODS\r\n// *********************\r\n\r\n// informFramesPerSecond *\r\n// We use this method to receive the amount of frames per second in a\r\n// timely basis, and log it...\r\nbool mainLoopClass::informFramesPerSecond(double fps){\r\n\tlogger.logLine(\"Frames per second: %f\", true, true, true, fps);\r\n\r\n\treturn true;\r\n}// informFramesPerSecond\r\n\r\n// beforeLoop ************\r\n// Here we put whatever we should do before executing this loop.\r\nbool mainLoopClass::beforeLoop(){\r\n\treturn true;\r\n}// beforeLoop\r\n\r\n// afterLoop *************\r\n// Here we put whatever we should do after executing this loop.\r\nbool mainLoopClass::afterLoop(){\r\n\t// Free all the resources in use by switching to the null zone\r\n\tif (!switchToNullProgramZone())\r\n\t\treturn false;\r\n\r\n\treturn true;\r\n}// afterLoop\r\n\r\n// drawFrame *************\r\n// Draw the current frame on screen.\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool mainLoopClass::drawFrame()\r\n{\r\n\t// a static vector to be used in the construction of file names\r\n\t// for screenshooting\r\n\tstatic char bmpFileName[200];\r\n\r\n\t// temporary variable for the return value\r\n\tbool retval=false;\r\n\r\n\t// make sure it's all ok before drawing the frame...\r\n\t// (if it returns false, it wasn't able to restore it, neither\r\n\t// it will, as it's been a fatal error)\r\n\tif (!checkLostResources()){\r\n\t\tlogger.logLine(\"Nonrecover error when restoring resources\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// call the drawFrame function of currentProgramZone in\r\n\t// currentProgramSubZone and currentProgramSubSubZone...\r\n\tswitch(currentProgramZone){\r\n\tcase pgzon_actualGameRunning:// actual game is currently running\r\n\t\tretval=GameLoopCode::drawFrame();\r\n\t\tbreak;\r\n\tcase pgzon_gameIntro:// program intro is currently being executed\r\n\t\tretval=IntroLoopCode::drawFrame();\r\n\t\tbreak;\r\n\tcase pgzon_gameMenues:// program menues are currently being executed\r\n\t\tretval=MenuLoopCode::drawFrame();\r\n\t\tbreak;\r\n\t}// switch\r\n/*\r\n\t// draw the console in the screen (above everything else)\r\n\tdrawConsole();\r\n\r\n\t// check if we shouldn't be taking a screenshot now\r\n\tif (takeASingleScreenshot || keepTakingScreenshots){\r\n\t\t// take the screenshot\r\n\t\t#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tlogger.logLine(\"Screenshot to be taken next...\", true, false);\r\n\t\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t\t// construct the bmp file name...\r\n\t\t#define SSHOTFILENAME \"sshots\\\\sshot\"\r\n\t\t#define SSHOTFILEEXT \".bmp\"\r\n\t\twsprintf(bmpFileName, \"%s%i%s\",\r\n\t\t\tSSHOTFILENAME,\r\n\t\t\tWinUtilCode::findFreeNumberedFile\r\n\t\t\t\t(SSHOTFILENAME, SSHOTFILEEXT),\r\n\t\t\tSSHOTFILEEXT);\r\n\r\n\t\t#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tlogger.logLine(\"Filename for screenshot selected.\", true, false);\r\n\t\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t\t// save the screenshot itself\r\n\t\tDD.saveAsBmpFile(bmpFileName, true);\r\n\t\tlogger.logLine(\"Screenshot saved as \\\"%s\\\".\", true, true, true,\r\n\t\t\tbmpFileName);\r\n\r\n\t\t// clear the single screenshooting flag\r\n\t\ttakeASingleScreenshot=false;\r\n\t}// if\r\n*/\r\n\t// time to flip the screen buffers\r\n\tDD.flip();\r\n\r\n\treturn retval;\r\n}// drawFrame\r\n\r\n// executeFrame ***********\r\n// Execute a frame, without drawing it on screen. It's what I call\r\n// \"virtual frames\".\r\n// Only return false for non-recover errors.\r\nbool mainLoopClass::executeFrame(DWORD frameNumber)\r\n{\r\n\tbool retval=false;\r\n\tbool isLost;// used with dinput\r\n\r\n\t// Get the input...\r\n\t// Mouse...\r\n\tif (!mouse.getState(&isLost)){\r\n\t\tif (isLost){\r\n\t\t\t// try getting the info again, after acquiring the\r\n\t\t\t// device\r\n\t\t\tlogger.logLine(\"Mouse lost\");\r\n\t\t\tmouse.acquire();\r\n\t\t\tmouse.getState();\r\n\t\t} else {\r\n\t\t\t// any other error is bad news\r\n\t\t\tlogger.logLine(\"Mouse error\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n\t// Keyboard...\r\n\tif (!keyboard.getKeys(&isLost)){\r\n\t\tif (isLost){\r\n\t\t\t// try getting the info again, after acquiring the\r\n\t\t\t// device\r\n\t\t\tlogger.logLine(\"Keyboard lost\");\r\n\t\t\tkeyboard.acquire();\r\n\t\t\tkeyboard.getKeys();\r\n\t\t} else {\r\n\t\t\t// any other error is bad news\r\n\t\t\tlogger.logLine(\"Keyboard error\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n\r\n/*\t// check if it is time for making screenshots\r\n\tif (KEYEVENTDOWN(keyboard.keys, keyboard.latestKeys, DIK_F9)){\r\n\t\t// take a screenshot\r\n\t\t#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tlogger.logLine(\"Screenshot marked to be taken...\", true, false);\r\n\t\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t\t// mark this flag to let the drawer know we want a screenshot\r\n\t\ttakeASingleScreenshot=true;\r\n\t}// if\r\n*/\r\n\t// call the drawFrame function of currentProgramZone in\r\n\t// currentProgramSubZone and currentProgramSubSubZone...\r\n\tswitch(currentProgramZone){\r\n\tcase pgzon_actualGameRunning:// actual game is currently running\r\n\t\tretval=GameLoopCode::executeFrame(frameNumber);\r\n\t\tbreak;\r\n\tcase pgzon_gameIntro:// program intro is currently being executed\r\n\t\tretval=IntroLoopCode::executeFrame(frameNumber);\r\n\t\tbreak;\r\n\tcase pgzon_gameMenues:// program menues are currently being executed\r\n\t\tretval=MenuLoopCode::executeFrame(frameNumber);\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n        SDL_Event event;\r\n\r\n\twhile(SDL_PollEvent(&event)){\r\n\t\tswitch(event.type){\r\n\t\t\tcase SDL_QUIT:\r\n\t\t\t\texitLoop();\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn retval;\r\n}// executeFrame\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"massDeallocator.h\"// for accessing to the massDeallocator object, useful for massive deallocations\r\n\r\n// MASS DEALLOCATOR METHODS\r\n// ************************\r\n\r\n// PRIVATE ONES\r\n\r\n// genericRemoveMemAllocation *******\r\n// This method removes a memory allocation from the internal list,\r\n// with and without deallocating it\r\nbool massDeallocatorClass::genericRemoveMemAllocation(\r\n\tvoid* memory,// data to remove from the list\r\n\tbool deallocate)// deallocate it at the time it's removed?\r\n{\r\n\tallocatedNodeStruct* node;\r\n\r\n\tif (!ready) return false;// it should have been initialized previously\r\n\r\n\t// traverse the list looking for such mem object\r\n\tfor (node=memoryList;\r\n\tnode!=NULL && node->memory!=memory;\r\n\tnode++);\r\n\r\n\t// if we didn't find it, return an error value\r\n\tif (node==NULL) return false;\r\n\r\n\t// remove it from the list...\r\n\t// remove references from the previous node\r\n\tif (node->previousNode==NULL){\r\n\t\tmemoryList=node->nextNode;\r\n\t}else{\r\n\t\tnode->previousNode->nextNode=node->nextNode;\r\n\t}// if\r\n\t// remove references from the next node\r\n\tif (node->nextNode!=NULL){\r\n\t\tnode->nextNode->previousNode=node->previousNode;\r\n\t}// if\r\n\r\n\t// deallocate it if needed\r\n\tif (deallocate){\r\n\t\tif (node->oneOrMany){\r\n\t\t\t// one\r\n\t\t\tdelete (node->memory);\r\n\t\t}else{\r\n\t\t\t// many\r\n\t\t\tdelete[] (node->memory);\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// and deallocate the node information, always\r\n\tdelete node;\r\n\r\n\treturn true;// all ok\r\n}// genericRemoveMemAllocation\r\n\r\n\r\n\r\n// INITIALIZATION / DEINITIALIZATION\r\n\r\n// init *********\r\n// This method initializes the mass deallocator object\r\nbool massDeallocatorClass::init()\r\n{\r\n\tif (ready) return false;// check it's not already initialized\r\n\r\n\tready=true;\r\n\tmemoryList=NULL;\r\n\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// close *********\r\n// This method closesthe mass deallocator object\r\nbool massDeallocatorClass::close()\r\n{\r\n\tbool ok;\r\n\r\n\tif (!ready) return false;// it should have been initialized previously\r\n\r\n\t// try removing all from memory\r\n\tok=massDeallocate();\r\n\r\n\t// ok...\r\n\tready=false;\r\n\treturn ok;\r\n}// close\r\n\r\n// LIST MANAGEMENT\r\n\r\n// addMemAllocation ******\r\n// This method adds a memory allocation to the list of mem to\r\n// deallocate. It only adds it, doesn't ever allocate anything for\r\n// the caller.\r\nbool massDeallocatorClass::addMemAllocation(\r\n\tvoid* memory,// memory position of the memory object to add\r\n\tbool oneOrMany)// that is: true for an mem obj that should be later deallocated with delete; false, with delete[]\r\n{\r\n\tallocatedNodeStruct* node;\r\n\r\n\tif (!ready) return false;// it should have been initialized previously\r\n\r\n\t// create the node\r\n\tnode=new allocatedNodeStruct;\r\n\tnode->memory=memory;\r\n\tnode->oneOrMany=oneOrMany;\r\n\tnode->previousNode=NULL;\r\n\r\n\t// add the node at the beginning of the linked list\r\n\tnode->nextNode=memoryList;\r\n\tif (node->nextNode!=NULL) node->nextNode->previousNode=node;\r\n\tmemoryList=node;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// addMemAllocation\r\n\r\n// removeMemAllocation *******\r\n// This method removes a memory allocation from the internal list,\r\n// but without ever deallocating it (at least not by default, use\r\n// deallocateOne for these purposes).\r\nbool massDeallocatorClass::removeMemAllocation(\r\n\tvoid* memory)\r\n{\r\n\t// remove it from the list, without deallocating it\r\n\treturn genericRemoveMemAllocation(memory, false);\r\n}// removeMemAllocation \r\n\r\n\r\n// MEMORY MANAGEMENT\r\n\r\n// massDeallocate *******\r\n// This method deallocates all what's present in the linked list of\r\n// memory to deallocate\r\nbool massDeallocatorClass::massDeallocate()\r\n{\r\n\tallocatedNodeStruct* node;\r\n\tallocatedNodeStruct* nextNode;\r\n\r\n\tif (!ready) return false;// it should have been initialized previously\r\n\r\n\t// go through the entire list deallocating all the nodes\r\n\tfor (node=memoryList;\r\n\tnode!=NULL;\r\n\tnode=nextNode)// node=tempNode means node++\r\n\t{\r\n\t\t// deallocate that object\r\n\t\tif (node->oneOrMany){\r\n\t\t\t// one\r\n\t\t\tdelete (node->memory);\r\n\t\t}else{\r\n\t\t\t// many\r\n\t\t\tdelete[] (node->memory);\r\n\t\t}// if\r\n\r\n\t\t// remove the current node from memory, and remember which\r\n\t\t// one will be the next node\r\n\t\tnextNode=node->nextNode;\r\n\t\tdelete node;\r\n\t}\r\n\r\n\t// initialize all back as a brand new massDeallocator, ready\r\n\t// for striking back\r\n\tmemoryList=NULL;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// massDeallocate\r\n\r\n// deallocateOne *******\r\n// This method deallocates one specific memory allocation, and\r\n// removes it from the internal list.\r\nbool massDeallocatorClass::deallocateOne(void* memory)\r\n{\r\n\t// remove it from the list, and deallocate it\r\n\treturn genericRemoveMemAllocation(memory, true);\r\n}// deallocateOne\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n/*\r\nMASSDEALLOCATOR.*:\r\n(massDeallocator: an object that is used to deallocate big numbers\r\nof different memory allocations with a simple call... useful for\r\neasily avoiding memory leaks when allocating lots of objects at a\r\ntime is necessary)\r\n\r\nThese files contain the declaration of the massDeallocator object,\r\nwhich was designed to easily deallocate big numbers of different\r\nmemory allocations.\r\n\r\n*/\r\n\r\n#ifndef FILE_MASSDEALLOCATOR_INCLUDED\r\n#define FILE_MASSDEALLOCATOR_INCLUDED\r\n\r\n#define FILE_MASSDEALLOCATOR_VERSION \"28-7-2003-H\"// last modification: dd/mm/yy\r\n\r\n\r\n#include \"win-constants.h\"\r\n\r\n// ALLOCATED NODE STRUCT\r\nstruct allocatedNodeStruct{\r\n\tvoid* memory;// pointer to the memory data to deallocate\r\n\tbool oneOrMany;// that is: true for deallocating with delete; false, with delete[]\r\n\r\n\tallocatedNodeStruct* nextNode;// pointer to the next node\r\n\tallocatedNodeStruct* previousNode;// pointer to the previous node\r\n};// allocatedNodeStruct\r\n\r\n// MASS DEALLOCATOR CLASS\r\n// The massDeallocator object\r\nclass massDeallocatorClass{\r\nprivate:\r\n\tallocatedNodeStruct* memoryList;\r\n\tbool ready;\r\n\r\n\t// for using with removeMemAllocation and deallocateOne\r\n\tbool genericRemoveMemAllocation(void* memory, bool deallocate);\r\n\r\npublic:\r\n\t// constructor / destructor\r\n\tmassDeallocatorClass():ready(false){}\r\n\tvirtual ~massDeallocatorClass(){if (isReady()) close();}\r\n\r\n\t// initialization / deinitialization\r\n\tvirtual bool init();\r\n\tvirtual bool close();\r\n\r\n\t// list management\r\n\tvirtual bool addMemAllocation(void* memory, bool oneOrMany=true);\r\n\tvirtual bool removeMemAllocation(void* memory);\r\n\r\n\t// memory management\r\n\tvirtual bool massDeallocate();\r\n\tvirtual bool deallocateOne(void* memory);\r\n\r\n\t// useful stuff\r\n\tvirtual bool isReady(){return ready;}\r\n};// massDeallocatorClass\r\n\r\n#endif// FILE_MASSDEALLOCATOR_INCLUDED\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"menucode.h\"// for accesing to the methods related to the program zone corresponding to the game menues\r\n#include \"gameglobals.h\"// for using the game objects\r\n/*#include \"generalmaths.h\"// for mathematical functions*/\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include \"optionsfile.h\"// for the management of the files where the game options are saved\r\n#include \"ddwrap.h\"\r\n/*#include \"diwrap.h\"\r\n#include \"audiowrap.h\"*/\r\n#include \"console.h\"\r\n#include \"con-logger.h\"\r\n#include \"globals.h\"// for using the program objects\r\n#include \"mainloop.h\"// for accessing to the main loop object\r\n#include \"programinfo.h\"// for general info about the program itself\r\n/*#include \"soundman.h\"// for using the functions related to sound management*/\r\n#include <string.h>\r\n\r\n// VARIABLES AND FUNCTIONS\r\n// Useful variables for the obscuring stuff\r\nstatic double screenLightness;// 0 to 255, lightness factor\r\nstatic double obscuringSpeed;// how much to obscure per frame\r\nbool nowObscuring;// whether we should be obscuring the screen now, or lighting it up\r\n\r\n// Useful for knowing where the mouse is\r\nstatic int mouseX, mouseY;\r\n\r\n// this variable should only be used during the execution of\r\n// MenuLoopCode::drawFrame\r\nstatic ddSurfaceClass* screenBuffer;\r\n\r\n\r\n\r\n// *****************************\r\n// LUA INTERFACING FUNCTIONS   *\r\n// *****************************\r\n\r\n// luaResetHighScores *******\r\n// A function that resets the high scores list every time it's called\r\nint luaResetHighScores(lua_State* lstate)\r\n{\r\n\tint paramNum=lua_gettop(lstate);\r\n\r\n\t// now just reset the high scores list\r\n\tif (!optionsFileObject.highScoresOneManager->resetList())\r\n\t\treturn false;\r\n\toptionsFileObject.save();\r\n\r\n\t// log it\r\n\tlogger.logLine(\"High scores list has been reset\");\r\n\r\n\treturn 0;// there are no return values\r\n}// luaResetHighScores\r\n\r\n// luaSetSoundEnabled *******\r\n// A function to set the soundEnabled field to true or false,\r\n// as needed\r\nint luaSetSoundEnabled(lua_State* lstate)\r\n{\r\n/*\tint paramNum=lua_gettop(lstate);\r\n\tbool enabled;// should we use sound?\r\n\r\n\t// we get the parameter out of the stack\r\n\tenabled=(lua_toboolean(lstate, 1)==1?true:false);\r\n\r\n\t// now just do the change\r\n\tprogramSoundEnabled=enabled;\r\n\toptionsFileObject.getOptionsPointer()->programSoundEnabled=\r\n\t\tprogramSoundEnabled;\r\n\toptionsFileObject.save();\r\n\r\n\t// set the current sound state in lua\r\n\tscriptMan.setSoundEnabledInLua(\r\n\t\tprogramSoundEnabled, programSoundActive);\r\n\r\n\t// if called with 'soundEnabled' false, we need to stop all the\r\n\t// sounds now\r\n\tif (!enabled) stopAllSoundResources();\r\n\r\n\t// log it\r\n\tlogger.logLine(\"Sound has been switched %s\", true, false, true,\r\n\t\t(enabled?\"on\":\"off\"));\r\n*/\r\n\treturn 0;// there are no return values\r\n}// luaSetSoundEnabled\r\n\r\n// luaStopAndPlaySoundResource *******\r\n// a function that stop and plays a given sound resource\r\nint luaStopAndPlaySoundResource(lua_State* lstate)\r\n{\r\n/*\tint paramNum=lua_gettop(lstate);\r\n\tchar* soundName;\r\n\r\n\t// we get the parameters out of the stack\r\n\tsoundName=(char*)(lua_tostring(lstate, 1));\r\n\r\n\t// now just execute it\r\n\tstopAndPlaySoundResource(soundName);\r\n*/\r\n\treturn 0;// there are no return values\r\n}// luaStopAndPlaySoundResource\r\n\r\n// luaPlaySoundResource *******\r\n// a function that plays a given sound resource\r\nint luaPlaySoundResource(lua_State* lstate)\r\n{\r\n/*\tint paramNum=lua_gettop(lstate);\r\n\tchar* soundName;\r\n\tbool looping;// should the sound loop?\r\n\r\n\t// we get the parameters out of the stack\r\n\tsoundName=(char*)(lua_tostring(lstate, 1));\r\n\tlooping=(lua_toboolean(lstate, 2)==1?true:false);\r\n\r\n\t// now just execute it\r\n\tplaySoundResource(soundName, looping);\r\n*/\r\n\treturn 0;// there are no return values\r\n}// luaPlaySoundResource\r\n\r\n// luaStopSoundResource *******\r\n// a function that stops playing a given sound resource\r\nint luaStopSoundResource(lua_State* lstate)\r\n{\r\n/*\tint paramNum=lua_gettop(lstate);\r\n\tchar* soundName;\r\n\r\n\t// we get the parameter out of the stack\r\n\tsoundName=(char*)(lua_tostring(lstate, 1));\r\n\r\n\t// now just stop it\r\n\tstopSoundResource(soundName);\r\n*/\r\n\treturn 0;// there are no return values\r\n}// luaStopSoundResource\r\n\r\n// luaUpdateHighScoresList *******\r\n// a function that updates or constructs a high scores list in the\r\n// lua side\r\nint luaUpdateHighScoresList(lua_State* lstate)\r\n{\r\n\thighScoreStruct* hScore;\r\n\tint paramNum=lua_gettop(lstate);\r\n\tint i;\r\n\r\n\t// let's start pushing an emtpy table to the stack\r\n\tlua_newtable(lstate);// we call it gt\r\n\r\n\t// we traverse the high scores list\r\n\tfor (i=1; i<10; i++)// 2010 TODO\r\n\t{\r\n\t\t// i\r\n\t\tlua_pushnumber(lstate, i);\r\n\t\t// gt[i].name=name, gt[i].score=score\r\n\t\tlua_newtable(lstate);// (this will be gt[i])\r\n\t\tlua_pushstring(lstate, \"name\");\r\n\t\tlua_pushstring(lstate, \"abc\");\r\n\t\tlua_rawset(lstate, -3);\r\n\t\tlua_pushstring(lstate, \"score\");\r\n\t\tlua_pushnumber(lstate, (10-i)*3);\r\n\t\tlua_rawset(lstate, -3);\r\n\t\t// save it in the gt object too\r\n\t\tlua_rawset(lstate, -3);\r\n\t}// for// 2010 TODO\r\n/*\tfor (hScore=optionsFileObject.highScoresOneManager->\r\n\t\tgetFirstNodeHSF(), i=1;\r\n\thScore!=NULL;\r\n\thScore=optionsFileObject.highScoresOneManager->\r\n\t\tgetNextNodeHSF(hScore), i++)\r\n\t{\r\n\t\t// i\r\n\t\tlua_pushnumber(lstate, i);\r\n\t\t// gt[i].name=name, gt[i].score=score\r\n\t\tlua_newtable(lstate);// (this will be gt[i])\r\n\t\tlua_pushstring(lstate, \"name\");\r\n\t\tlua_pushstring(lstate, hScore->name);\r\n\t\tlua_rawset(lstate, -3);\r\n\t\tlua_pushstring(lstate, \"score\");\r\n\t\tlua_pushnumber(lstate, hScore->score);\r\n\t\tlua_rawset(lstate, -3);\r\n\t\t// save it in the gt object too\r\n\t\tlua_rawset(lstate, -3);\r\n\t}// for\r\n*/\r\n\t// finally, we do highScoresList=gt\r\n\tlua_setglobal(lstate, \"highScoresList\");\r\n\r\n\treturn 0;// there are no return values\r\n}// luaUpdateHighScoresList\r\n\r\n// luaSetCurrentLanguage *******\r\n// a function used for changing the current mouse position\r\nint luaSetCurrentLanguage(lua_State* lstate)\r\n{\r\n\tchar* langName;\r\n\r\n\tint paramNum=lua_gettop(lstate);\r\n\r\n\t// get the new language name\r\n\tlangName=(char*)(lua_tostring(lstate, 1));\r\n\r\n\tif (strcmp(langName, \"spanish\")==0){\r\n\t\tcurrentLanguage=language_spanish;\r\n\t}else if (strcmp(langName, \"english\")==0){\r\n\t\tcurrentLanguage=language_english;\r\n\t}else{\r\n\t\t// nothing to do if lang name is not specified correctly\r\n\t}// if\r\n\r\n\t// set the language in lua\r\n\tscriptMan.setCurrentLanguageInLua(currentLanguage);\r\n\r\n\t// save the change in the options file\r\n\toptionsFileObject.getOptionsPointer()->selectedLanguage=\r\n\t\tcurrentLanguage;\r\n\toptionsFileObject.save();\r\n\r\n\t// log it\r\n\tlogger.logLine(\"Language been switched to %s\", true, false, true,\r\n\t\tlangName);\r\n\r\n\treturn 0;// there are no return values\r\n}// luaSetCurrentLanguage\r\n\r\n// luaMenuSetMouseXY *******\r\n// a function used for changing the current mouse position\r\nint luaMenuSetMouseXY(lua_State* lstate)\r\n{\r\n\tint paramNum=lua_gettop(lstate);\r\n\r\n\t// get the new mouse coordinates\r\n\tmouseX=(int)(lua_tonumber(lstate, 1));\r\n\tmouseY=(int)(lua_tonumber(lstate, 2));\r\n\t\r\n\treturn 0;// there are no return values\r\n}// luaMenuSetMouseXY\r\n\r\n// luaSwitchToMenu *******\r\n// a function used for switching the current menu\r\nint luaSwitchToMenu(lua_State* lstate)\r\n{\r\n\tchar* menuName;\r\n\tint errCode;\r\n\r\n\tint paramNum=lua_gettop(lstate);\r\n\r\n\t// get the menu name...\r\n\tmenuName=(char*)(lua_tostring(lstate, 1));\r\n\t\r\n\t// execute the lua code that manages menu switching\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"cpp_switchToMenu\");\r\n\tlua_pushstring(lstate, menuName);\r\n\terrCode=lua_pcall(lstate, 1, 0, -3);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over cpp_switchToMenu\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// now check for the actions related to the different menus...\r\n\tif (strcmp(menuName, \"startGame_pseudoMenu\")==0){\r\n\t\t// make it go start the game\r\n\t\tgameWorld.playersToStart=1;// let's start with only one player\r\n\t\t// go to the game itself\r\n\t\tif (!switchToProgramZone(pgzon_actualGameRunning,\r\n\t\t\tgmzon_classicZone, 0, true)) return false;\r\n\t} else if (strcmp(menuName, \"exitingMenu\")==0){\r\n\t\t// start obscuring all down\r\n\t\tnowObscuring=true;\r\n\t}// if\r\n\r\n\treturn 0;// there are no return values\r\n}// luaSwitchToMenu\r\n\r\n// luaMenuBltImage *******\r\n// a function used for blting from a Lua script to the screen\r\nint luaMenuBltImage(lua_State* lstate)\r\n{\r\n\tddSurfaceClass* surface;\r\n\r\n\tint paramNum=lua_gettop(lstate);\r\n\r\n\tint xD, yD, xS, yS, wS, hS;\r\n\tbool transparent;\r\n\tchar* srfName;\r\n\r\n\t// check which version of the function is being called\r\n\tswitch(paramNum){\r\n\tcase 4:\r\n\t\t// short version\r\n\t\t// params, in the same order they should be\r\n\t\t// passed to the program\r\n\t\tsrfName=(char*)(lua_tostring(lstate, 1));\r\n\t\txD=int(lua_tonumber(lstate, 2));\r\n\t\tyD=int(lua_tonumber(lstate, 3));\r\n\t\ttransparent=lua_toboolean(lstate, 4)==1?true:false;\r\n\r\n\t\t// look for the surface...\r\n\t\tsurface=getSurfaceByResourceName(srfName);\r\n\r\n\t\t// go draw it...\r\n\t\tscreenBuffer->bltFrom(\r\n\t\t\t*surface, xD, yD, true, transparent);\r\n\r\n\t\tbreak;\r\n\tcase 8:\r\n\t\t// long version\r\n\t\t// params, in the same order they should be\r\n\t\t// passed to the program\r\n\t\tsrfName=(char*)(lua_tostring(lstate, 1));\r\n\t\txD=int(lua_tonumber(lstate, 2));\r\n\t\tyD=int(lua_tonumber(lstate, 3));\r\n\t\txS=int(lua_tonumber(lstate, 4));\r\n\t\tyS=int(lua_tonumber(lstate, 5));\r\n\t\twS=int(lua_tonumber(lstate, 6));\r\n\t\thS=int(lua_tonumber(lstate, 7));\r\n\t\ttransparent=lua_toboolean(lstate, 8)==1?true:false;\r\n\r\n\t\t// look for the surface...\r\n\t\tsurface=getSurfaceByResourceName(srfName);\r\n\r\n\t\t// go draw it...\r\n\t\tscreenBuffer->bltFrom(\r\n\t\t\t*surface, xD, yD, xS, yS, wS, hS, true, transparent);\r\n\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\treturn 0;// there are no return values\r\n}// luaMenuBltImage\r\n\r\n// luaMenuDrawText *******\r\n// a function used for drawing a text from a Lua script to the screen\r\nint luaMenuDrawText(lua_State* lstate)\r\n{\r\n\t// useful variables...\r\n\tchar* fontName;\r\n\tchar* text;\r\n\tfixedFontClass* font;\r\n\tint x, y, boxWidth, boxHeight;\r\n\talignEnum h_align;\r\n\tvalignEnum v_align;\r\n\tchar* alignvTmp;\r\n\tchar* alignhTmp;\r\n\r\n\r\n\t// get the parameters, in the order they should have been sent\r\n\tfontName=(char*)(lua_tostring(lstate, 1));\r\n\ttext=(char*)(lua_tostring(lstate, 2));\r\n\tx=int(lua_tonumber(lstate, 3));\r\n\ty=int(lua_tonumber(lstate, 4));\r\n\tboxWidth=int(lua_tonumber(lstate, 5));\r\n\tboxHeight=int(lua_tonumber(lstate, 6));\r\n\talignhTmp=(char*)(lua_tostring(lstate, 7));\r\n\talignvTmp=(char*)(lua_tostring(lstate, 8));\r\n\r\n\t// select the asked font\r\n\tif (strcmp(fontName, \"ediaFont\")==0){\r\n\t\tfont=&fntEdiaFont;\r\n\t}else if (strcmp(fontName, \"ediaBigFont\")==0){\r\n\t\tfont=&fntEdiaBigFont;\r\n\t}else if (strcmp(fontName, \"dahFont\")==0){\r\n\t\tfont=&fntDahFont;\r\n\t}else {\r\n\t\t// default\r\n\t\tfont=&fntDahFont;\r\n\t}// if\r\n\r\n\t// select the asked h align\r\n\tif (strcmp(alignhTmp, \"left\")==0){\r\n\t\th_align=FILE_DDWRAP_ALIGN_LEFT;\r\n\t}else if (strcmp(alignhTmp, \"right\")==0){\r\n\t\th_align=FILE_DDWRAP_ALIGN_RIGHT;\r\n\t}else if (strcmp(alignhTmp, \"center\")==0){\r\n\t\th_align=FILE_DDWRAP_ALIGN_CENTER;\r\n\t}else {\r\n\t\t// default\r\n\t\th_align=FILE_DDWRAP_ALIGN_LEFT;\r\n\t}// if\r\n\r\n\t// select the asked v align\r\n\tif (strcmp(alignvTmp, \"top\")==0){\r\n\t\tv_align=FILE_DDWRAP_VALIGN_TOP;\r\n\t}else if (strcmp(alignvTmp, \"bottom\")==0){\r\n\t\tv_align=FILE_DDWRAP_VALIGN_BOTTOM;\r\n\t}else if (strcmp(alignvTmp, \"center\")==0){\r\n\t\tv_align=FILE_DDWRAP_VALIGN_CENTER;\r\n\t}else {\r\n\t\t// default\r\n\t\tv_align=FILE_DDWRAP_VALIGN_TOP;\r\n\t}// if\r\n\r\n\t// draw the text\r\n\tfont->drawMultilineText(\r\n\t\t*screenBuffer, text, strlen(text), x, y,\r\n\t\tboxWidth, boxHeight, true, h_align, v_align);\r\n\r\n\treturn 0;// there are no return values\r\n}// luaMenuDrawText\r\n\r\n\r\n\r\n// *****************************\r\n// MAIN FUNCTIONS\r\n// Addressed as MenuLoopCode::*\r\n// *****************************\r\n\r\n\r\n// THE MAIN CODE\r\n// drawFrame *************\r\n// Draw the current frame on screen.\r\n// Only return false for non-recover errors (not for lost surfaces,\r\n// for example).\r\nbool MenuLoopCode::drawFrame()\r\n{\r\n\tlua_State* lstate;\r\n\tint errCode;\r\n\r\n\t// let's see whether we need a buffer or not\r\n\tif (screenLightness==255){\r\n\t\t// we don't need that buffer\r\n\t\tscreenBuffer=&DD;\r\n\t}else{\r\n\t\t// we need the buffer\r\n\t\tscreenBuffer=getSurfaceByResourceName(\"srfScreenSizedBuffer\");\r\n\t}// if\r\n\r\n\t// REVISE LATER BEGIN\r\n\t// first go and black all down\r\n\tscreenBuffer->fillAllDword(0);\r\n\t// REVISE LATER END\r\n\r\n\t// DRAW THE SCREEN FOR THE MAIN MENU\r\n\t// execute the lua code that manages menu drawing\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"drawFrame\");\r\n\terrCode=lua_pcall(lstate, 0, 0, -2);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over drawFrame\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// let's see whether we used the buffer or not, and manage the\r\n\t// light of the screen\r\n\tif (screenLightness!=255){\r\n\t\t// we used it, so let's blt it to the screen\r\n\t\tDD.obscuredBltFrom(*screenBuffer,// surface\r\n\t\t\t0, 0,// coordinates\r\n\t\t\t(unsigned char)(screenLightness),// lightness\r\n\t\t\tfalse);// transparent?\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// drawFrame\r\n\r\n// executeFrame ***********\r\n// Execute a frame, without drawing it on screen. It's what I call\r\n// \"virtual frames\".\r\n// Only return false for non-recover errors.\r\nbool MenuLoopCode::executeFrame(DWORD frameNumber)\r\n{\r\n\tlua_State* lstate;\r\n\tint errCode;\r\n\r\n\tbool keyPreviousPressed=false;\r\n\tbool keyNextPressed=false;\r\n\tbool keyClickPressed=false;\r\n\tbool mouseClickPressed=false;\r\n\r\n/*\t// CHECK FOR KEYS\r\n\t// check if it's time to change the currently selected menu option\r\n\t// Go up...\r\n\tif ((KEYDOWN(keyboard.keys, DIK_UP) ||\r\n\t\tKEYDOWN(keyboard.keys, DIK_LEFT))\r\n\t\t&& !isCurrentlyTypingNameHS && !showConsole){\r\n\r\n\t\tkeyPreviousPressed=true;\r\n\t}// if\r\n\t// Go down...\r\n\tif ((KEYDOWN(keyboard.keys, DIK_DOWN) ||\r\n\t\tKEYDOWN(keyboard.keys, DIK_RIGHT))\r\n\t\t&& !isCurrentlyTypingNameHS && !showConsole){\r\n\r\n\t\tkeyNextPressed=true;\r\n\t}// if\r\n\t// Check for selected buttons or mouse buttons\r\n\tif ((KEYDOWN(keyboard.keys, DIK_SPACE) ||// space key\r\n\t\tKEYDOWN(keyboard.keys, DIK_LCONTROL) ||// left control key\r\n\t\tKEYDOWN(keyboard.keys, DIK_RETURN))// return key\r\n\t\t&& !isCurrentlyTypingNameHS && !showConsole){\r\n\r\n\t\tkeyClickPressed=true;\r\n\t}// if*/\r\n\tif ((MOUSEDOWN(mouse.mouseData, MOUSE_BUTTON_LEFT))// left mouse button\r\n\t\t&& !isCurrentlyTypingNameHS){\r\n\r\n\t\t// mouse click\r\n\t\tmouseClickPressed=true;\r\n\t}// if\r\n\r\n\t// Check it has moved at all\r\n\tif (MOUSEX(mouse.mouseData)!=0 || MOUSEY(mouse.mouseData)){\r\n\t\t// Get the current mouse position\r\n\t\tmouseX+=MOUSEX(mouse.mouseData);\r\n\t\tif (mouseX<0) mouseX=0;\r\n\t\tif (mouseX>=DD.getWidth()-1) mouseX=DD.getWidth()-1;\r\n\t\tmouseY+=MOUSEY(mouse.mouseData);\r\n\t\tif (mouseY<0) mouseY=0;\r\n\t\tif (mouseY>=DD.getHeight()-1) mouseY=DD.getHeight()-1;\r\n\t}// if\r\n\r\n\t// LUA EXECUTE FRAME\r\n\t// execute the lua code that manages frame execution\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"executeFrame\");\r\n\tlua_pushnumber(lstate, frameNumber);\r\n\tlua_pushnumber(lstate, mouseX);\r\n\tlua_pushnumber(lstate, mouseY);\r\n\tlua_pushboolean(lstate, mouseClickPressed);\r\n\tlua_pushboolean(lstate, keyPreviousPressed);\r\n\tlua_pushboolean(lstate, keyNextPressed);\r\n\tlua_pushboolean(lstate, keyClickPressed);\r\n\terrCode=lua_pcall(lstate, 7, 0, -9);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over executeFrame\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// THE ALPHA BLENDING THING\r\n\tif (nowObscuring){\r\n\t\t// go obscure the screen\r\n\t\tscreenLightness-=obscuringSpeed;\r\n\t\tif (screenLightness<=0){\r\n\t\t\t// finished lighting down? should execute some\r\n\t\t\t// obscuring event... for now we just go away\r\n\t\t\tscreenLightness=0;\r\n\t\t\t// first obscure all the buffers of the screen\r\n\t\t\tif (DD.isReady() && DD.isVideoModeReady()){\r\n\t\t\t\tint i;\r\n\r\n\t\t\t\tfor (i=0; i<DD.getBackBuffersCount(); i++){\r\n\t\t\t\t\tDD.fillAllDword(0); DD.flip();\r\n\t\t\t\t}// for\r\n\t\t\t}// if\r\n\t\t\t// bye bye\r\n\t\t\tif (!globalExit())\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t}else{\r\n\t\t// anywhere else from the exiting menu, light screen up\r\n\t\tscreenLightness+=obscuringSpeed;\r\n\t\tif (screenLightness>=255) screenLightness=255;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// executeFrame\r\n\r\n// beforeLoop **********\r\n// This is the code to be executed every time a program zone linked to\r\n// these functions is switched to.\r\nbool MenuLoopCode::beforeLoop()\r\n{\r\n\tlua_State* lstate;\r\n\tint errCode;\r\n\tchar* menuToSwitch;\r\n\r\n\t// before starting, stop all the playing sounds (belonging to other\r\n/*\t// program zones)\r\n\tif (!stopAllSoundResources()) return false;\r\n*/\r\n\t// calculate the obscuring stuff\r\n\t// light all up in 1 second\r\n\tobscuringSpeed=(255/double(desiredFramesPerSecond))/1;\r\n\t// light the screen slowly only when coming from the intro\r\n\tif (previousProgramZone==pgzon_gameIntro){\r\n\t\t// go slowly\r\n\t\tscreenLightness=0;\r\n\t}else{\r\n\t\t// make it be already lightened\r\n\t\tscreenLightness=255;\r\n\t}// if\r\n\r\n\t// give the mouse cursor an initial position\r\n\tmouseX=0;\r\n\tmouseY=0;\r\n\r\n\t// EXECUTE THE LUA BEFORE LOOP\r\n\t// execute the lua code that manages the before loop\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"beforeLoop\");\r\n\terrCode=lua_pcall(lstate, 0, 0, -2);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over beforeLoop\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// Now switch to a valid menu, first let's see which one to switch\r\n\t// to...\r\n\tif (isCurrentlyTypingNameHS){\r\n\t\t// We are typing a high score entry, time to go to the hs\r\n\t\t// entry menu\r\n\t\tmenuToSwitch=\"highScoresMenu\";\r\n\t}else{\r\n#ifdef PROGMODE_SCREENSHOTS_DEMO_YES// is this a screenshots demo or not?\r\n\t\t// Time to go to the screenshots menu\r\n\t\tmenuToSwitch=\"screenshotsMenu\";\r\n#else // that is, PROGMODE_SCREENSHOTS_DEMO_NO\r\n\t\t// Time to go to the main menu\r\n\t\tmenuToSwitch=\"mainMenu\";\r\n#endif// that is, PROGMODE_SCREENSHOTS_DEMO_NO\r\n\t}// if\r\n\t// EXECUTE THE LUA SWITCH TO MENU\r\n\t// execute the lua code that manages the menu switching\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"switchToMenu\");\r\n\tlua_pushstring(lstate, menuToSwitch);\r\n\terrCode=lua_pcall(lstate, 1, 0, -3);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over switchToMenu\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\r\n\treturn true;// all ok\r\n}// beforeLoop\r\n\r\n\r\n// afterLoop ***********\r\n// This is the code to be executed every time it's time to switch to\r\n// another program zone, being a program zone currently linked to\r\n// these functions.\r\nbool MenuLoopCode::afterLoop()\r\n{\r\n\tlua_State* lstate;\r\n\tint errCode;\r\n\r\n\t// the player cannot be typing his name still\r\n\tisCurrentlyTypingNameHS=false;// tells whether the player is currently typing his name for the high score list or not\r\n\thighScoreToTypeIn=NULL;// pointer to the node in the high scores list where to type in\r\n\r\n\t// EXECUTE THE LUA AFTER LOOP\r\n\t// execute the lua code that manages the after loop\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"afterLoop\");\r\n\terrCode=lua_pcall(lstate, 0, 0, -2);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over afterLoop\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// afterLoop\r\n\r\n\r\n// *****************\r\n// EXTRA FUNCTIONS *\r\n// *****************\r\n\r\n// executeHighScoreTyping ************\r\n// This function manages the process of receiving a key hit and making\r\n// it go to the name of the high scores list currently under edition.\r\nbool executeHighScoreTyping(char key)\r\n{\r\n\tchar* currentChar;\r\n\tlua_State* lstate;\r\n\tint errCode;\r\n\r\n\t// calculate the position for the next character\r\n\tcurrentChar=highScoreToTypeIn->name+\r\n\t\tstrlen(highScoreToTypeIn->name);\r\n\r\n\t// check for backspace\r\n\tif (key=='\\b'){\r\n\t\tif (strlen(highScoreToTypeIn->name)<=1) return true;// all ok\r\n\t\t*(currentChar-2)='_';\r\n\t\t*(currentChar-1)=0;\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// check for enter\r\n\tif (key=='\\r'){\r\n\t\t// no more name typing\r\n\t\tisCurrentlyTypingNameHS=false;// tells whether the player is currently typing his name for the high score list or not\r\n\t\t*(currentChar-1)=0;// remove the '_'\r\n\t\tlogger.logLine(\"Last high score name: %s\", true, false, true,\r\n\t\t\thighScoreToTypeIn->name);\r\n\t\tif (!optionsFileObject.save())\r\n\t\t\tlogger.logLine(\"Couldn't save high score\");\r\n\r\n\t\t// there is no need to manually go to the main menu...\r\n\t\t// it will go anyway\r\n\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// Any other key, just type it in.\r\n\t// Don't let the text grow too much:\r\n\t// (Consider there is a _ letter occupying a space)\r\n\tif (strlen(highScoreToTypeIn->name)>=\r\n\t\tFILE_HSCORES_SCORES_ONE_VIRTUAL_NAMELEN) return true;// all ok\r\n\t// type it in\r\n\t*(currentChar-1)=key;\r\n\t*(currentChar)='_';\r\n\t*(currentChar+1)=0;\r\n\r\n\r\n\t// EXECUTE THE LUA UPDATE HIGH SCORES LIST\r\n\t// execute the lua code that makes the system update its\r\n\t// high scores list\r\n\tlstate=scriptMan.getLuaObject();\r\n\tlua_getglobal(lstate, \"errorManager\");\r\n\tlua_getglobal(lstate, \"updateHighScoresList\");\r\n\terrCode=lua_pcall(lstate, 0, 0, -2);\r\n\tlua_pop(lstate, 1);// take errorManager off the stack\r\n\tif (errCode!=0){\r\n\t\tlua_pop(lstate,1);// there is an extra value there...\r\n\t\tlogger.logLine(\"Error calling pcall over updateHighScoresList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// executeHighScoreTyping\r\n\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"optionsfile.h\"// for the management of the files where the game options are saved\r\n/*#include \"winutil.h\"// for accessing to some useful functions related to low level windows specific code*/\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n/*#include \"gamedata.h\"// data types of this game*/\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include <string.h>\r\n\r\n#define FILE_OPTIONSFILE_OPTIONSFILENAME \"data/gamedata.dat\"\r\n\r\n// HIGH SCORES MANAGER CLASS\r\n\r\n// init ************\r\n// Initializes the object...\r\nbool highScoresManagerClass::init(\r\n\thighScoreStruct* hScoresList,// pointer to a list of high scores\r\n\tint listSize)// size of such list\r\n{\r\n\tif (initialized) return false;\r\n\r\n\t// initialize all...\r\n\thighScoresManagerClass::hScoresList=hScoresList;\r\n\thighScoresManagerClass::listSize=listSize;\r\n\r\n\t// all ok\r\n\tinitialized=true;\r\n\treturn true;\r\n}// init\r\n\r\n// end ************\r\n// Deinitializes the object...\r\nbool highScoresManagerClass::end()\r\n{\r\n\tif (!initialized) return false;\r\n\r\n\t// deinitialize all...\r\n\t// (nothing to do here, yet)\r\n\r\n\t// all ok\r\n\tinitialized=false;\r\n\treturn true;\r\n}// end\r\n\r\n// resetList ************\r\n// Resets the lists of high scores (assigns default values to all the\r\n// nodes)\r\nbool highScoresManagerClass::resetList()\r\n{\r\n\tint i;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// go through the entire list\r\n\tfor (i=0; i<listSize; i++){\r\n\t\t// assign a default value to every node\r\n\t\thScoresList[i].score=(i+1)*1500+(i-4>0?i-4:0)*3000;\r\n\t\tstrcpy(hScoresList[i].name, \"Anonymous\");\r\n\t}// for\r\n\r\n\treturn true;// all ok\r\n}// resetList\r\n\r\n// getLastNodeHSF ************\r\n// Used a lot for adding nodes. When adding a node, some other node\r\n// is supposed to be taken out of the list (as it's fixedly sized), and\r\n// this node to be taken out, in a typical high scores list, is the one\r\n// with the lowest score, so the latest in a higher score first (HSF)\r\n// list. So we use, instead of addNode, this method to take the latest\r\n// node and modify it.\r\n// The next node of the last node is NULL.\r\nhighScoreStruct* highScoresManagerClass::getLastNodeHSF()\r\n{\r\n\thighScoreStruct* lastNode;\r\n\thighScoreStruct* tempNode;\r\n\r\n\t// get lastNode to point to the latest node in HSF order\r\n\t// (when that's done, tempNode will point to NULL)\r\n\tlastNode=NULL;\r\n\tfor (tempNode=getFirstNodeHSF(); tempNode!=NULL;\r\n\t\tlastNode=tempNode, tempNode=getNextNodeHSF(tempNode));\r\n\t;// just to correct indentation\r\n\r\n\t// ready (lastNode will be NULL in the case of error)\r\n\treturn lastNode;\r\n}// getLastNodeHSF\r\n\r\n// getFirstNodeHSF ************\r\n// Returns a pointer to the first node of the high scores list, in\r\n// Higher Score First order (so the node returned is the one with the\r\n// highest score).\r\n// If there are two nodes with the same score, and it's the highest\r\n// score available, the choosen node is the one with the lowest index.\r\nhighScoreStruct* highScoresManagerClass::getFirstNodeHSF()\r\n{\r\n\tint i;\r\n\tint hSIdx;// highest score index\r\n\r\n\tif (!initialized) return NULL;\r\n\r\n\t// check for empty lists...\r\n\tif (listSize<=0) return NULL;\r\n\r\n\t// look for the index of the node with the highest score\r\n\tfor (i=0, hSIdx=i; i<listSize; i++){\r\n\t\tif (hScoresList[i].score>hScoresList[hSIdx].score){\r\n\t\t\t// we found a higher score!\r\n\t\t\thSIdx=i;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\t// ready\r\n\treturn &(hScoresList[hSIdx]);\r\n}// getFirstNodeHSF\r\n\r\n// getNextNodeHSF ************\r\n// Returns a pointer to the next node of the high scores list, in\r\n// Higher Score First order, since a given node.\r\n// If there are two nodes with the same score, and both are supposed\r\n// to be the next node, the first node to be visited will be the one with\r\n// the lowest index.\r\n// The next node of the last node is NULL.\r\nhighScoreStruct* highScoresManagerClass::getNextNodeHSF(\r\n\thighScoreStruct* since)// node where to start counting\r\n{\r\n\tint i;\r\n\tint hSIdx, hSIdx2;// highest score index\r\n\tint sinceIndex=since-hScoresList;\r\n\r\n\tif (!initialized) return NULL;\r\n\r\n\t// check for empty lists and other easy stuff...\r\n\tif (listSize<=0) return NULL;\r\n\tif (since==NULL) return NULL;\r\n\t// check for list boundaries\r\n\tif (sinceIndex<0 || sinceIndex>=listSize) return NULL;\r\n\r\n\t// look for the index of the node with the highest score, in the\r\n\t// half next to the 'since' index\r\n\tfor (i=sinceIndex+1, hSIdx=-1; i<listSize; i++){\r\n\t\tif ((hSIdx<0 || hScoresList[i].score>hScoresList[hSIdx].score)\r\n\t\t\t&& hScoresList[i].score<=since->score){\r\n\r\n\t\t\t// we found a higher score!\r\n\t\t\thSIdx=i;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\t// look for the index of the node with the highest score, in the\r\n\t// half previous to the 'since' index\r\n\t// (note here we compare \"hScoresList[i].score<since->score\",\r\n\t// with a lower-only sign, as if the next node has a lower\r\n\t// index than since has, then it cannot have the same score\r\n\t// _never_, according to the way equal scores are ordered).\r\n\tfor (i=0, hSIdx2=-1; i<sinceIndex; i++){\r\n\t\tif ((hSIdx2<0 ||\r\n\t\t\t\thScoresList[i].score>hScoresList[hSIdx2].score)\r\n\t\t\t&& hScoresList[i].score<since->score){\r\n\r\n\t\t\t// we found a higher score!\r\n\t\t\thSIdx2=i;\r\n\t\t}// if\r\n\t}// for\r\n\r\n\t// now choose between hSIdx and hSIdx2, the right value will be put\r\n\t// in hSIdx\r\n\t// check for error values\r\n\tif (hSIdx<0 || hSIdx==sinceIndex ||\r\n\t\thScoresList[hSIdx].score>since->score ||\r\n\t\thSIdx>=listSize) hSIdx=-1;\r\n\tif (hSIdx2<0 || hSIdx2==sinceIndex ||\r\n\t\thScoresList[hSIdx2].score>since->score ||\r\n\t\thSIdx2>=listSize) hSIdx2=-1;\r\n\tif (hSIdx==-1) hSIdx=hSIdx2;\r\n\t// now check hSIdx2 should be put in hSIdx: it has to be put there\r\n\t// only if it's strictly bigger than the highest value in the\r\n\t// right side of the list\r\n\t// Cases ('left' means 'left score', that is, hSIdx.score):\r\n\t// 1- Left (hSIdx2) is lower than right (hSIdx), then hSIdx=hSIdx.\r\n\t// (trivial)\r\n\t// 2- Right (hSIdx) is lower than left (hSIdx2), then hSIdx=hSIdx2.\r\n\t// (trivial)\r\n\tif (hSIdx2!=-1 && hSIdx!=1  &&\r\n\t\t(hScoresList[hSIdx2].score>hScoresList[hSIdx].score))\r\n\t\thSIdx=hSIdx2;\r\n\t// 3- Left (hSIdx2) is equal to right (hSIdx), then there are two\r\n\t// cases:\r\n\t// a- hSIdx==since, then hSIdx=hSIdx (because hSIdx2 has supposedly\r\n\t// been used before)\r\n\t// b- hSIdx!=since, then hSIdx=hSIdx2 (because it's before)\r\n\tif (hSIdx2!=-1 && hSIdx!=1  &&\r\n\t\t(since->score!=hSIdx2) &&\r\n\t\t(hScoresList[hSIdx2].score==hScoresList[hSIdx].score))\r\n\t\thSIdx=hSIdx2;\r\n\r\n\t// check to see if we found such next node or not (that is, check\r\n\t// all erroneous values of hSIdx)\r\n\tif (hSIdx<0){\r\n\r\n\t\t// node not found\r\n\t\treturn NULL;\r\n\t}// if\r\n\r\n\t// ready\r\n\treturn &(hScoresList[hSIdx]);\r\n}// getNextNodeHSF\r\n\r\n\r\n// OPTIONS FILE CLASS\r\n\r\n// init ************\r\n// Initializes the object...\r\nbool optionsFileClass::init()\r\n{\r\n\tif (initialized) return false;\r\n\r\n\t// initialize all...\r\n\toptions=new optionsStruct;\r\n\r\n\t// initialize the high scores lists\r\n\thighScoresOneManager=new highScoresManagerClass;\r\n\tif (!highScoresOneManager->init(\r\n\t\toptions->highScoresOne,// list of high scores\r\n\t\tFILE_HSCORES_SCORES_ONE_MAXNAMES))// list size\r\n\t{\r\n\t\t// error!\r\n\t\tdelete[] options;\r\n\t\tdelete[] highScoresOneManager;\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// all ok\r\n\tinitialized=true;\r\n\treturn true;\r\n}// init\r\n\r\n// end ************\r\n// Deinitializes the object...\r\nbool optionsFileClass::end()\r\n{\r\n\tif (!initialized) return false;\r\n\r\n\t// deinitialize all...\r\n\thighScoresOneManager->end();\r\n\tdelete[] highScoresOneManager;\r\n\tdelete[] options;\r\n\r\n\t// all ok\r\n\tinitialized=false;\r\n\treturn true;\r\n}// end\r\n\r\n// load ************\r\n// Loads the options from the file...\r\nbool optionsFileClass::load()\r\n{\r\n/*\tHANDLE hFile;\r\n\tDWORD fileSize;\r\n\tDWORD dataSize=sizeof(optionsStruct);\r\n\tDWORD bytesRead=0;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// Open the file for reading (it has to exist)\r\n\tif ((hFile=CreateFile(\r\n\t\tFILE_OPTIONSFILE_OPTIONSFILENAME,//name of the file\r\n\t\tGENERIC_READ,//desired access\r\n\t\tFILE_SHARE_READ,//share mode\r\n\t\tNULL,//security attributes\r\n\t\tOPEN_EXISTING,//creation disposition\r\n\t\tFILE_ATTRIBUTE_NORMAL,//flags and attr\r\n\t\tNULL)//template file\r\n\t\t)==INVALID_HANDLE_VALUE)\r\n\r\n\t\treturn false;\r\n\r\n\t// check the file size is enough\r\n\tfileSize=GetFileSize(hFile,NULL);\r\n\tif (fileSize==0xFFFFFFFF || fileSize<dataSize){\r\n\r\n\t\t// failed\r\n\t\tCloseHandle(hFile);\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// read the data to the options structure\r\n\tdo {\r\n\t\tif (0==ReadFile(\r\n\t\t\thFile,// the file\r\n\t\t\t((BYTE*)options)+bytesRead,// where to read to\r\n\t\t\tdataSize,// how many bytes to read\r\n\t\t\t&bytesRead,// where to tell how many bytes have been read\r\n\t\t\tNULL))// overlapped?\r\n\t\t{\r\n\r\n\t\t\t// failed\r\n\t\t\tCloseHandle(hFile);\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t}while(bytesRead<dataSize);\r\n\r\n\t// that's all\r\n\tCloseHandle(hFile);\r\n\r\n\t// time to decrypt and authenticate what we took from the file\r\n\tif (!decrypt() || !checkAuthenticity()) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// load\r\n\r\n// save ************\r\n// Saves the options data to the options file...\r\nbool optionsFileClass::save()\r\n{\r\n/*\tHANDLE hFile;\r\n\tDWORD dataSize=sizeof(optionsStruct);\r\n\tDWORD bytesWritten=0;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// first, time to crypt and set the authenticity of\r\n\t// the data\r\n\tif (!setAuthenticityNumber() || !crypt()) return false;\r\n\r\n\t// Open the file for writing (it must not exist)\r\n\tif ((hFile=CreateFile(\r\n\t\tFILE_OPTIONSFILE_OPTIONSFILENAME,//name of the file\r\n\t\tGENERIC_WRITE,//desired access\r\n\t\t0,//share mode\r\n\t\tNULL,//security attributes\r\n\t\tCREATE_ALWAYS,//creation disposition\r\n\t\tFILE_ATTRIBUTE_NORMAL,//flags and attr\r\n\t\tNULL)//template file\r\n\t\t)==INVALID_HANDLE_VALUE)\r\n\r\n\t\treturn false;\r\n\r\n\t// write the options structure to the file\r\n\tdo {\r\n\t\tif (0==WriteFile(\r\n\t\t\thFile,// the file\r\n\t\t\t((BYTE*)options)+bytesWritten,// where to read to\r\n\t\t\tdataSize,// how many bytes to read\r\n\t\t\t&bytesWritten,// where to tell how many bytes have been read\r\n\t\t\tNULL))// overlapped?\r\n\t\t{\r\n\r\n\t\t\t// failed\r\n\t\t\tCloseHandle(hFile);\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t}while(bytesWritten<dataSize);\r\n\r\n\t// that's all\r\n\tCloseHandle(hFile);\r\n\r\n\t// now we wrote the structure, we can decrypt it again\r\n\tif (!decrypt()) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// save\r\n\r\n// createFileIfNeeded ************\r\n// Checks whether the options file exists or not, and if it does not\r\n// exist, it creates such file\r\nbool optionsFileClass::createFileIfNeeded()\r\n{\r\n/*\tbool errCode;\r\n\tbool exists;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// check the file exists\r\n\texists=WinUtilCode::fileExists(\r\n\t\tFILE_OPTIONSFILE_OPTIONSFILENAME, &errCode);\r\n\tif (!errCode) return false;\r\n\r\n\t// if the file exists, it's time to go out\r\n\tif (exists) return true;\r\n\r\n\t// otherwise, create it new\r\n\tif (!resetOptions() || !save()) return false;\r\n*/\r\n\t// that's all, and all has been ok\r\n\treturn true;\r\n}// createFileIfNeeded\r\n\r\n// resetOptions ************\r\n// This method resets all the data of the options structure, so they\r\n// have the default values.\r\nbool optionsFileClass::resetOptions()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// first zero all the data\r\n\tmemset(options, 0, sizeof(*options));\r\n\r\n\t// set all up (but don't touch authentication data)\r\n\toptions->header='OH';// the header HO, from HHM's Options\r\n\toptions->usedTimeSeconds=0;// time, in seconds, the program has been used\r\n\r\n\t// Set the default language according to the program info\r\n\t#ifdef PROGMODE_DEFAULTLANGUAGE_SPANISH\r\n\t\toptions->selectedLanguage=language_spanish;\r\n\t#else// PROGMODE_DEFAULTLANGUAGE_ENGLISH\r\n\t\toptions->selectedLanguage=language_english;\r\n\t#endif// PROGMODE_DEFAULTLANGUAGE_SPANISH\r\n\r\n\t// Set sound to be active initially\r\n\toptions->programSoundEnabled=true;\r\n\r\n\t// reset the high scores...\r\n\tif (!highScoresOneManager->resetList()) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// resetOptions\r\n\r\n// crypt ************\r\n// This method crypts all the data in the options structure.\r\nbool optionsFileClass::crypt()\r\n{\r\n/*\tBYTE* thisByte;\r\n\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\t// don't crypt anything\r\n\treturn true;\r\n#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// crypt all... (typical xor)\r\n\tfor (thisByte=(BYTE*)options;\r\n\tthisByte-(BYTE*)options<sizeof(optionsStruct);\r\n\tthisByte++)\r\n\t\t(*thisByte)=(*thisByte)^1;\r\n*/\r\n\treturn true;// all ok\r\n}// crypt\r\n\r\n// decrypt ************\r\n// This method decrypts all the data in the options structure.\r\nbool optionsFileClass::decrypt()\r\n{\r\n/*\tBYTE* thisByte;\r\n\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\t// don't decrypt anything, unless strictly necessary\r\n\t// That is: developer mode let us decrypt option files and use\r\n\t// them decrypted later.\r\n\tif (checkAuthenticity()) return true;\r\n#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\tif (!initialized) return false;\r\n\r\n\t// decrypt all... (typical xor)\r\n\tfor (thisByte=(BYTE*)options;\r\n\tthisByte-(BYTE*)options<sizeof(optionsStruct);\r\n\tthisByte++)\r\n\t\t(*thisByte)=(*thisByte)^1;\r\n*/\r\n\treturn true;// all ok\r\n}// decrypt\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"players.h\"// for managing the players\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include <string.h>\r\n//#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions\r\n\r\n// Functions to be called before and after executing the game\r\n\r\n// This function sets all up to let players participate in the game.\r\n// Everything related to player initialization is here.\r\nbool createPlayerObjects()\r\n{\r\n\tplayerUnitStruct playerData;\r\n\r\n\t// Add our players to the list\r\n\r\n\t// Drop the players from the list\r\n\tplayerList.resetList();\r\n\r\n\t// Basic info\r\n\tsetupPlayerUnit(playerData, FILE_GAMEDATA_PLAYER_JAVATAR);\r\n\t// Set the relative position stuff (relative to camera)\r\n\tplayerData.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\tplayerData.xFromCamera=\r\n\t\t-(constructContainerFrame(&playerData).w-\r\n\t\tconstructContainerFrame(&playerData).handlerX);\r\n\tplayerData.yFromCamera=-50;\r\n\t// Coordinates\r\n\tplayerData.x=playerData.xFromCamera;\r\n\tplayerData.y=playerData.yFromCamera;\r\n\t// Set all up for the entrance\r\n\tplayerData.goingToPoint=true;\r\n\tplayerData.goingToPointX=200;\r\n\tplayerData.goingToPointY=(gameWorld.hCamera-150)/2;\r\n\tsetSpeedForLinealMove(\r\n\t\t&playerData,// player unit\r\n\t\tplayerData.goingToPointX, playerData.goingToPointY,// dest pos\r\n\t\t280/double(desiredFramesPerSecond));// linear speed\r\n\t// Don't let it shoot for the first portion of a second\r\n\tplayerData.unarmedTimeLeft=\r\n\t\tint(0.2*double(desiredFramesPerSecond));\r\n\t// Speed\r\n\tplayerData.linearSpeed=200/double(desiredFramesPerSecond);\r\n\t// Input info...\r\n\tplayerData.userControlled=true;\r\n\tplayerData.keyUp=SDLK_UP;\r\n\tplayerData.keyDown=SDLK_DOWN;\r\n\tplayerData.keyLeft=SDLK_LEFT;\r\n\tplayerData.keyRight=SDLK_RIGHT;\r\n\tplayerData.keyShoot=KMOD_RCTRL;\r\n\tif (gameWorld.playersToStart<=1){\r\n\t\t// we are alone, let us use all the keyboard\r\n\t\tplayerData.playerUseAllKeyboard=true;// if it's set, we can use special key codes for making many keys do for the same function\r\n\t}else{\r\n\t\tplayerData.playerUseAllKeyboard=false;// if it's set, we can use special key codes for making many keys do for the same function\r\n\t}// if\r\n\t// Add this node\r\n\tif (!playerList.isValidIndex(playerList.addNode(playerData))){\r\n\t\tlogger.logLine(\"Failed adding node to playerList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// createPlayerObjects\r\n\r\n// This functions destroys all what's been created in createPlayerObjects.\r\nbool destroyPlayerObjects()\r\n{\r\n\t// nothing to do yet...\r\n\r\n\treturn true;// all ok\r\n}// destroyPlayerObjects\r\n\r\n// Other useful functions\r\n\r\n// This function increments the score of a player\r\nbool playerIncrementScoreForHit(gameObjectPointerStruct& unitP, double extraScore){\r\n\tvectorListNodeStruct<playerUnitStruct>* player;\r\n\r\n\t// check for unitP actually being a player, if it's not, it's\r\n\t// been an error.\r\n\tif (unitP.objectType!=FILE_GAMEDATA_GAMEOBJECT_PLAYER)\r\n\t\treturn false;\r\n\r\n\tplayer=playerList.getNode(unitP.listIndex);\r\n\r\n\t// Now check for it being the player it's supposed to be, and for\r\n\t// it being a correct player to increment the score\r\n\tif (player->data.id!=unitP.id || player->data.energyLeft<=0 ||\r\n\t\t!player->data.nowActive){\r\n\r\n\t\t// I can't increment this player score, neither it's been a\r\n\t\t// real error\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\r\n\t// Increment the score\r\n\tplayer->data.score+=extraScore;\r\n\t// save the statistic\r\n\tgameWorld.scoreInHits+=(int)extraScore;\r\n\r\n\treturn true;// all ok\r\n}// playerIncrementScoreForHit\r\n\r\n// allPlayersIncrementScore *******\r\n// This function increments the score of all the players\r\nbool allPlayersIncrementScore(double extraScore){\r\n\r\n\tvectorListNodeStruct<playerUnitStruct> *player;\r\n\r\n\tfor (player=playerList.getFirstNode(); player!=NULL;\r\n\tplayer=playerList.getNextNode(player)){\r\n\r\n\t\t// never mind about this unit if it's not active now\r\n\t\tif (!player->data.nowActive) continue;\r\n\r\n\t\t// increment its score\r\n\t\tplayer->data.score+=extraScore;\r\n\t}// for unit\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// allPlayersIncrementScore\r\n\r\n// This function makes a player unit drop a bullet\r\nbool playerDropBullet(vectorListNodeStruct<playerUnitStruct>& unitP){\r\n\t// Unit types\r\n\tgenericUnitTypeDataStruct* myPlayerType;\r\n\tgenericUnitTypeDataStruct* myBulletType;\r\n\r\n\t// Unit frames\r\n\tframeDataStruct* myPlayerFrame;\r\n\tframeDataStruct* myBulletFrame;\r\n\r\n\t// Other variables\r\n\tbulletUnitStruct unitB;\r\n\tlong double x, y;\r\n\r\n\t// set the default values for this bullet...\r\n\tif (!setupBulletUnit(unitB, FILE_GAMEDATA_BULLET_PLAYERFLAME))\r\n\t\treturn false;\r\n\r\n\t// Select the unit types and frames\r\n\tmyPlayerType=&(playerType[unitP.data.unitType]);\r\n\tmyPlayerFrame=&(myPlayerType->frames[unitP.data.currentFrame]);\r\n\tmyBulletType=&(bulletType[unitB.unitType]);\r\n\tmyBulletFrame=&(myBulletType->frames[unitB.currentFrame]);\r\n\r\n\t// coordinates for the bullet\r\n\tx=unitP.data.x+\r\n\t\t(myPlayerFrame->spawnBulletsX);\r\n\ty=unitP.data.y+\r\n\t\t(myPlayerFrame->spawnBulletsY);\r\n\r\n\t// Center vertically the bullet on those coordinates\r\n\t// (x is the x coordinate of the bullet handler, while y is the\r\n\t// y coordinate of the center of the bullet)\r\n\tunitB.x=x;\r\n\tunitB.y=y+(myBulletFrame->handlerY)-(myBulletFrame->h)/2;\r\n\r\n\t// What kind of units does this bullet hit?: enemies only\r\n\tunitB.canCollideWithEnemies=true;// can this bullet unit collide with enemies?\r\n\tunitB.canCollideWithPlayers=true;// can this bullet unit collide with players?\r\n\r\n\t// set the owner\r\n\tunitB.owner.id=unitP.data.id;\r\n\tunitB.owner.listIndex=playerList.getIndex(&unitP);\r\n\tunitB.owner.objectType=FILE_GAMEDATA_GAMEOBJECT_PLAYER;\r\n\r\n\t// speed for the bullet\r\n\tunitB.linearSpeed=\r\n\t\tgameWorld.xSpeedCamera+700/double(desiredFramesPerSecond);\r\n\r\n\t// set the linear movement\r\n\tunitB.goingToPoint=true;\r\n\t// medium x collision point\r\n\tunitB.goingToPointX=getRightWall(int(unitB.y));\r\n\t// top x collision point\r\n\tunitB.goingToPointX=MIN(unitB.goingToPointX,\r\n\t\tgetRightWall(int(unitB.y-(myBulletFrame->handlerY))));\r\n\t// bottom x collision point\r\n\tunitB.goingToPointX=MIN(unitB.goingToPointX,\r\n\t\tgetRightWall(int(unitB.y+(myBulletFrame->h)\r\n\t\t-(myBulletFrame->handlerY))));\r\n\tunitB.goingToPointY=unitB.y;\r\n\r\n\t// check the bullet won't go backwards, and if it will, don't let\r\n\t// it do that: make it appear directly where it must to go\r\n\t// (this code assumes some specific horizontal direction for the\r\n\t// bullet)\r\n\tif (unitB.goingToPointX<unitB.x) unitB.x=unitB.goingToPointX;\r\n\r\n\tsetSpeedForLinealMove(\r\n\t\t&unitB,// player unit\r\n\t\tunitB.goingToPointX, unitB.goingToPointY,// dest pos\r\n\t\tunitB.linearSpeed);// linear speed\r\n\r\n\t// add the bullet itself\r\n\tif (!bulletList.isValidIndex(bulletList.addNode(unitB))){\r\n\t\tlogger.logLine(\"Failed adding node to bulletList\");\r\n\t\treturn false;\r\n\t}// if\r\n/*\r\n\t// do the sound of the bullet\r\n\tmakeSoundPlayerDropBullet();\r\n*/\r\n\treturn true;// all ok\r\n}// playerDropBullet\r\n\r\n// Tell whether we take current keyboard state as a pressed state of\r\n// the keyCode, according to the playerUseAllKeyboard flag\r\nbool isPlayerKeyPressed(FILE_DIWRAP_KEYS_TYPE* keys, FILE_DIWRAP_SINGLEKEY_TYPE keyCode, bool playerUseAllKeyboard){\r\n\tif (playerUseAllKeyboard){\r\n\t\tswitch (keyCode){\r\n\t\tcase KMOD_LCTRL:// these three are as an only key\r\n\t\tcase KMOD_RCTRL:\r\n\t\tcase SDLK_SPACE:\r\n\t\t\treturn KEYDOWN(keys, SDLK_SPACE) ||\r\n\t\t\t\tKEYDOWN(keys, KMOD_LCTRL) ||\r\n\t\t\t\tKEYDOWN(keys, KMOD_RCTRL);\r\n\t\tdefault:\r\n\t\t\t// common behaviour for no special keywords\r\n\t\t\treturn KEYDOWN(keys, keyCode);\r\n\t\t}// switch\r\n\t}else{\r\n\t\treturn KEYDOWN(keys, keyCode);\r\n\t}// if\r\n}// isPlayerKeyPressed\r\n\r\n// This function moves a player unit according to the data from the\r\n// input devices\r\nbool movePlayerUnit(vectorListNodeStruct<playerUnitStruct>& unit, FILE_DIWRAP_KEYS_TYPE* keys)\r\n{\r\n\tgenericUnitTypeDataStruct* myPlayerType;\r\n\tframeDataStruct* myUnitFrame;\r\n\r\n\t// we use this to know if the unit was going to a given point\r\n\t// before executing the unintelligent lineal movement\r\n\tbool wasGoingToPoint=unit.data.goingToPoint;\r\n\r\n\t// select the player type and current frame\r\n\tmyPlayerType=&(playerType[unit.data.unitType]);\r\n\tmyUnitFrame=&(myPlayerType->frames[unit.data.currentFrame]);\r\n\r\n\t// for counting other players\r\n\tint counter;\r\n\tvectorListNodeStruct<playerUnitStruct> *extraPlayer;\r\n\r\n\t// AUTOFRAMING BEGIN\r\n\t// auto frame it\r\n\tif (!autoFrameUnit(&(unit.data))) return false;\r\n\r\n\t// check for negative frame numbers (they use to have a meaning,\r\n\t// attached)\r\n\tswitch(unit.data.currentFrame){\r\n\t// BULLET SPECIFIC CODE BEGIN\r\n\tcase -1:\r\n\t\t// frame -1 means: this unit should stop existing!\r\n\t\t// free the slaves of this unit\r\n\t\tif (!freeSlavesOf(&unit.data)) return false;\r\n\t\t// remove the unit\r\n\t\tif (!playerList.removeNode(playerList.getIndex(&unit)))\r\n\t\t\treturn false;\r\n\t\t// the unit has been removed, we cannot continue here\r\n\t\treturn true;\r\n\t// BULLET SPECIFIC CODE END\r\n\tdefault:\r\n\t\t// no problem here...\r\n\t\tbreak;\r\n\t}// switch\r\n\t// AUTOFRAMING END\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\t// if this unit is a slave of any other, no more work should be\r\n\t// done here\r\n\tif (unit.data.slaveOf.objectType!=FILE_GAMEDATA_GAMEOBJECT_EMPTY)\r\n\t\treturn true;\r\n\r\n\t// move the unit with the camera if it's necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.x=gameWorld.xCamera+unit.data.xFromCamera;\r\n\t\tunit.data.y=gameWorld.yCamera+unit.data.yFromCamera;\r\n\t}// if\r\n\r\n\t// before anything, decrease the counters if needed\r\n\t// For being untouchable\r\n\tif (unit.data.untouchableTimeLeft>0){\r\n\t\tunit.data.untouchableTimeLeft--;\r\n\r\n\t\tif (unit.data.untouchableTimeLeft==0 && unit.data.energyLeft>0){\r\n\t\t\t// go back to the usual frame...\r\n\t\t\tswitch(unit.data.unitType){\r\n\t\t\tcase FILE_GAMEDATA_PLAYER_JAVATAR:\r\n\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"javatarNormal\");// normal frame\r\n\t\t\t\tunit.data.trembling=false;// don't tremble anymore\r\n\t\t\t\t// continue auto framing\r\n\t\t\t\tunit.data.vFramesPassed=0;\r\n\t\t\t\t// to avoid mistakes, update the frame info\r\n\t\t\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\t\t}// if\r\n\t}// if\r\n\t// For being unarmed\r\n\tif (unit.data.unarmedTimeLeft>0)\r\n\t\tunit.data.unarmedTimeLeft--;\r\n\r\n\t// Execute some events now...\r\n\t// Check events to know if it's time to let the player shoot\r\n\t// again (check for the eventAvatar_weaponReadyAgain event)\r\n\t// Don't forget, however, that if the shooting is interrupted\r\n\t// before going to the frame that has such event, the only\r\n\t// factors that will determine the time that the player will\r\n\t// continue being unarmed are unarmedTimeMax and unarmedTimeLeft)\r\n\tif (unit.data.vFramesPassed==\r\n\t\tmyUnitFrame->autoShowVirtualFrames-1 &&\r\n\t\tmyUnitFrame->nextEventName!=NULL &&\r\n\t\tstrcmp(\"eventAvatar_weaponReadyAgain\",\r\n\t\tmyUnitFrame->nextEventName)==0){\r\n\r\n\t\t// set the guy as not being unarmed anymore\r\n\t\tunit.data.unarmedTimeLeft=0;\r\n\t}// if\r\n\t// Check events to know if it's time to add a bullet\r\n\t// (check for this frame having an \"imgAvatarEvent_shoot\"\r\n\t// event attached to it)\r\n\tif (unit.data.vFramesPassed==\r\n\t\tmyUnitFrame->autoShowVirtualFrames-1 &&\r\n\t\tmyUnitFrame->nextEventName!=NULL &&\r\n\t\tstrcmp(\"eventAvatar_shoot\",\r\n\t\tmyUnitFrame->nextEventName)==0){\r\n\r\n\t\t// drop the bullet\r\n\t\tif(!playerDropBullet(unit)) return false;\r\n\t}// if\r\n\r\n\t// should we move the unit to some specific point?\r\n\t// that is, unintelligent movement vs. intelligent movement\r\n\tif (unit.data.goingToPoint){\r\n\t\tif (!unintelligentLinealMove(&unit.data))\r\n\t\t\treturn false;// failed!\r\n\r\n\t\t// not going to a point anymore? clear the entering flag!\r\n\t\tif (!unit.data.goingToPoint && unit.data.nowEnteringGame){\r\n\t\t\t// stopped entering!\r\n\t\t\tunit.data.nowEnteringGame=false;\r\n\r\n\t\t\t// execute the next ingame music...\r\n/*\t\t\texecuteIngameMusic(1);*/\r\n\t\t}// if\r\n\t}else{\r\n\t\t// now the usual ai\r\n\t\t// Move in every direction\r\n\t\r\n\t\t// Up\r\n\t\tif (isPlayerKeyPressed(keys, unit.data.keyUp,\r\n\t\t\tunit.data.playerUseAllKeyboard)){\r\n\r\n\t\t\t// go up\r\n\t\t\tunit.data.y-=unit.data.linearSpeed;\r\n\r\n\t\t\t// if not currently doing anything strange, set the\r\n\t\t\t// frame of moving down\r\n\t\t\tif (myUnitFrame->groupName!=NULL &&\r\n\t\t\t\tstrcmp(\"javGrpNormal\", myUnitFrame->groupName)==0){\r\n\r\n\t\t\t\t// set the frame\r\n\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"javatarGoingUp\");\r\n\t\t\t\t// continue auto framing\r\n\t\t\t\tunit.data.vFramesPassed=0;\r\n\t\t\t\t// to avoid mistakes, update the frame info\r\n\t\t\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t\t// Down\r\n\t\tif (isPlayerKeyPressed(keys, unit.data.keyDown,\r\n\t\t\tunit.data.playerUseAllKeyboard)){\r\n\r\n\t\t\t// go down\r\n\t\t\tunit.data.y+=unit.data.linearSpeed;\r\n\r\n\t\t\t// if not currently doing anything strange, set the\r\n\t\t\t// frame of moving down\r\n\t\t\tif (myUnitFrame->groupName!=NULL &&\r\n\t\t\t\tstrcmp(\"javGrpNormal\", myUnitFrame->groupName)==0){\r\n\r\n\t\t\t\t// set the frame\r\n\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"javatarGoingDown\");\r\n\t\t\t\t// continue auto framing\r\n\t\t\t\tunit.data.vFramesPassed=0;\r\n\t\t\t\t// to avoid mistakes, update the frame info\r\n\t\t\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t\t// Left\r\n\t\tif (isPlayerKeyPressed(keys, unit.data.keyLeft,\r\n\t\t\tunit.data.playerUseAllKeyboard))\r\n\t\t\tunit.data.x-=unit.data.linearSpeed;\r\n\t\t// Right\r\n\t\tif (isPlayerKeyPressed(keys, unit.data.keyRight,\r\n\t\t\tunit.data.playerUseAllKeyboard))\r\n\t\t\tunit.data.x+=unit.data.linearSpeed;\r\n\r\n\r\n\t\t// Check for the collisions against the camera boundaries\r\n\t\t// Up\r\n\t\tif (unit.data.y-(myUnitFrame->handlerY)+(myUnitFrame->cY)\r\n\t\t\t<(gameWorld.yCamera)){\r\n\r\n\t\t\tunit.data.y=(myUnitFrame->handlerY)\r\n\t\t\t\t-(myUnitFrame->cY)+(gameWorld.yCamera);\r\n\t\t}// if\r\n\t\t// Left\r\n\t\tif (unit.data.x-(myUnitFrame->handlerX)+(myUnitFrame->cX)\r\n\t\t\t<(gameWorld.xCamera)){\r\n\r\n\t\t\tunit.data.x=(myUnitFrame->handlerX)\r\n\t\t\t\t-(myUnitFrame->cX)+(gameWorld.xCamera);\r\n\t\t}// if\r\n\t\t// Down\r\n\t\tif (unit.data.y+(myUnitFrame->cH)+(myUnitFrame->cY)\r\n\t\t\t-(myUnitFrame->handlerY)>=\r\n\t\t\t(gameWorld.yCamera)+gameWorld.hCamera){\r\n\r\n\t\t\tunit.data.y=(gameWorld.yCamera)+gameWorld.hCamera-\r\n\t\t\t(myUnitFrame->cH)-(myUnitFrame->cY)+(myUnitFrame->handlerY);\r\n\t\t}// if\r\n\t\t// Right\r\n\t\tif (unit.data.x+(myUnitFrame->cW)+(myUnitFrame->cX)-\r\n\t\t\t(myUnitFrame->handlerX)>=(gameWorld.xCamera)+\r\n\t\t\tgameWorld.wCamera){\r\n\r\n\t\t\tunit.data.x=(gameWorld.xCamera)+gameWorld.wCamera-\r\n\t\t\t(myUnitFrame->cW)-(myUnitFrame->cX)+(myUnitFrame->handlerX);\r\n\t\t}// if\r\n\r\n\t\t// Check for collisions against the walls\r\n\t\t// Down against the ground\r\n\t\tif (unit.data.y+(myUnitFrame->cH)+(myUnitFrame->cY)\r\n\t\t\t-(myUnitFrame->handlerY)>=\r\n\t\t\t(gameWorld.yCamera)+gameWorld.yGroundForPlayer){\r\n\r\n\t\t\tunit.data.y=(gameWorld.yCamera)+gameWorld.yGroundForPlayer-\r\n\t\t\t(myUnitFrame->cH)-(myUnitFrame->cY)+(myUnitFrame->handlerY);\r\n\t\t}// if\r\n\t\t// Left wall against handler\r\n\t\tif ((unit.data.x)-(myUnitFrame->handlerX)+(myUnitFrame->cX)\r\n\t\t\t<getLeftWall((int)unit.data.y)){\r\n\r\n\t\t\tunit.data.x=(myUnitFrame->handlerX)\r\n\t\t\t\t-(myUnitFrame->cX)+getLeftWall((int)unit.data.y);\r\n\t\t}// if\r\n\t\t// Right wall against handler\r\n\t\tif (unit.data.x+(myUnitFrame->cW)+(myUnitFrame->cX)-\r\n\t\t\t(myUnitFrame->handlerX)>=getRightWall((int)unit.data.y)){\r\n\r\n\t\t\tunit.data.x=getRightWall((int)unit.data.y)-\r\n\t\t\t(myUnitFrame->cW)-(myUnitFrame->cX)+(myUnitFrame->handlerX);\r\n\t\t}// if\r\n\t\t// Next four checks aren't necessary at all, but are useful\r\n\t\t// for making the guy keep outside the wall limits with the\r\n\t\t// entire body.\r\n\t\t// Left wall against upper side\r\n\t\tif (unit.data.x-(myUnitFrame->handlerX)+(myUnitFrame->cX)\r\n\t\t\t<getLeftWall((int)\r\n\t\t\t\tunit.data.y-(myUnitFrame->handlerY)+(myUnitFrame->cY))){\r\n\r\n\t\t\tunit.data.x=(myUnitFrame->handlerX)\r\n\t\t\t\t-(myUnitFrame->cX)+getLeftWall((int)\r\n\t\t\t\t\tunit.data.y-(myUnitFrame->handlerY)+(myUnitFrame->cY));\r\n\t\t}// if\r\n\t\t// Right wall against upper side\r\n\t\tif (unit.data.x+(myUnitFrame->cW)+(myUnitFrame->cX)-\r\n\t\t\t(myUnitFrame->handlerX)\r\n\t\t\t>=getRightWall((int)\r\n\t\t\t\tunit.data.y-(myUnitFrame->handlerY)+(myUnitFrame->cY))){\r\n\r\n\t\t\tunit.data.x=getRightWall((int)\r\n\t\t\t\tunit.data.y-(myUnitFrame->handlerY)+(myUnitFrame->cY))-\r\n\t\t\t(myUnitFrame->cW)-(myUnitFrame->cX)+(myUnitFrame->handlerX);\r\n\t\t}// if\r\n\t\t// Left wall against lower side\r\n\t\tif (unit.data.x-(myUnitFrame->handlerX)+(myUnitFrame->cX)\r\n\t\t\t<getLeftWall((int)\r\n\t\t\t\tunit.data.y-\r\n\t\t\t\t(myUnitFrame->handlerY)+(myUnitFrame->cY)\r\n\t\t\t\t+(myUnitFrame->cH))){\r\n\r\n\t\t\tunit.data.x=(myUnitFrame->handlerX)\r\n\t\t\t\t-(myUnitFrame->cX)+getLeftWall((int)\r\n\t\t\t\t\tunit.data.y-(myUnitFrame->handlerY)+\r\n\t\t\t\t\t(myUnitFrame->cY)+(myUnitFrame->cH));\r\n\t\t}// if\r\n\t\t// Right wall against lower side\r\n\t\tif (unit.data.x+(myUnitFrame->cW)+(myUnitFrame->cX)-\r\n\t\t\t(myUnitFrame->handlerX)\r\n\t\t\t>=getRightWall((int)\r\n\t\t\t\tunit.data.y-(myUnitFrame->handlerY)\r\n\t\t\t\t+(myUnitFrame->cY)+(myUnitFrame->cH))){\r\n\r\n\t\t\tunit.data.x=getRightWall((int)\r\n\t\t\t\tunit.data.y-(myUnitFrame->handlerY)\r\n\t\t\t\t+(myUnitFrame->cY)+(myUnitFrame->cH))-\r\n\t\t\t(myUnitFrame->cW)-(myUnitFrame->cX)+(myUnitFrame->handlerX);\r\n\t\t}// if\r\n\t}// lineal movement vs. typical ai\r\n\r\n\t// Now check if it's shooting\r\n\t// (only while alive)\r\n\tif ((unit.data.energyLeft>0) &&\r\n\t\tisPlayerKeyPressed(keys, unit.data.keyShoot,\r\n\t\tunit.data.playerUseAllKeyboard) &&\r\n\t\tunit.data.unarmedTimeLeft<=0 &&\r\n\t\tunit.data.untouchableTimeLeft<=0){\r\n\r\n\t\t// Change to the shooting frame if necessary\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_PLAYER_JAVATAR){\r\n\r\n\t\t\t// change the frame\r\n\t\t\tif (unit.data.unitType==FILE_GAMEDATA_PLAYER_JAVATAR)\r\n\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\tgetFrameIndexAndListByName(\"javatarShoot\");// shooting frame\r\n\r\n\t\t\t// continue auto framing\r\n\t\t\tunit.data.vFramesPassed=0;\r\n\r\n\t\t\t// to avoid mistakes, update the frame info\r\n\t\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t\t}// if\r\n\r\n\t\t// Make it wait for the next shot\r\n\t\tunit.data.unarmedTimeLeft=unit.data.unarmedTimeMax;\r\n\t}// if\r\n\r\n\t// AI to execute even when in lineal movement\r\n\t// check for this unit being out of the screen\r\n\t// (while dead)\r\n\tif ((unit.data.energyLeft<=0) &&\r\n\t\t((unit.data.x-(myUnitFrame->handlerX)\r\n\t\t>=gameWorld.xCamera+gameWorld.wCamera) ||\r\n\t\t(unit.data.y-(myUnitFrame->handlerY)\r\n\t\t>=gameWorld.yCamera+gameWorld.hCamera) ||\r\n\t\t(unit.data.x+(myUnitFrame->w)-(myUnitFrame->handlerX)<0) ||\r\n\t\t(unit.data.y+(myUnitFrame->h)-(myUnitFrame->handlerY)<0))\r\n\t\t){\r\n\r\n\t\t// UNIT TO BE DISABLED: MISCELLANEOUS WORK\r\n\t\t// now do everything else, that has to be done every time\r\n\t\t// a player is disabled\r\n\t\t// Count the active players\r\n\t\tfor (extraPlayer=playerList.getFirstNode(), counter=0;\r\n\t\textraPlayer!=NULL;\r\n\t\textraPlayer=playerList.getNextNode(extraPlayer)){\r\n\t\t\t// don't count inactive units, neither this unit\r\n\t\t\t// Units with no energy are useful here, though (as we'll\r\n\t\t\t// deal with these as soon as they finish going out of the\r\n\t\t\t// screen)\r\n\t\t\tif (!extraPlayer->data.nowActive ||\r\n\t\t\t\textraPlayer->data.id==unit.data.id)\r\n\t\t\t\tcontinue;\r\n\t\t\tcounter++;\r\n\t\t}// for\r\n\t\tif (counter<=0){\r\n\t\t\t// there are no other alive players, do what's needed\r\n\t\t\t// ... but nothing is needed\r\n\t\t}// if\r\n\r\n\t\t// Now we finished scoring this unit we can disable it\r\n\t\t// for ever\r\n\t\tunit.data.nowActive=false;\r\n\t}// if\r\n\r\n\t// update the *FromCamera variables if necessary\r\n\tif (unit.data.isPosRelative){\r\n\t\tunit.data.xFromCamera=unit.data.x-gameWorld.xCamera;\r\n\t\tunit.data.yFromCamera=unit.data.y-gameWorld.yCamera;\r\n\t}// if\r\n\r\n\t// let's move the unit with the owner unit, if any\r\n\tif (!moveWithOwner(&unit.data)) return false;\r\n\r\n\r\n\treturn true;// all ok\r\n}// movePlayerUnit\r\n\r\n// This function moves the players according to the data from the\r\n// input devices\r\nbool movePlayers(FILE_DIWRAP_KEYS_TYPE* keys)\r\n{\r\n\tvectorListNodeStruct<playerUnitStruct> *unit;\r\n\tint i=0;\r\n\r\n\t// move all the players in the game world...\r\n\tfor (unit=playerList.getFirstNode(); unit!=NULL; unit=playerList.getNextNode(unit)){\r\n\t\t// don't move this unit if it's not active now\r\n\t\tif (!unit->data.nowActive) continue;\r\n\r\n\t\t// move this unit\r\n\t\tif (!movePlayerUnit(*unit, keys)) return false;\r\n\t}// for unit\r\n\r\n\treturn true;// all ok\r\n}// movePlayers\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"postinstall.h\"// for using the functions related to post-installation tasks\r\n/*#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"winutil.h\"// for accessing to some useful functions related to low level windows specific code\r\n#include \"vorbis2wav.h\"// for converting ogg vorbis files to wav\r\n*/\r\n\r\n// executePostInstallTasks *************\r\n// This funcion is supposed to be called the first time the program is\r\n// executed after installation, when it's time to decompress the ogg\r\n// files into wav, for example.\r\nbool executePostInstallTasks(bool showMessages)\r\n{\r\n/*\tint nodeIdx;// node in the resources list\r\n\twaveResourceClass* waveObj;// a wave object...\r\n\tchar waitText[200];\r\n\r\n\t// Let's do the Ogg conversion to Wav\r\n\t// for every node in the objects list...\r\n\tfor (nodeIdx=0; nodeIdx<resObjectsListSize; nodeIdx++){\r\n\t\t// check it's a wave file\r\n\t\tif (resObjectsList[nodeIdx].resObj->getType()\r\n\t\t\t==FILE_RESOBJECTS_WAVE){\r\n\r\n\t\t\t// it's a wave file, let's see what to do now\r\n\t\t\twaveObj=(waveResourceClass*)resObjectsList[nodeIdx].resObj;\r\n\r\n\t\t\t// check it needs to be converted\r\n\t\t\tif (waveObj->getOggFileName()!=NULL &&\r\n\t\t\t\t!WinUtilCode::fileExists(waveObj->getFileName())){\r\n\r\n\t\t\t\t// Log it\r\n\t\t\t\tlogger.logLine(\"Going to decode %s using Vorbis.\",\r\n\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\twaveObj->getOggFileName());\r\n\r\n\t\t\t\tif (showMessages){\r\n\t\t\t\t\t// Show a message on screen\r\n\t\t\t\t\twsprintf(waitText,\r\n\t\t\t\t\t\t\"-- RANDOMEDIA CONCEPT --\\n\"\r\n\t\t\t\t\t\t\"Please wait while the installation is completed.\\n\"\r\n\t\t\t\t\t\t\"Decompressing %s.\",\r\n\t\t\t\t\t\twaveObj->getOggFileName());\r\n\t\t\t\t\tDD.fillAllDword(0);\r\n\t\t\t\t\tDD.writeText(waitText,\r\n\t\t\t\t\t\t255, 255, 255,\r\n\t\t\t\t\t\tFILE_DDWRAP_ALIGN_CENTER,\r\n\t\t\t\t\t\t0, 120, 0, 0);\r\n\t\t\t\t\tDD.flip();\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// Now it's time to do the real conversion, and let's\r\n\t\t\t\t// use 16 bits...\r\n\t\t\t\tif (!convertOggToWavFile(\r\n\t\t\t\t\twaveObj->getOggFileName(),\r\n\t\t\t\t\twaveObj->getFileTemp(),\r\n\t\t\t\t\t16)) return false;\r\n\t\t\t\tDeleteFile(waveObj->getFileName());\r\n\t\t\t\tMoveFile(waveObj->getFileTemp(), waveObj->getFileName());\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// for nodeIdx\r\n*/\r\n\treturn true;\r\n}// executePostInstallTasks\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n#include \"resmanager.h\"// for using the functions which manage the resources and operate their loading and unloading\r\n#include \"globals.h\"// for using the program objects\r\n#include \"introcode.h\"// for accesing to the methods related to the program zone corresponding to the intro\r\n#include \"menucode.h\"// for accesing to the methods related to the program zone corresponding to the game menues\r\n#include \"gamecode.h\"// for accessing to the code related only with the game\r\n#include \"programinfo.h\"// for general info about the program itself\r\n\r\n// switchToProgramZone *******\r\n// This function manages the switch from a program zone to another one.\r\nbool switchToProgramZone(\r\n\tprogramZonesEnum programZone,// program zone to look at\r\n\tDWORD programSubZone,// program sub zone to look at\r\n\tDWORD programSubSubZone,// program sub sub zone to look at\r\n\tbool reInitializeAllResources)// if true, set up more slowly, but keep memory fragmentation to a minimum\r\n{\r\n\t// switch it in all the cases\r\n\tlogger.logLine(\"Switching to program zone %i\",\r\n\t\ttrue, false, true, programZone);\r\n\r\n\t// first, pause the clock so that we don't use the clock time for\r\n\t// the load of data and all that stuff\r\n\tif (mainLoopObject.getTimerObject()->isReady() &&\r\n\t\t!mainLoopObject.getTimerObject()->pause()) return false;\r\n\r\n\t// call the afterLoop function of currentProgramZone in\r\n\t// currentProgramSubZone and currentProgramSubSubZone...\r\n\tswitch(currentProgramZone){\r\n\tcase pgzon_actualGameRunning:// actual game is currently running\r\n\t\tif (!GameLoopCode::afterLoop()) return false;\r\n\t\tbreak;\r\n\tcase pgzon_gameIntro:// program intro is currently being executed\r\n\t\tif (!IntroLoopCode::afterLoop()) return false;\r\n\t\tbreak;\r\n\tcase pgzon_gameMenues:// program menues are currently being executed\r\n\t\tif (!MenuLoopCode::afterLoop()) return false;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Program zone switch after loop ok\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t// set up the resources for this game zone\r\n\tif (!setUpResources(programZone)) return false;\r\n\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Program zone switch set up resources ok\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\t// save the previous program zone data\r\n\tpreviousProgramZone=currentProgramZone;\r\n\tpreviousProgramSubZone=currentProgramSubZone;\r\n\tpreviousProgramSubSubZone=currentProgramSubSubZone;\r\n\t// update the current zone data\r\n\tcurrentProgramZone=programZone;\r\n\tcurrentProgramSubZone=programSubZone;\r\n\tcurrentProgramSubSubZone=programSubSubZone;\r\n\r\n\t// call the beforeLoop function of programZone in\r\n\t// programSubZone and programSubSubZone...\r\n\tswitch(programZone){\r\n\tcase pgzon_actualGameRunning:// actual game is currently running\r\n\t\tif (!GameLoopCode::beforeLoop()) return false;\r\n\t\tbreak;\r\n\tcase pgzon_gameIntro:// program intro is currently being executed\r\n\t\tif (!IntroLoopCode::beforeLoop()) return false;\r\n\t\tbreak;\r\n\tcase pgzon_gameMenues:// program menues are currently being executed\r\n\t\tif (!MenuLoopCode::beforeLoop()) return false;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// let the timer object continue working now\r\n\tif (mainLoopObject.getTimerObject()->isReady() &&\r\n\t\t!mainLoopObject.getTimerObject()->play()) return false;\r\n\r\n\t#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Program zone switch ok\", true, false);\r\n\t#endif// PROGMODE_DEVELOPER_YES\r\n\r\n\treturn true;// all ok\r\n}// switchToProgramZone\r\n\r\n\r\n// switchToNullProgramZone *******\r\n// This function manages the switch to the null program zone.\r\nbool switchToNullProgramZone()\r\n{\r\n\t// do the switch...\r\n\treturn switchToProgramZone(\r\n\t\tpgzon_emptyZone, 0, 0, true);\r\n}// switchToNullProgramZone\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"resfonts.h\"// for accessing to the font resources\r\n\r\n\r\n// setUpProgramFonts *************\r\n// This function sets all the fonts up, either initializing or\r\n// deinitializing them.\r\n// It does only return false if the load of data fails, it doesn't do\r\n// so if it appears to be an unnecessary action.\r\nbool setUpProgramFonts(\r\n\tbool shouldDeinitialize)// boolean telling whether this function should deinitialize those who need being deinitialized, or initialize those who need being initialized\r\n{\r\n\r\n\tif (!shouldDeinitialize){\r\n\t\t// Initialize all the resources necessary for using fonts\r\n\t\tif (!fntDahFont.isReady()){\r\n\t\t\t// we assume no one of the resources used for fonts\r\n\t\t\t// is ready yet... so we initialize them all together\r\n\t\t\tif (\r\n\t\t\t\t!fntDahFont.init(getSurfaceByResourceName(\r\n\t\t\t\t\t\"srfDahFont\"), 8, 15) ||\r\n\t\t\t\t!fntEdiaFont.init(getSurfaceByResourceName(\r\n\t\t\t\t\t\"srfEdiaFont\"), 6, 6) ||\r\n\t\t\t\t!fntEdiaBigFont.init(getSurfaceByResourceName(\r\n\t\t\t\t\t\"srfEdiaFont\"), 13, 11) ||\r\n\t\t\t\t!fntDahFont.setUpCharactersInMatrix(\r\n\t\t\t\t\t\" AaBbCcDdEeFfGgHhIiJjKkLlMm Nn��OoPpQqRrSsTtUuVvWwXxYy Zz0123456789�!�?=|@#\\\"$%&\\\\/()+*-_;:.,<>^[]{}��������������������'\",\r\n\t\t\t\t\t1, 1,// x, y for the matrix start\r\n\t\t\t\t\t27,// width of the matrix in characters\r\n\t\t\t\t\t1, 1) ||// horizontal and vertical space between characters\r\n\t\t\t\t!fntEdiaFont.setUpCharactersInMatrix(\r\n\t\t\t\t\t\" ABCDEFGHIJKLMN�OPQRSTUVWXYZ,.:?!-0123456789\",\r\n\t\t\t\t\t1, 1,// x, y for the matrix start\r\n\t\t\t\t\t28,// width of the matrix in characters\r\n\t\t\t\t\t1, 1) ||// horizontal and vertical space between characters\r\n\t\t\t\t!fntEdiaBigFont.setUpCharactersInMatrix(\r\n\t\t\t\t\t\" ABCDEFGHIJKLMN�OPQRSTUVWXYZ,.:?!-0123456789wb\",\r\n\t\t\t\t\t1, 31,// x, y for the matrix start\r\n\t\t\t\t\t28,// width of the matrix in characters\r\n\t\t\t\t\t1, 1))// horizontal and vertical space between characters\r\n\t\t\t{\r\n\t\t\t\tfntDahFont.end();\r\n\t\t\t\tfntEdiaFont.end();\r\n\t\t\t\tfntEdiaBigFont.end();\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}else{\r\n\t\t// Deinitialize all our font resources\r\n\t\tfntDahFont.end();\r\n\t\tfntEdiaFont.end();\r\n\t\tfntEdiaBigFont.end();\r\n\t}// if\r\n\r\n\r\n\treturn true;// all ok...\r\n}// setUpProgramFonts\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"resinfoman.h\"// for managing the information related with the use of resources, ie: animation scripts\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"massDeallocator.h\"// for accessing to the massDeallocator object, useful for massive deallocations\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n#include <string.h>\r\n\r\n// header files for using lua\r\nextern \"C\"{\r\n\t#include <lua.h>\r\n\t#include <lauxlib.h>\r\n}// extern\r\n\r\n// RES INFO MEMORY MANAGEMENT objects\r\nstatic massDeallocatorClass resMemory;\r\n\r\n// FUNCTIONS OF RESOURCE INFO MANAGEMENT\r\n\r\n// initializeResInfo **********\r\n// This function initializes all the data structures related to\r\n// bringing information about the use of resources (for example, the\r\n// animations and frames data).\r\nbool initializeResInfo()\r\n{\r\n\tlua_State* lstate;\r\n\r\n\tlogger.logLine(\"Initializing resources info\", true, false);\r\n\r\n\t// get the lua state object, to be used below\r\n\tlstate=scriptMan.getLuaObject();\r\n\r\n\t// set up the memory mass deallocator we'll use here\r\n\tif (!resMemory.init()){\r\n\t\tlogger.logLine(\"Error initializing mass deallocator\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// now we have successfully executed our scripts... let's use\r\n\t// the data in those to define the composition of our frame lists\r\n\tlua_getglobal(lstate, \"animsFrameList\");\r\n\tlua_pushnil(lstate);\r\n\twhile (lua_next(lstate, -2)!=0){\r\n\t\t// for every specific frame list...\r\n\t\t// we get the name of the frame list to traverse\r\n\t\tchar* curr=(char*)(lua_tostring(lstate, -1));\r\n\t\tframeDataStruct* frData;\r\n\t\tint size;\r\n\t\tint i;\r\n\t\t#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tlogger.logLine(\"Loading animation: %s\",\r\n\t\t\ttrue, false, true, curr);\r\n\t\t#endif\r\n\t\t// ...\r\n\t\tlua_getglobal(lstate, curr);\r\n\t\t// let's see the size of the table\r\n\t\tsize=lua_rawlen(lstate, -1);\r\n\t\tfrData=new frameDataStruct[size+1];\r\n\t\tresMemory.addMemAllocation(frData, false);\r\n\t\t// we add the empty node at the end of the table (position size\r\n\t\t// in a size+1 list)\r\n\t\tmemset(&(frData[size]), 0, sizeof(frData[0]));\r\n\t\t// let's traverse that table...\r\n\t\tlua_pushnil(lstate);\r\n\t\ti=0;\r\n\t\twhile (lua_next(lstate, -2)!=0){\r\n\t\t\tchar* framename;// name of the frame itself \r\n\t\t\tchar* resname; // name of the resource to use \r\n\t\t\tchar* eventname; // name of the event...\r\n\t\t\tchar* groupname; // name of the frames group\r\n\t\t\tint x, y, w, h, // x, y, w, h, as usual \r\n\t\t\t\tcx, cy, cw, ch,// cX, cY, cW, cH, as usual, but in absolute coordinates! \r\n\t\t\t\thx, hy, // handlerX, handlerY, as usual, but in absolute coordinates \r\n\t\t\t\tsx, sy, // spawnBulletsX, spawnBulletsY, as usual, but in absolute coordinates \r\n\t\t\t\tax, ay, // adherenceX, adherenceY, as usual, but in absolute coordinates \r\n\t\t\t\taNF; // autoNextFrame, just as usual \r\n\t\t\tdouble aSVT; // autoShowVirtualTime, just as autoShowVirtualFrames but with time measured in \r\n\t\r\n\t\t\t// and for each node, let's take what's at there\r\n\t\t\tint* value;\r\n\t\t\t// framename\r\n\t\t\tlua_pushstring(lstate, \"framename\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\tif (lua_isnil(lstate, -1)){\r\n\t\t\t\tframename=NULL;\r\n\t\t\t}else{\r\n\t\t\t\tconst char* str=lua_tostring(lstate, -1);\r\n\t\t\t\tframename=new char[strlen(str)+1];\r\n\t\t\t\tstrcpy(framename, str);\r\n\t\t\t\tresMemory.addMemAllocation(framename, false);\r\n\t\t\t}// if\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// resname\r\n\t\t\tlua_pushstring(lstate, \"resname\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\tif (lua_isnil(lstate, -1)){\r\n\t\t\t\tresname=NULL;\r\n\t\t\t}else{\r\n\t\t\t\tconst char* str=lua_tostring(lstate, -1);\r\n\t\t\t\tresname=new char[strlen(str)+1];\r\n\t\t\t\tstrcpy(resname, str);\r\n\t\t\t\tresMemory.addMemAllocation(resname, false);\r\n\t\t\t}// if\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// eventname\r\n\t\t\tlua_pushstring(lstate, \"eventName\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\tif (lua_isnil(lstate, -1)){\r\n\t\t\t\teventname=NULL;\r\n\t\t\t}else{\r\n\t\t\t\tconst char* str=lua_tostring(lstate, -1);\r\n\t\t\t\teventname=new char[strlen(str)+1];\r\n\t\t\t\tstrcpy(eventname, str);\r\n\t\t\t\tresMemory.addMemAllocation(eventname, false);\r\n\t\t\t}// if\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// groupname\r\n\t\t\tlua_pushstring(lstate, \"groupName\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\tif (lua_isnil(lstate, -1)){\r\n\t\t\t\tgroupname=NULL;\r\n\t\t\t}else{\r\n\t\t\t\tconst char* str=lua_tostring(lstate, -1);\r\n\t\t\t\tgroupname=new char[strlen(str)+1];\r\n\t\t\t\tstrcpy(groupname, str);\r\n\t\t\t\tresMemory.addMemAllocation(groupname, false);\r\n\t\t\t}// if\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// x\r\n\t\t\tvalue=&x;\r\n\t\t\tlua_pushstring(lstate, \"x\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// y\r\n\t\t\tvalue=&y;\r\n\t\t\tlua_pushstring(lstate, \"y\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// w\r\n\t\t\tvalue=&w;\r\n\t\t\tlua_pushstring(lstate, \"w\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// h\r\n\t\t\tvalue=&h;\r\n\t\t\tlua_pushstring(lstate, \"h\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// cx\r\n\t\t\tvalue=&cx;\r\n\t\t\tlua_pushstring(lstate, \"cx\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// cy\r\n\t\t\tvalue=&cy;\r\n\t\t\tlua_pushstring(lstate, \"cy\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// cw\r\n\t\t\tvalue=&cw;\r\n\t\t\tlua_pushstring(lstate, \"cw\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// ch\r\n\t\t\tvalue=&ch;\r\n\t\t\tlua_pushstring(lstate, \"ch\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// hx\r\n\t\t\tvalue=&hx;\r\n\t\t\tlua_pushstring(lstate, \"hx\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// hy\r\n\t\t\tvalue=&hy;\r\n\t\t\tlua_pushstring(lstate, \"hy\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// sx\r\n\t\t\tvalue=&sx;\r\n\t\t\tlua_pushstring(lstate, \"sx\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// sy\r\n\t\t\tvalue=&sy;\r\n\t\t\tlua_pushstring(lstate, \"sy\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// ax\r\n\t\t\tvalue=&ax;\r\n\t\t\tlua_pushstring(lstate, \"ax\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// ay\r\n\t\t\tvalue=&ay;\r\n\t\t\tlua_pushstring(lstate, \"ay\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// aNF\r\n\t\t\tvalue=&aNF;\r\n\t\t\tlua_pushstring(lstate, \"aNF\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\t*value=int(lua_tonumber(lstate, -1));\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\t// aSVT\r\n\t\t\tlua_pushstring(lstate, \"aSVT\");\r\n\t\t\tlua_gettable(lstate, -2);\r\n\t\t\taSVT=lua_tonumber(lstate, -1);\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\r\n\t\t\t// let's add the node to our list\r\n\t\t\tframeDataStruct frTemp=createFrame(\r\n\t\t\t\tframename,\r\n\t\t\t\tresname,\r\n\t\t\t\tx, y, w, h,\r\n\t\t\t\tcx, cy, cw, ch,\r\n\t\t\t\thx, hy,\r\n\t\t\t\tsx, sy,\r\n\t\t\t\tax, ay,\r\n\t\t\t\taNF,\r\n\t\t\t\taSVT,\r\n\t\t\t\teventname,\r\n\t\t\t\tgroupname);\r\n\t\t\tfrData[i]=frTemp;\r\n\t\r\n\t\t\t// let's remove the value\r\n\t\t\tlua_pop(lstate, 1);\r\n\t\t\ti++;\r\n\t\t}// while\r\n\r\n\t\t// now we remove the 'curr' table we were traversing itself\r\n\t\tlua_pop(lstate, 1);\r\n\r\n\t\tframeListDataStruct* listNode=getFrameListNodeByName(curr);\r\n\t\tif (listNode==NULL){\r\n\t\t\t// error\r\n\t\t\tlogger.logLine(\"No list node for %s\", true, false, true,\r\n\t\t\t\tcurr);\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\t// all ok, continue working\r\n\t\t\tlistNode->frameList=frData;\r\n\t\t\tlistNode->size=size;\r\n\t\t}// if\r\n\r\n\t\t// let's remove the value got from the traversed key\r\n\t\tlua_pop(lstate, 1);\r\n\t}// while\r\n\r\n\t// remove the animsFrameList table\r\n\tlua_pop(lstate, 1);\r\n\r\n\treturn true;// all ok\r\n}// initializeResInfo \r\n\r\n\r\n\r\n// closeResourcesInfo **********\r\n// This function closes all the data structures that were set up\r\n// with initializeResInfo().\r\nbool closeResourcesInfo()\r\n{\r\n\tif (resMemory.isReady()){\r\n\t\t// deallocate all\r\n\t\tif (!resMemory.massDeallocate()){\r\n\t\t\tlogger.logLine(\"Could not mass deallocate resMemory\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// close some remaining objects\r\n\t\tresMemory.close();\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// closeResourcesInfo\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"resmanager.h\"// for using the functions which manage the resources and operate their loading and unloading\r\n#include \"win-constants.h\"// for defining those common types, like DWORD, etc\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n/*#include \"filenames.h\"// for defining the file names\r\n#include \"resfonts.h\"// for accessing to the font resources*/\r\n#include \"programzones.h\"// for accessing to the code which manages the program zones and the switching between them\r\n\r\n// Functions used by the Resources Manager\r\n\r\n// setUpResources ************\r\n// This function sets all the resources of a given zone up, while\r\n// deallocating the resources that are not going to be used there.\r\nbool setUpResources(\r\n\tprogramZonesEnum programZone)// program zone to look at\r\n\r\n{\r\n\tresObjectDataStruct* ptrObj;\r\n\tresourceClass* resource;\r\n\r\n\t// we use this boolean for some specific cases where a resource\r\n\t// should be excepted from the load\r\n\tbool thisResourceExcepted;\r\n\r\n\t// DEINITIALIZER\r\n\t// Deinitialize all first, only keep in memory those resources\r\n\t// which are to be used in both programZones, and that are marked\r\n\t// with reallocateAlways==false.\r\n\t// Also, only unload those that say neverDeallocate==true, unless\r\n\t// it's going to the pgzon_emptyZone program zone.\r\n\t// for every node in the objects list...\r\n\tfor (ptrObj=resObjectsList;\r\n\tptrObj<resObjectsList+resObjectsListSize; ptrObj++){\r\n\r\n\t\tresource=ptrObj->resObj;\r\n\t\t// check it can be deallocated now... (details are checked below)\r\n\t\tif (resource->isLoaded() &&\r\n\t\t\t(programZone==pgzon_emptyZone || !ptrObj->neverDeallocate))\r\n\t\t{\r\n\r\n\t\t\tif (ptrObj->reallocateAlways){\r\n\t\t\t\t// it has to be reallocated always, unload it\r\n\t\t\t\tif (!resource->unload()){\r\n\t\t\t\t\t// failed, log and exit\r\n\t\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\t\"Failed unloading %s for program zone %i\",\r\n\t\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\t\tresource->getResourceName(), programZone);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}// if\r\n\t\t\t}else{\r\n\t\t\t\t// unload it only if it won't be used on the given\r\n\t\t\t\t// program zone\r\n\t\t\t\tif (!isResObjectInProgramZone(ptrObj, programZone)){\r\n\t\t\t\t\tif (!resource->unload()){\r\n\t\t\t\t\t\t// failed, log and exit\r\n\t\t\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\t\t\"Failed unloading %s for program zone %i\",\r\n\t\t\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\t\t\tresource->getResourceName(), programZone);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// for ptrObj\r\n\r\n\r\n\t// INITIALIZER\r\n\t// Now initialize all those resources which aren't still loaded,\r\n\t// and that belong to the given program zone.\r\n\tfor (ptrObj=resObjectsList;\r\n\tptrObj<resObjectsList+resObjectsListSize; ptrObj++){\r\n\r\n\t\tresource=ptrObj->resObj;\r\n\t\tif (!resource->isLoaded()){\r\n\t\t\t// EXCEPTION CHECK SPECIFIC BEGIN\r\n\t\t\t// check for exceptions\r\n\t\t\tthisResourceExcepted=false;\r\n\r\n\t\t\t// first exception: don't load an audio file if the\r\n\t\t\t// program sound isn't active\r\n\t\t\tif ((resource->getType()==FILE_RESOBJECTS_WAVE ||\r\n\t\t\t\tresource->getType()==FILE_RESOBJECTS_MIDI)\r\n\t\t\t\t&& !programSoundActive){\r\n\r\n\t\t\t\tthisResourceExcepted=true;\r\n\t\t\t}// if\r\n\t\t\t// EXCEPTION CHECK SPECIFIC END\r\n\r\n\t\t\t// load it only if it's used in the given program zone\r\n\t\t\t// and it's not an exception to what should be loaded\r\n\t\t\tif (isResObjectInProgramZone(ptrObj, programZone) &&\r\n\t\t\t\t!thisResourceExcepted){\r\n\r\n\t\t\t\tif (!resource->load()){\r\n\t\t\t\t\t// failed the loading, check whether it's a\r\n\t\t\t\t\t// necessary resource or not\r\n\t\t\t\t\tif (ptrObj->isNecessary){\r\n\t\t\t\t\t\t// failed, log and exit\r\n\t\t\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\t\t\"Failed loading %s for program zone %i\",\r\n\t\t\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\t\t\tresource->getResourceName(), programZone);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// never mind, log the fault and continue\r\n\t\t\t\t\t\tlogger.logLine(\r\n\t\t\t\t\t\t\t\"Failed loading %s for program zone %i, system will continue execution (unnecessary resource)\",\r\n\t\t\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\t\t\tresource->getResourceName(), programZone);\r\n\t\t\t\t\t}// if\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// for ptrObj\r\n\r\n\treturn true;// all ok\r\n}// setUpResources\r\n\r\n// reloadAllLostResources ****\r\n// This function reloads all the resources which are currently loaded,\r\n// but which have been lost (that is, they need to be reloaded). Useful\r\n// for being executed after a switch between programs, for example,\r\n// when graphic surfaces and other resources are lost.\r\nbool reloadAllLostResources()\r\n{\r\n\tresObjectDataStruct* ptrObj;\r\n\tresourceClass* resource;\r\n\r\n\t// for every node in the objects list, check if it's loaded and\r\n\t// lost, and in such a case, reload it\r\n\tfor (ptrObj=resObjectsList;\r\n\tptrObj<resObjectsList+resObjectsListSize; ptrObj++){\r\n\r\n\t\tresource=ptrObj->resObj;\r\n\t\tif (resource->isLoaded() && resource->needsToBeReloaded()){\r\n\t\t\tif (!resource->reload()){\r\n\t\t\t\tlogger.logLine(\"Failed reloading %s\",\r\n\t\t\t\t\ttrue, true, true,\r\n\t\t\t\t\tresource->getResourceName());\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t}// for ptrObj\r\n\r\n\treturn true;// all ok\r\n}// reloadAllLostResources\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"resobjects.h\"// for accessing to the resource objects (graphics, sounds, etc)\r\n\r\n// These files assume there is a variable named hInstance somewhere\r\n// else, containing the instance handle of the current application\r\n/*extern HINSTANCE hInstance;*/\r\n\r\n\r\n// GRAPHIC RESOURCE CLASS METHODS\r\n\r\n// The parametrized constructor\r\ngraphicResourceClass::graphicResourceClass(\r\n\tchar* resName,// resource name\r\n\tchar* fileName,// file name, null for empty resource\r\n\tbool allocateInTheFastestMemory,// let the object decide whether to go to video or system memory, according to where it should blt faster? it supposes isTransparent=true if it's going to be blt transparently always\r\n\tbool useVideoMemory,// should the surface be stored in video memory, whenever possible?\r\n\tbool isFileOrResource,// true if it's a file, and not a resource\r\n\tchar* resourceType,// if the graphic is stored in a pcx resource, it could need to know the resource type\r\n\tbool isBMPorPCX,// true if it's a bmp file, and not a pcx file\r\n\tbool isTransparent,// does it use a transparent background?\r\n\tbool usesTransparentRGB,// does it use the three color components for the transparent color, or just the color coordinates? true for a dword\r\n\tint transparentR, int transparentG, int transparentB,// components of the transparent color\r\n\tint xTransparent, int yTransparent,// coordinates of the transparent color\r\n\tint desiredWidth, int desiredHeight)// size for the image in the case it's supposed to be loaded empty (filename=NULL)\r\n{\r\n\t// Set all up...\r\n\tresourceName=resName;\r\n\tgraphicResourceClass::fileName=fileName;\r\n\tgraphicResourceClass::allocateInTheFastestMemory=allocateInTheFastestMemory;\r\n\tgraphicResourceClass::useVideoMemory=useVideoMemory;\r\n\tgraphicResourceClass::isFileOrResource=isFileOrResource;\r\n\tgraphicResourceClass::resourceType=resourceType;\r\n\tgraphicResourceClass::isBMPorPCX=isBMPorPCX;\r\n\tgraphicResourceClass::isTransparent=isTransparent;\r\n\tgraphicResourceClass::usesTransparentRGB=usesTransparentRGB;\r\n\tgraphicResourceClass::transparentR=transparentR;\r\n\tgraphicResourceClass::transparentG=transparentG;\r\n\tgraphicResourceClass::transparentB=transparentB;\r\n\tgraphicResourceClass::xTransparent=xTransparent;\r\n\tgraphicResourceClass::yTransparent=yTransparent;\r\n\tgraphicResourceClass::desiredWidth=desiredWidth;\r\n\tgraphicResourceClass::desiredHeight=desiredHeight;\r\n}// constructor for graphicResourceClass\r\n\r\n// rawLoad: our function for loading the resource this object contains.\r\n// Only loads the file.\r\nbool graphicResourceClass::rawLoad()\r\n{\r\n\t// First check the case files are not needed at all\r\n\tif (fileName==NULL){\r\n\t\t// In such case, there is nothing to load at all\r\n\t\treturn true;// all ok\r\n\t}// if\r\n\tif (!surface.createFromGeneralImage((BYTE*)fileName, useVideoMemory))\r\n\t\treturn false;\r\n/*\r\n\t// Load the file\r\n\tif (isFileOrResource){\r\n\t\tif (isBMPorPCX){\r\n\t\t\t// load a bmp file\r\n\t\t\tif (!surface.loadBmpFile(fileName, useVideoMemory))\r\n\t\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\t// load a pcx file\r\n\t\t\tif (!surface.loadPcxFile(fileName, useVideoMemory))\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t}else{\r\n\t\tif (isBMPorPCX){\r\n\t\t\t// load a bmp resource from the executable file\r\n\t\t\tif (!surface.loadBmpResource(fileName, hInstance,\r\n\t\t\t\tuseVideoMemory))\r\n\r\n\t\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\t// load a pcx resource from the executable file\r\n\t\t\tif (!surface.loadPcxResource(fileName, resourceType,\r\n\t\t\t\tuseVideoMemory))\r\n\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n*/\r\n\treturn true;// all ok!\r\n}// rawLoad\r\n\r\n// Load: our function for loading and setting the resource this object\r\n// contains up.\r\nbool graphicResourceClass::load()\r\n{\r\n\t// not even try to load the resource if it's already up and running\r\n\tif (isLoaded()) return true;\r\n\r\n/*\t// If allocateInTheFastestMemory is true, decide what useVideoMemory\r\n\t// should be for fastest blts (supposing that isTransparent=true only\r\n\t// if it's going to be blt transparently always)\r\n\tif (allocateInTheFastestMemory){\r\n\t\tif (!isTransparent){\r\n\t\t\t// not transparent, video memory is faster that way\r\n\t\t\tuseVideoMemory=false;\r\n\t\t}else{\r\n\t\t\t// transparent, let's see what's better\r\n\t\t\tuseVideoMemory=\r\n\t\t\t\tsurface.getDDObject()->doesHardwareTransparentBlt();\r\n\t\t}// if\r\n\t}// if\r\n*/\r\n\t// If it's needed, create the surface (it's only needed if it doesn't\r\n\t// require being loaded)\r\n\tif (fileName==NULL){\r\n\t\t// create the surface...\r\n\t\tif (!surface.create(desiredWidth, desiredHeight, useVideoMemory))\r\n\t\t\treturn false;\r\n\t}// if\r\n\r\n\t// Load the surface itself, and check there aren't errors.\r\n\tif (!rawLoad()) return false;\r\n/*\r\n\t// Set the transparent color if necessary\r\n\tif (isTransparent){\r\n\t\tif (usesTransparentRGB){\r\n\t\t\t// set the transparent color from the three color components\r\n\t\t\tif (!surface.setTransparentColorFromRGB(\r\n\t\t\t\ttransparentR, transparentG, transparentB))\r\n\t\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\t// set the transparent color from the pixel color placed\r\n\t\t\t// at the given coordinates\r\n\t\t\tif (!surface.setTransparentColorFromPixel(\r\n\t\t\t\txTransparent, yTransparent))\r\n\r\n\t\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n*/\r\n\treturn true;// all ok!\r\n}// load\r\n\r\n// Reload: our function for setting the resource this object contains up,\r\n// when it's already loaded, but needs to be reloaded.\r\nbool graphicResourceClass::reload()\r\n{\r\n\t// if the surface wasn't loaded before, return an error code\r\n\tif (!isLoaded()) return false;\r\n\r\n\t// don't ever bother reloading the surface, if it's not been lost\r\n\t// at all\r\n\tif (!needsToBeReloaded()) return true;\r\n\r\n\t// If the surface can't be restored, it's an error, but not an\r\n\t// important one, as it only indicates that's not the time for\r\n\t// restoring the surface yet, try again later. So we return our\r\n\t// \"ok\" error code, true, meaning it's all ok for us.\r\n\tif (!surface.restore()) return true;\r\n\r\n\t// Load the surface itself, and check there aren't errors.\r\n\tif (!rawLoad()) return false;\r\n\r\n\treturn true;// all ok!\r\n}// reload\r\n\r\n// Unload: our function for unloading the resource this object contains.\r\nbool graphicResourceClass::unload()\r\n{\r\n\t// Don't ever bother unloading the resource if it's not loaded yet\r\n\tif (!isLoaded()) return true;\r\n\r\n\treturn surface.free();\r\n}// unload\r\n\r\n\r\n// WAVE RESOURCE CLASS METHODS\r\n/*\r\n// The parametrized constructor\r\nwaveResourceClass::waveResourceClass(\r\n\tchar* resName,// resource name\r\n\tchar* fileName,// file from where we'll take the wave when loading\r\n\tchar hardOrSoft)// a char telling where sounds will go, options are FILE_AUDIOWRAP_WAVE_DEFER, FILE_AUDIOWRAP_WAVE_HARDWARE and FILE_AUDIOWRAP_WAVE_SOFTWARE\r\n{\r\n\t// Set all up...\r\n\tresourceName=resName;\r\n\tfileOgg=NULL;// it hasn't an ogg version\r\n\tfileTemp=NULL;// it hasn't an ogg version, so no temp either\r\n\twaveResourceClass::fileName=fileName;\r\n\twaveResourceClass::hardOrSoft=hardOrSoft;\r\n}// constructor for waveResourceClass\r\n\r\n// The parametrized constructor, in the version of the file having an\r\n// ogg version file.\r\n// We don't care about OGGs here, only we do for knowing where the ogg\r\n// version is for the decoder to know.\r\nwaveResourceClass::waveResourceClass(\r\n\tchar* resName,// resource name\r\n\tchar* oggFileName,// where we'll take the ogg version of the file from\r\n\tchar* fileName,// file from where we'll take the wave when loading\r\n\tchar* fileTemp,// name of the file we'll use temporary for decoding the ogg\r\n\tchar hardOrSoft)// a char telling where sounds will go, options are FILE_AUDIOWRAP_WAVE_DEFER, FILE_AUDIOWRAP_WAVE_HARDWARE and FILE_AUDIOWRAP_WAVE_SOFTWARE\r\n{\r\n\t// Set all up...\r\n\tresourceName=resName;\r\n\tfileOgg=oggFileName;// it has an ogg version\r\n\twaveResourceClass::fileTemp=fileTemp;// temporary version for the ogg decoding\r\n\twaveResourceClass::fileName=fileName;\r\n\twaveResourceClass::hardOrSoft=hardOrSoft;\r\n}// constructor for waveResourceClass\r\n\r\n\r\n// rawLoad: our function for loading the resource this object contains.\r\n// Only loads the file.\r\nbool waveResourceClass::rawLoad()\r\n{\r\n\t// Load the file\r\n\tif (!waveFile.open(fileName, hardOrSoft)) return false;\r\n\r\n\treturn true;// all ok!\r\n}// rawLoad\r\n\r\n// Load: our function for loading and setting the resource this object\r\n// contains up.\r\nbool waveResourceClass::load()\r\n{\r\n\t// not even try to load the resource if it's already up and running\r\n\tif (isLoaded()) return true;\r\n\r\n\t// Load the surface itself, and check there aren't errors.\r\n\tif (!rawLoad()) return false;\r\n\r\n\treturn true;// all ok!\r\n}// load\r\n\r\n// Reload: our function for setting the resource this object contains up,\r\n// when it's already loaded, but needs to be reloaded.\r\nbool waveResourceClass::reload()\r\n{\r\n\t// if the surface wasn't loaded before, return an error code\r\n\tif (!isLoaded()) return false;\r\n\r\n\t// don't ever bother reloading the surface, if it's not been lost\r\n\t// at all\r\n\tif (!needsToBeReloaded()) return true;\r\n\r\n\t// If the surface can't be restored, it's an error, but not an\r\n\t// important one, as it only indicates that's not the time for\r\n\t// restoring the surface yet, try again later. So we return our\r\n\t// \"ok\" error code, true, meaning it's all ok for us.\r\n\tif (!waveFile.restore()) return true;\r\n\r\n\t// Load the surface itself, and check there aren't errors.\r\n\tif (!rawLoad()) return false;\r\n\r\n\treturn true;// all ok!\r\n}// reload\r\n\r\n// Unload: our function for unloading the resource this object contains.\r\nbool waveResourceClass::unload()\r\n{\r\n\t// Don't ever bother unloading the resource if it's not loaded yet\r\n\tif (!isLoaded()) return true;\r\n\r\n\treturn waveFile.close();\r\n}// unload\r\n\r\n\r\n\r\n// MIDI RESOURCE CLASS METHODS\r\n\r\n// Midi objects never need to be reloaded.\r\n\r\n// The parametrized constructor\r\nmidiResourceClass::midiResourceClass(\r\n\tchar* resName,// resource name\r\n\tchar* fileName)// file name\r\n{\r\n\t// Set all up...\r\n\tresourceName=resName;\r\n\tmidiResourceClass::fileName=fileName;\r\n}// constructor for midiResourceClass\r\n\r\n// Load: our function for loading and setting the resource this object\r\n// contains up.\r\nbool midiResourceClass::load()\r\n{\r\n\t// not even try to load the resource if it's already up and running\r\n\tif (isLoaded()) return true;\r\n\r\n\t// Load the midi file\r\n\treturn midiMusic.open(fileName);\r\n}// load\r\n\r\n// Unload: our function for unloading the resource this object contains.\r\nbool midiResourceClass::unload()\r\n{\r\n\t// Don't ever bother unloading the resource if it's not loaded yet\r\n\tif (!isLoaded()) return true;\r\n\r\n\treturn midiMusic.close();\r\n}// unload\r\n*/\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n#include \"globals.h\"// for using the program objects\r\n#include \"fileString.h\"// for accessing to strings, memory, files and windows resources in an only simple way\r\n#include \"menucode.h\"// for accesing to the methods related to the program zone corresponding to the game menues\r\n/*#include \"gameglobals.h\"// for using the game objects\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include \"timewrap.h\"// for using the time wrapper class\r\n*/\r\n// header files for using lua\r\nextern \"C\"{\r\n\t#include <lua.h>\r\n\t#include <lualib.h>\r\n\t#include <lauxlib.h>\r\n}// extern\r\n\r\n#define lua_dostring luaL_dostring // change in Lua 5.1\r\n#define luaL_dobuffer(l, buff, size, name) (luaL_loadbuffer(l, buff, size, name) || lua_pcall(l, 0, LUA_MULTRET, 0))\r\n#define lua_dobuffer luaL_dobuffer\r\n\r\n\r\n// LUA INTERNAL FUNCTIONS\r\n\r\n// luaLogToFile *******\r\n// a function used for logging from a Lua script to the logs file\r\nstatic int luaLogToFile(lua_State* lstate)\r\n{\r\n\tint i;\r\n\tint n=lua_gettop(lstate);\r\n\r\n\tfor (i=1; i<=n; i++){\r\n\t\tlogger.logLine(\"[Lua msg] %s\", true, true, false,\r\n\t\t\tlua_tostring(lstate, i));\r\n\t}// for\r\n\r\n\treturn 0;// there are no return values\r\n}// luaLogToFile\r\n\r\n// SCRIPT MANAGER METHODS\r\n// ======================\r\n\r\n// INIT / DEINIT METHODS\r\n\r\n// init *********\r\n// method used for the initialization of this object\r\nbool scriptManagerClass::init()\r\n{\r\n\tfileStringClass luadata;\r\n\tchar* scriptName;\r\n\ttimeWrapperClass timer;\r\n\r\n\t// check for previous initialization\r\n\tif (ready) return false;// error\r\n\r\n\t// log it\r\n\tlogger.logLine(\"Initializing scripting manager...\", true, false);\r\n\r\n\t// open lua\r\n\tlstate=luaL_newstate();\r\n\tif (lstate==NULL){\r\n\t\tlogger.logLine(\"Failed opening Lua\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// open the extra libraries\r\n\tluaopen_base(lstate);\r\n\tluaopen_string(lstate);\r\n\tluaopen_table(lstate);\r\n\tluaopen_math(lstate);\r\n\r\n\t// register our logging function\r\n\tlua_register(lstate, \"logToFile\", luaLogToFile);\r\n\t// register our drawing images function for the menues\r\n\tlua_register(lstate, \"menuBltImage\", luaMenuBltImage );\r\n\t// register our drawing texts function for the menues\r\n\tlua_register(lstate, \"menuDrawText\", luaMenuDrawText);\r\n\t// register our function that switches to other menues\r\n\tlua_register(lstate, \"switchToMenu\", luaSwitchToMenu);\r\n\t// register our function that moves the mouse\r\n\tlua_register(lstate, \"menuSetMouseXY\", luaMenuSetMouseXY);\r\n\t// register our function that switches the current language\r\n\tlua_register(lstate, \"setCurrentLanguage\", luaSetCurrentLanguage);\r\n\t// register our function that updates the high scores list\r\n\tlua_register(lstate, \"updateHighScoresList\",\r\n\t\tluaUpdateHighScoresList);\r\n\t// register our function that changes the sound enabled field\r\n\tlua_register(lstate, \"setSoundEnabled\", luaSetSoundEnabled);\r\n\t// register our function that plays a given sound\r\n\tlua_register(lstate, \"playSoundResource\", luaPlaySoundResource);\r\n\t// register our function that stops playing a given sound\r\n\tlua_register(lstate, \"stopSoundResource\", luaStopSoundResource);\r\n\t// register our function that stops and plays a given sound\r\n\tlua_register(lstate, \"stopAndPlaySoundResource\",\r\n\t\tluaStopAndPlaySoundResource);\r\n\t// register our function that resets the high scores\r\n\tlua_register(lstate, \"resetHighScores\",\r\n\t\tluaResetHighScores);\r\n\r\n\t// save the desiredFramesPerSecond variable in Lua\r\n\tlua_pushnumber(lstate, desiredFramesPerSecond);\r\n\tlua_setglobal(lstate, \"desiredFramesPerSecond\");\r\n\r\n\t// set the current language in lua\r\n\tthis->setCurrentLanguageInLua(currentLanguage);\r\n\r\n\t// Execute SCRIPTFILES\r\n\t// open the script data from a text file...\r\n\tif (!luadata.openFromFile(\"data/scripts/scriptfiles.lua\")){\r\n\r\n\t\tluadata.close();\r\n\t\tif (!luadata.openFromFile(\r\n\t\t\t\"data/scriptsdata/scriptfiles.lua\")){\r\n\r\n\t\t\tlogger.logLine(\"Failed opening scriptfiles.lua\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t}// if\r\n\t// load the lua data to lua\r\n\tif (lua_dobuffer(\r\n\t\tlstate,// lua state\r\n\t\t(char*)luadata.getDataPointer(),\r\n\t\tluadata.getDataSize(),\r\n\t\t\"redia load list script\")!=0)\r\n\t{\r\n\t\tlogger.logLine(\"Failed executing pre load buffer\");\r\n\t\treturn false;\r\n\t}// if\r\n\t// ready\r\n\tluadata.close();\r\n\r\n\t// Now, for every value in the scriptFilesList, execute a lua\r\n\t// script\r\n\tlua_getglobal(lstate, \"scriptFilesList\");\r\n\tlua_pushnil(lstate);\r\n\twhile (lua_next(lstate, -2)!=0){\r\n\t\t// execute the script on the list\r\n\t\tscriptName=(char*)(lua_tostring(lstate, -1));\r\n\t\tif (!luadata.openFromFile(scriptName)){\r\n\t\t\tlogger.logLine(\"Failed opening %s for lua\",\r\n\t\t\t\ttrue, true, true, scriptName);\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// load the lua data to lua\r\n\t\tif (lua_dobuffer(\r\n\t\t\tlstate,// lua state\r\n\t\t\t(char*)luadata.getDataPointer(),\r\n\t\t\tluadata.getDataSize(),\r\n\t\t\tscriptName)!=0)\r\n\t\t{\r\n\t\t\tlogger.logLine(\"Failed executing the %s lua script\",\r\n\t\t\t\ttrue, true, true, scriptName);\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\t\t// ready\r\n\t\tluadata.close();\r\n\r\n\t\t// set up for the next step of the loop\r\n\t\tlua_pop(lstate, 1);\r\n\t}// while\r\n\t// remove the table and the key value as well\r\n\tlua_pop(lstate, 2);\r\n\r\n\r\n\t// time the use of lua\r\n\tif (!timer.init()) return false;\r\n\r\n\t// execute the initialize function before starting\r\n\tif (lua_dostring(lstate, \"startScript()\")!=0){\r\n\t\tlogger.logLine(\"Failed executing the initialize script\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// ready, log the time it took to execute lua\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogger.logLine(\"Time in setting up lua: %f\",\r\n\t\ttrue, true, true, timer.getTime()/1000.0);\r\n#endif // PROGMODE_DEVELOPER_YES\r\n\ttimer.end();\r\n\r\n\t// set flags\r\n\tready=true;\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// init\r\n\r\n// close ********\r\n// method used for the deinitialization of this object\r\nbool scriptManagerClass::close()\r\n{\r\n\t// check for previous initialization\r\n\tif (!ready) return false;// error\r\n\r\n\t// close lua\r\n\tlua_close(lstate);\r\n\r\n\t// set flags\r\n\tready=false;\r\n\r\n\treturn true;// all ok\r\n}// close\r\n\r\n// GENERAL PURPOSE INTERFACES\r\n// getIntVariable ********\r\n// method used for obtaining the value attached to a given integer\r\n// variable, given the variable name.\r\n// errCode is the pointer to a bool variable to set with true if\r\n// all went ok, and to set with false if there was any errors. it\r\n// might be NULL (default value) for avoiding such work\r\nint scriptManagerClass::getIntVariable(char* varName, bool* errCode)\r\n{\r\n\tbool success=true;// all ok by default\r\n\tint value;\r\n\r\n\t// check for previous initialization\r\n\tif (!ready || varName==NULL){\r\n\t\t// error\r\n\t\tsuccess=false;\r\n\t\tif (errCode!=NULL) *errCode=success;\r\n\t\treturn 0;\r\n\t}// if\r\n\r\n\t// get the asked value\r\n\tlua_getglobal(lstate, varName);\r\n\tvalue=int(lua_tonumber(lstate, -1));\r\n\tlua_pop(lstate, 1);// discard\r\n\r\n\t// all ok\r\n\tif (errCode!=NULL) *errCode=success;\r\n\treturn value;\r\n}// getIntVariable\r\n\r\n// getDoubleVariable ********\r\n// method used for obtaining the value attached to a given double\r\n// variable, given the variable name\r\n// errCode is the pointer to a bool variable to set with true if\r\n// all went ok, and to set with false if there was any errors. it\r\n// might be NULL (default value) for avoiding such work\r\ndouble scriptManagerClass::getDoubleVariable(char* varName, bool* errCode)\r\n{\r\n\tbool success=true;// all ok by default\r\n\tdouble value;\r\n\r\n\t// check for previous initialization\r\n\tif (!ready || varName==NULL){\r\n\t\t// error\r\n\t\tsuccess=false;\r\n\t\tif (errCode!=NULL) *errCode=success;\r\n\t\treturn 0;\r\n\t}// if\r\n\r\n\t// get the asked value\r\n\tlua_getglobal(lstate, varName);\r\n\tvalue=lua_tonumber(lstate, -1);\r\n\tlua_pop(lstate, 1);// discard\r\n\r\n\t// all ok\r\n\tif (errCode!=NULL) *errCode=success;\r\n\treturn value;\r\n}// getDoubleVariable\r\n\r\n// getStringValue ***********\r\n// method used for obtaining the value attached to a given string\r\n// variable, given the variable name\r\n// errCode is the pointer to a bool variable to set with true if\r\n// all went ok, and to set with false if there was any errors. it\r\n// might be NULL (default value) for avoiding such work\r\nchar* scriptManagerClass::getStringValue(char* varName, bool* errCode)\r\n{\r\n\tbool success=true;// all ok by default\r\n\tchar* value;\r\n\r\n\t// check for previous initialization\r\n\tif (!ready || varName==NULL){\r\n\t\t// error\r\n\t\tsuccess=false;\r\n\t\tif (errCode!=NULL) *errCode=success;\r\n\t\treturn 0;\r\n\t}// if\r\n\r\n\t// get the asked value\r\n\tlua_getglobal(lstate, varName);\r\n\tvalue=(char*)(lua_tostring(lstate, -1));\r\n\tlua_pop(lstate, 1);// discard\r\n\r\n\t// all ok\r\n\tif (errCode!=NULL) *errCode=success;\r\n\treturn value;\r\n}// getStringValue\r\n\r\n// doString ********\r\n// this method executes a given string as a lua command, and returns\r\n// the typical error code\r\nbool scriptManagerClass::doString(char* string)\r\n{\r\n\t// check for previous initialization\r\n\tif (!ready) return false;// error\r\n\r\n\tif (lua_dostring(lstate, string)!=0){\r\n\t\treturn false;// error\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// doString\r\n\r\n// setCurrentLanguageInLua **********\r\n// This method sets an environment variable telling which language\r\n// is currently active, only in Lua\r\nbool scriptManagerClass::setCurrentLanguageInLua(languageEnum lang)\r\n{\r\n\t// check for previous initialization\r\n\tif (!ready) return false;// error\r\n\r\n\t// change the currentLanguage variable in Lua\r\n\tif (lang==language_spanish){\r\n\t\tlua_pushstring(lstate, \"spanish\");\r\n\t}else{\r\n\t\tlua_pushstring(lstate, \"english\");\r\n\t}// if\r\n\tlua_setglobal(lstate, \"currentLanguage\");\r\n\r\n\treturn true;// all ok\r\n}// setCurrentLanguageInLua\r\n\r\n// setSoundEnabledInLua **********\r\n// This method sets an environment variable telling whether the\r\n// sound is currently enabled or not\r\nbool scriptManagerClass::setSoundEnabledInLua(\r\n\tbool nowEnabled,// whether the user selected enabled or disabled\r\n\tbool soundActive)// whether it's currently active in the program (would need restarting the program to change)\r\n{\r\n\t// check for previous initialization\r\n\tif (!ready) return false;// error\r\n\r\n\t// change the currentLanguage variable in Lua\r\n\tlua_pushboolean(lstate, nowEnabled);\r\n\tlua_setglobal(lstate, \"programSoundEnabled\");\r\n\tlua_pushboolean(lstate, soundActive);\r\n\tlua_setglobal(lstate, \"programSoundActive\");\r\n\r\n\treturn true;// all ok\r\n}// setSoundEnabledInLua\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n// That's a little class used to draw scrolling texts in the screen\r\n\r\n#include \"ddwrap.h\"\r\n#include \"scrolltext.h\"\r\n\r\n\r\n// Initialize the scrollText object...\r\nbool scrollTextClass::init(\r\n\tint width, int height,// size of the surface to write into\r\n\tint r, int g, int b,// color of the text\r\n\tint rB, int gB, int bB,// color of the background\r\n\tbool videoMemory)// is in video memory?\r\n{\r\n/*\t// set all up for the calculate text\r\n\tint tempInt=width;\r\n\tfontHeight=0;\r\n\r\n\tif (initialized) return false;\r\n\r\n\t// initialize the surface and calculate the amount of lines\r\n\tif (!surface.create(width, height, videoMemory)) return false;\r\n\tif (!surface.calculateText(\"z\\nz\", FILE_DDWRAP_ALIGN_LEFT,\r\n\t\ttempInt, fontHeight)){\r\n\r\n\t\tsurface.free();\r\n\t\treturn false;\r\n\t}// if\r\n\tfontHeight/=2;// I measured two lines\r\n\tnumLines=height/fontHeight;\r\n\r\n\t// remember the colors to use\r\n\tscrollTextClass::r=r;\r\n\tscrollTextClass::g=g;\r\n\tscrollTextClass::b=b;\r\n\tscrollTextClass::rB=rB;\r\n\tscrollTextClass::gB=gB;\r\n\tscrollTextClass::bB=bB;\r\n\r\n\t// time to clear the surface\r\n\tclearSurface();\r\n\r\n\tinitialized=true;*/\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// Close the scroll object.\r\nbool scrollTextClass::end()\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\t// bye bye surface\r\n\tif (!surface.free()) return false;\r\n\r\n\tinitialized=false;*/\r\n\treturn true;// all ok\r\n}// end\r\n\r\n// Scroll some amount of lines up.\r\nbool scrollTextClass::scrollLines(int lines)\r\n{\r\n/*\tint linesToMove=numLines-lines;\r\n\tint yBlock=lines*fontHeight;\r\n\tint hBlock=linesToMove*fontHeight;\r\n\r\n\tif (!initialized) return false;\r\n\r\n\tif (!surface.bltFrom(\r\n\t\tsurface,// copy from this one\r\n\t\t0, 0,// destination pos\r\n\t\t0, yBlock,// source block\r\n\t\tsurface.getWidth(), hBlock// size of the block to move\r\n\t\t)) return false;\r\n\r\n\t// fill the remaining space with the background color\r\n\tif (!surface.fillRect(rB, gB, bB,\r\n\t\t0, hBlock)) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// scrollLines\r\n\r\n// Writes a text in the latest line of the scrolling text.\r\nbool scrollTextClass::writeLatestLine(char* text)\r\n{\r\n/*\tif (!initialized) return false;\r\n\r\n\tif (!surface.fillRect(rB, gB, bB, 0, (numLines-1)*fontHeight))\r\n\t\treturn false;\r\n\r\n\t// write the text\r\n\tif (!surface.writeText(text, r, g, b, FILE_DDWRAP_ALIGN_LEFT,\r\n\t\t0, (numLines-1)*fontHeight)) return false;\r\n*/\r\n\treturn true;// all ok\r\n}// writeLatestLine\r\n\r\n\r\n// Copies the current image of the scroll text surface to some\r\n// graphic object (surface), in the coordinates specified.\r\nbool scrollTextClass::blt(ddSurfaceClass& srf, int x, int y)\r\n{\r\n\tif (!initialized) return false;\r\n\r\n\t// go blit it\r\n//\tif (!srf.bltFrom(surface, x, y)) return false;\r\n\r\n\treturn true;// all ok!\r\n}// blt\r\n\r\n// it's used to paint the background of the surface, so clearing it\r\n// (and also making it be ready, if it's just being initialized)\r\nbool scrollTextClass::clearSurface()\r\n{\r\n/*\t// paint the console background now\r\n\tif (!surface.fillRect(rB, gB, bB, 0, 0)) return false;\r\n*/\r\n\treturn true;\r\n}// clearSurface\r\n\r\n// Tell us if the surface where we store the scrolling text\r\n// is lost (meaning it has to be restored)\r\nbool scrollTextClass::isLost(bool* errorCode)\r\n{\r\n\t// check if it's lost\r\n//\treturn surface.isLost(errorCode);\r\n\treturn true;\r\n}// isLost\r\n\r\n// Restore the surface where we use to draw the scrolling object.\r\n// The surface obtained could not keep the text, as it could have been\r\n// lost together with the surface.\r\nbool scrollTextClass::restore()\r\n{\r\n/*\t// restore the surface itself\r\n\tif (!surface.restore())\r\n\t\treturn false;// something failed\r\n*/\r\n\t// now clear the surface\r\n\treturn clearSurface();\r\n}// restore\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"sheepai.h\"// for managing the AI of a specific type of enemies, the sheeps\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions\r\n\r\n\r\n\r\n// sheepLinearMovementDoneEvent *******\r\n// This is the code to be executed when a sheep finishes with the\r\n// execution of a linear movement.\r\nbool sheepLinearMovementDoneEvent(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)\r\n{\r\n\tint minX, maxX;\r\n\tframeDataStruct* headFrame;\r\n\tint headX;// x we consider in the head\r\n\tvectorListNodeStruct<enemyUnitStruct> *head;\r\n\tframeDataStruct* gettingHeadsFrame;\r\n\r\n\t// update the gettingHeadsFrame now\r\n\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\tgettingHeadsFrame=\r\n\t\t\t&(getUnitFramesList(&unit.data)[\r\n\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\"whiteSheepGettingAHead\")]);\r\n\t}else{\r\n\t\tgettingHeadsFrame=\r\n\t\t\t&(getUnitFramesList(&unit.data)[\r\n\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\"blackSheepGettingAHead\")]);\r\n\t}// if\r\n\r\n\t// to avoid mistakes, update the frame info\r\n\tframeDataStruct* myUnitFrame=getUnitFrame(&unit.data);\r\n\r\n\t// check what kind of switch it was\r\n\tif (unit.data.aiSpecific.sheepData.nowFalling){\r\n\t\t// it was falling, and has just stopped the free fall\r\n\t\tunit.data.aiSpecific.sheepData.nowFalling=false;\r\n\t\tunit.data.aiSpecific.sheepData.nowJumpingForHigh=false;\r\n\r\n\t\t// it has finished falling, make it go to the\r\n\t\t// sheepAtGround frame\r\n\t\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\tunit.data.currentFrame=\r\n\t\t\t\tgetFrameIndexAndListByName(\"whiteSheepAtGround\");\r\n\t\t}else{\r\n\t\t\tunit.data.currentFrame=\r\n\t\t\t\tgetFrameIndexAndListByName(\"blackSheepAtGround\");\r\n\t\t}// if\r\n\t\t// continue auto framing\r\n\t\tunit.data.vFramesPassed=0;\r\n\r\n\t}else{\r\n\t\t// just make the sheep walk and that's all\r\n\t\tif (!makeSheepWalk(unit)) return false;\r\n\t}// if\r\n\r\n\r\n\t// check if we can get a head now\r\n\tif (unit.data.slaveUnit.objectType==\r\n\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t// SET YOURSELF AS THE OWNER OF A NEAR HEAD !\r\n\t\t// acceptable range for near heads\r\n\t\tminX=int(unit.data.x)+gettingHeadsFrame->adherenceX-3;\r\n\t\tmaxX=int(unit.data.x)+gettingHeadsFrame->adherenceX+3;\r\n\r\n\t\t// Check all the heads until finding an useful one\r\n\t\tfor (head=enemyList.getFirstNode();\r\n\t\t\thead!=NULL &&\r\n\t\t\t\tunit.data.slaveUnit.objectType==// for interrupting as soon as it gets a near head\r\n\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\t\t\thead=enemyList.getNextNode(head)){\r\n\r\n\t\t\t// frame of the head\r\n\t\t\tif (head->data.unitType==// it's a head\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\thead->data.nowActive){\r\n\r\n\t\t\t\theadFrame=getUnitFrame(&head->data);\r\n\t\t\t\theadX=int(head->data.x)+headFrame->adherenceX;\r\n\t\t\t}// if\r\n\r\n\t\t\t// filter the unit\r\n\t\t\tif (head->data.nowActive &&// it's active\r\n\t\t\t\thead->data.unitType==// it's a head\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\thead->data.slaveOf.objectType==// it's not busy already\r\n\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY &&\r\n\t\t\t\t!head->data.aiSpecific.headData.fallingHead &&// it's not falling anymore\r\n\t\t\t\theadX>=minX &&// it's near\r\n\t\t\t\theadX<=maxX){\r\n\r\n\t\t\t\t// then take that head\r\n\t\t\t\t// take it\r\n\t\t\t\tunit.data.slaveUnit.id=head->data.id;\r\n\t\t\t\tunit.data.slaveUnit.listIndex=\r\n\t\t\t\t\tenemyList.getIndex(head);\r\n\t\t\t\tunit.data.slaveUnit.objectType=\r\n\t\t\t\t\thead->data.objectType;\r\n\r\n\t\t\t\t// mark this one as the other's owner\r\n\t\t\t\thead->data.slaveOf.id=unit.data.id;\r\n\t\t\t\thead->data.slaveOf.listIndex=\r\n\t\t\t\t\tenemyList.getIndex(&unit);\r\n\t\t\t\thead->data.slaveOf.objectType=\r\n\t\t\t\t\tunit.data.objectType;\r\n\r\n\t\t\t\t// and change the head's frame accordingly\r\n\t\t\t\tif (unit.data.unitType==\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\t\t\thead->data.currentFrame=\r\n\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\"humanHeadCarriedBySheep\");\r\n\t\t\t\t\thead->data.vFramesPassed=0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\thead->data.currentFrame=\r\n\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\"humanHeadCarriedByBody\");\r\n\t\t\t\t\thead->data.vFramesPassed=0;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// and change the sheep's frame accordingly\r\n\t\t\t\tif (unit.data.unitType==\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\"whiteSheepGettingAHead\");\r\n\t\t\t\t\tunit.data.vFramesPassed=0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tunit.data.currentFrame=\r\n\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\"blackSheepGettingAHead\");\r\n\t\t\t\t\tunit.data.vFramesPassed=0;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// and stop moving this one\r\n\t\t\t\tunit.data.goingToPoint=false;\r\n\r\n\t\t\t\t// we only draw it together with the owner\r\n\t\t\t\thead->data.nowDrawable=false;\r\n\t\t\t}// if\r\n\t\t}// for\r\n\t}// if\r\n\r\n\r\n// old, disabled code\r\n/*\tif (unit.data.aiSpecific.sheepData.nowJumpingForHigh){\r\n\t\t// it was jumping, now make it fall\r\n\t\tunit.data.aiSpecific.sheepData.nowJumpingForHigh=false;\r\n\r\n\t\t// set the going to fields\r\n\t\tunit.data.goingToPoint=true;\r\n\t\t// goingToPointX by default\r\n\t\tunit.data.goingToPointX=unit.data.x-\r\n\t\t\tunit.data.aiSpecific.sheepData.jumpHDistance/2;\r\n\t\tunit.data.goingToPointY=\r\n\t\t\tgetGroundWall(int(unit.data.goingToPointX))-\r\n\t\t\tgetUnitFramesList(&unit.data)[quietFrameNum].cH+\r\n\t\t\tgetUnitFramesList(&unit.data)[quietFrameNum].handlerY;\r\n\r\n\t\t// the going to X depends on the presence of heads\r\n\t\tif (unit.data.slaveUnit.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t\t// LOOK FOR A NEAR HEAD !\r\n\t\t\t// acceptable range for near heads\r\n\t\t\tminX=int(unit.data.x)-\r\n\t\t\t\tunit.data.aiSpecific.sheepData.jumpHDistance\r\n\t\t\t\t-unit.data.aiSpecific.sheepData.maxVarianceHD\r\n\t\t\t\t+myUnitFrame->adherenceX;\r\n\t\t\tmaxX=int(unit.data.x)+myUnitFrame->adherenceX;\r\n\t\t\t// Check all the heads until finding an useful one\r\n\t\t\tfor (head=enemyList.getFirstNode();\r\n\t\t\t\thead!=NULL; head=enemyList.getNextNode(head)){\r\n\r\n\t\t\t\t// frame of the head\r\n\t\t\t\tif (head->data.unitType==// it's a head\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\t\thead->data.nowActive){\r\n\r\n\t\t\t\t\theadFrame=getUnitFrame(&head->data);\r\n\t\t\t\t\theadX=int(head->data.x)+headFrame->adherenceX;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// filter the unit\r\n\t\t\t\tif (head->data.nowActive &&// it's active\r\n\t\t\t\t\thead->data.unitType==// it's a head\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\t\thead->data.slaveOf.objectType==// it's not busy already\r\n\t\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY &&\r\n\t\t\t\t\t!head->data.aiSpecific.headData.fallingHead &&// it's not falling anymore\r\n\t\t\t\t\theadX>=minX &&// it's near\r\n\t\t\t\t\theadX<=maxX){\r\n\r\n\t\t\t\t\t// then go for such head\r\n\t\t\t\t\tunit.data.goingToPointX=\r\n\t\t\t\t\t\theadX-myUnitFrame->adherenceX;\r\n\t\t\t\t}// if\r\n\t\t\t}// for\r\n\t\t}// if\r\n\r\n\t\t// set another frame\r\n\t\t// (don't!)\r\n\t\t// unit.data.currentFrame=0; ???\r\n\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t}else{\r\n\r\n\t\t// it was falling from a jump, now make it jump again\r\n\t\tunit.data.aiSpecific.sheepData.nowJumpingForHigh=true;\r\n\r\n\t\t// check if we can get a head now\r\n\t\tif (unit.data.slaveUnit.objectType==\r\n\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY){\r\n\r\n\t\t\t// SET YOURSELF AS THE OWNER OF A NEAR HEAD !\r\n\t\t\t// acceptable range for near heads\r\n\t\t\tminX=int(unit.data.x)+myUnitFrame->adherenceX-3;\r\n\t\t\tmaxX=int(unit.data.x)+myUnitFrame->adherenceX+3;\r\n\r\n\t\t\t// Check all the heads until finding an useful one\r\n\t\t\tfor (head=enemyList.getFirstNode();\r\n\t\t\t\thead!=NULL &&\r\n\t\t\t\t\tunit.data.slaveUnit.objectType==// for interrupting as soon as it gets a near head\r\n\t\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY;\r\n\t\t\t\thead=enemyList.getNextNode(head)){\r\n\r\n\t\t\t\t// frame of the head\r\n\t\t\t\tif (head->data.unitType==// it's a head\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\t\thead->data.nowActive){\r\n\r\n\t\t\t\t\theadFrame=getUnitFrame(&head->data);\r\n\t\t\t\t\theadX=int(head->data.x)+headFrame->adherenceX;\r\n\t\t\t\t}// if\r\n\r\n\t\t\t\t// filter the unit\r\n\t\t\t\tif (head->data.nowActive &&// it's active\r\n\t\t\t\t\thead->data.unitType==// it's a head\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD &&\r\n\t\t\t\t\thead->data.slaveOf.objectType==// it's not busy already\r\n\t\t\t\t\tFILE_GAMEDATA_GAMEOBJECT_EMPTY &&\r\n\t\t\t\t\t!head->data.aiSpecific.headData.fallingHead &&// it's not falling anymore\r\n\t\t\t\t\theadX>=minX &&// it's near\r\n\t\t\t\t\theadX<=maxX){\r\n\r\n\t\t\t\t\t// then take that head\r\n\t\t\t\t\t// take it\r\n\t\t\t\t\tunit.data.slaveUnit.id=head->data.id;\r\n\t\t\t\t\tunit.data.slaveUnit.listIndex=\r\n\t\t\t\t\t\tenemyList.getIndex(head);\r\n\t\t\t\t\tunit.data.slaveUnit.objectType=\r\n\t\t\t\t\t\thead->data.objectType;\r\n\r\n\t\t\t\t\t// mark this one as the other's owner\r\n\t\t\t\t\thead->data.slaveOf.id=unit.data.id;\r\n\t\t\t\t\thead->data.slaveOf.listIndex=\r\n\t\t\t\t\t\tenemyList.getIndex(&unit);\r\n\t\t\t\t\thead->data.slaveOf.objectType=\r\n\t\t\t\t\t\tunit.data.objectType;\r\n\r\n\t\t\t\t\t// and change the head's frame accordingly\r\n\t\t\t\t\tif (unit.data.unitType==\r\n\t\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\t\t\t\t\thead->data.currentFrame=\r\n\t\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\t\"humanHeadCarriedBySheep\");\r\n\t\t\t\t\t\thead->data.vFramesPassed=0;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\thead->data.currentFrame=\r\n\t\t\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\t\t\"humanHeadCarriedByBody\");\r\n\t\t\t\t\t\thead->data.vFramesPassed=0;\r\n\t\t\t\t\t}// if\r\n\r\n\t\t\t\t\t// we only draw it together with the owner\r\n\t\t\t\t\thead->data.nowDrawable=false;\r\n\t\t\t\t}// if\r\n\t\t\t}// for\r\n\t\t}// if\r\n\r\n\t\t// set the going to fields\r\n\t\tunit.data.goingToPoint=true;\r\n\t\tunit.data.goingToPointX=unit.data.x-\r\n\t\t\tunit.data.aiSpecific.sheepData.jumpHDistance/2\r\n\t\t\t+rand()%(unit.data.aiSpecific.sheepData.maxVarianceHD+1);// and add the variance here! (not when falling though)\r\n\t\tunit.data.goingToPointY=\r\n\t\t\tgetGroundWall(int(unit.data.goingToPointX))-\r\n\t\t\tgetUnitFramesList(&unit.data)[quietFrameNum].cH+// jumping frame\r\n\t\t\tgetUnitFramesList(&unit.data)[quietFrameNum].handlerY// jumping frame\r\n\t\t\t-unit.data.aiSpecific.sheepData.jumpVDistance;// distance to fall from the ground\r\n\r\n\t\t// set another frame\r\n\t\tunit.data.currentFrame=quietFrameNum;// jumping frame\r\n\t\tmyUnitFrame=getUnitFrame(&unit.data);\r\n\t}// if\r\n\r\n\t// finish setting up the going to stuff\r\n\tif (unit.data.isPosRelative){\r\n\t\t// correct the coordinates to be relative\r\n\t\tunit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\tunit.data.goingToPointY-=gameWorld.yCamera;\r\n\t}// if\r\n\t// set the speed for going to such point\r\n\tsetSpeedForLinealMove(&unit.data,\r\n\t\tunit.data.goingToPointX, unit.data.goingToPointY,\r\n\t\tunit.data.linearSpeed);\r\n*/\r\n\t// all ok\r\n\treturn true;\r\n}// sheepLinearMovementDoneEvent\r\n\r\n\r\n\r\n\r\n// makeSheepWalk ***********\r\n// This function makes a given sheep continue walking to the\r\n// ship to the left.\r\nbool makeSheepWalk(\r\n\tvectorListNodeStruct<enemyUnitStruct>& unit)\r\n{\r\n\tint walkingFrameNum;\r\n\tdouble speed;\r\n\t\r\n\t// calculate the walking frame and speed\r\n\tif (unit.data.unitType==FILE_GAMEDATA_ENEMY_WHITESHEEP){\r\n\r\n\t\twalkingFrameNum=getFrameIndexAndListByName(\r\n\t\t\t\"whiteSheepWalking\");\r\n\r\n\t\tspeed=unit.data.linearSpeed;\r\n\t}else{\r\n\t\twalkingFrameNum=getFrameIndexAndListByName(\r\n\t\t\t\"blackSheepWalking\");\r\n\r\n\t\tspeed=unit.data.linearSpeed;\r\n\t}// if\r\n\r\n\r\n\t// set the going to fields\r\n\tunit.data.goingToPoint=true;\r\n\tunit.data.goingToPointX=unit.data.x-5;\r\n\tunit.data.goingToPointY=\r\n\t\tgetGroundWall(int(unit.data.goingToPointX))-\r\n\t\tgetUnitFramesList(&unit.data)[walkingFrameNum].cH+\r\n\t\tgetUnitFramesList(&unit.data)[walkingFrameNum].handlerY;\r\n\r\n\t// finish setting up the going to stuff\r\n\tif (unit.data.isPosRelative){\r\n\t\t// correct the coordinates to be relative\r\n\t\tunit.data.goingToPointX-=gameWorld.xCamera;\r\n\t\tunit.data.goingToPointY-=gameWorld.yCamera;\r\n\t}// if\r\n\t// set the speed for going to such point\r\n\tsetSpeedForLinealMove(&unit.data,\r\n\t\tunit.data.goingToPointX, unit.data.goingToPointY,\r\n\t\tspeed);\r\n\r\n\t// all ok\r\n\treturn true;\r\n}// makeSheepWalk\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"staging.h\"// for the management of stages, levels, and the switching between these\r\n#include \"programinfo.h\"// for general info about the program itself\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"globals.h\"// for using the program objects\r\n#include \"generalmaths.h\"// for mathematical functions\r\n/*#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions*/\r\n\r\n\r\n// getNextLevel **********************\r\n// This function tells what's the next level, since a given\r\n// pair (level, stage)\r\nint getNextLevel(int fromLevel, gameStagesEnum fromStage)\r\n{\r\n\tint level=fromLevel;\r\n\r\n\t// see if it's time to advance a level, or only a stage...\r\n\tswitch(fromStage){\r\n\tcase gmstg_emptyStage:\r\n\t\t// go to the first level!\r\n\t\tlevel=1;\r\n\t\tbreak;\r\n\tcase gmstg_freeHeads:\r\n\t\tlevel++;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// for any other stage, it's not time to advance the level num\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// return the result of our calculations...\r\n\treturn level;\r\n}// getNextLevel\r\n\r\n// getNextStage **********************\r\n// This function tells what's the next stage, since a given\r\n// pair (level, stage)\r\ngameStagesEnum getNextStage(int fromLevel, gameStagesEnum fromStage)\r\n{\r\n\tgameStagesEnum stage=fromStage;\r\n\r\n\t// see what the next stage will be\r\n\tswitch(stage){\r\n\tcase gmstg_emptyStage:\r\n\t\t// start playing\r\n\t\tstage=gmstg_freeSheeps;\r\n\t\tbreak;\r\n\tcase gmstg_freeSheeps:\r\n\t\t// time to go to the stage of head hunting\r\n\t\tstage=gmstg_freeHeads;\r\n\t\tbreak;\r\n\tcase gmstg_freeHeads:\r\n\t\t// time to go to the stage of sheep hunting\r\n\t\tstage=gmstg_freeSheeps;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// for any other stage, we cannot directly change the stage\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// return the result of our calculations...\r\n\treturn stage;\r\n}// getNextStage\r\n\r\n\r\n// activateCurrentStageLevel **********************\r\n// This function configures the current stage and level, so that the\r\n// game starts playing with the current level information\r\nbool activateCurrentStageLevel()\r\n{\r\n\tbool logToConsole;\r\n\tvectorListNodeStruct<waveGenUnitStruct> *wgUnit;\r\n\tstageLevelPropertiesStruct properties;\r\n\r\n\t// obtain the stageLevel properties\r\n\tproperties=getStageLevelProperties(\r\n\t\tgameWorld.currentLevel, gameWorld.currentStage);\r\n\r\n\t// set the time left as given in the properties\r\n\tgameWorld.timeLeftToNextStage=properties.maximumTime;// maximum working time for a stage level, 0 for infinitum\r\n\r\n\t// check the stage information\r\n\tswitch(gameWorld.currentStage){\r\n\tcase gmstg_freeSheeps:\r\n\tcase gmstg_freeHeads:\r\n\t\t// time to activate the stage of sheep / head hunting\r\n\t\t// activate the sheeps / heads wave generators, and deactivate\r\n\t\t// all the other ones...\r\n\t\t// that is, activate either sheeps or heads, not both\r\n\t\tfor (wgUnit=waveGenList.getFirstNode(); wgUnit!=NULL;\r\n\t\t\twgUnit=waveGenList.getNextNode(wgUnit)){\r\n\r\n\t\t\t// don't even mind about this unit if it's not active now\r\n\t\t\tif (!wgUnit->data.nowActive) continue;\r\n\r\n\t\t\t// check what kind of wave gen it is...\r\n\t\t\tswitch(wgUnit->data.unitType){\r\n\t\t\tcase FILE_GAMEDATA_WAVEGEN_WHITESHEEPS:\r\n\t\t\tcase FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS:\r\n\t\t\t\t// only keep this unit active, if it's the level of\r\n\t\t\t\t// freeing sheeps... otherwise deactive it\r\n\t\t\t\twgUnit->data.generatingNow=\r\n\t\t\t\t\t(gameWorld.currentStage==gmstg_freeSheeps);\r\n\r\n\t\t\t\t// how many seconds between waves?\r\n\t\t\t\twgUnit->data.distanceBetweenWaves=\r\n\t\t\t\t\tMAX(0.15,\r\n\t\t\t\t\t1-(gameWorld.currentLevel-1)*0.2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase FILE_GAMEDATA_WAVEGEN_HUMANHEADS:\r\n\t\t\t\t// only keep this unit active, if it's the level of\r\n\t\t\t\t// freeing heads... otherwise deactive it\r\n\t\t\t\twgUnit->data.generatingNow=\r\n\t\t\t\t\t(gameWorld.currentStage==gmstg_freeHeads);\r\n\r\n\t\t\t\t// how many seconds between waves?\r\n\t\t\t\twgUnit->data.distanceBetweenWaves=\r\n\t\t\t\t\tMAX(0.15,\r\n\t\t\t\t\t0.5-(gameWorld.currentLevel-1)*0.1);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// don't ever mind about the other wave generators\r\n\t\t\t\tbreak;\r\n\t\t\t}// switch\r\n\t\t}// for\r\n\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// for any other stage, we cannot activate something we don't\r\n\t\t// know, or a stage that is supposed to be empty! return an error\r\n\t\t// code\r\n\t\treturn false;// error!\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// log the stage activation, to the logs file, and to the console\r\n\t// only if in dev mode\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\tlogToConsole=true;\r\n#else// PROGMODE_DEVELOPER_NO\r\n\tlogToConsole=false;\r\n#endif// PROGMODE_DEVELOPER_NO\r\n\tlogCurrentStageLevelInfo(logToConsole);\r\n\r\n\treturn true;// all ok\r\n}// activateCurrentStageLevel\r\n\r\n\r\n// setStageLevel **********************\r\n// This function sets some given level and stage to be the current ones\r\nbool setStageLevel(int level, gameStagesEnum stage)\r\n{\r\n\t// set these to be the current values\r\n\tgameWorld.currentLevel=level;\r\n\tgameWorld.currentStage=stage;\r\n\r\n\t// activate the current stage and level\r\n\tif (!activateCurrentStageLevel()) return false;\r\n\r\n\treturn true;// all ok\r\n}// setStageLevel\r\n\r\n// logCurrentStageLevelInfo **********************\r\n// A function for logging the current stage level information\r\nbool logCurrentStageLevelInfo(\r\n\tbool toConsole)// log to the console as well, or only to the file?\r\n{\r\n\tchar* strStage;\r\n\r\n\t// look for the right string for the stage\r\n\tswitch(gameWorld.currentStage){\r\n\tcase gmstg_emptyStage:\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tstrStage=\"gmstg_emptyStage\";\r\n#else// PROGMODE_DEVELOPER_NO\r\n\t\tstrStage=\"Empty Stage\";\r\n#endif// PROGMODE_DEVELOPER_NO\r\n\t\tbreak;\r\n\tcase gmstg_freeSheeps:\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tstrStage=\"gmstg_freeSheeps\";\r\n#else// PROGMODE_DEVELOPER_NO\r\n\t\tstrStage=\"Free Sheeps Stage\";\r\n#endif// PROGMODE_DEVELOPER_NO\r\n\t\tbreak;\r\n\tcase gmstg_freeHeads:\r\n#ifdef PROGMODE_DEVELOPER_YES\r\n\t\tstrStage=\"gmstg_freeHeads\";\r\n#else// PROGMODE_DEVELOPER_NO\r\n\t\tstrStage=\"Free Heads Stage\";\r\n#endif// PROGMODE_DEVELOPER_NO\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tstrStage=\"unknown-stage\";\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// log it\r\n\tif (!logger.logLine(\"In stage '%s', level: %i, index: %i\",\r\n\t\ttrue, toConsole, true,// log to file, and maybe to console\r\n\t\tstrStage,// stage name\r\n\t\tgameWorld.currentLevel,// level number\r\n\t\tgetStageLevelIndex(// stage level index\r\n\t\t\tgameWorld.currentLevel, gameWorld.currentStage)\r\n\t\t)){\r\n\r\n\t\treturn false;// error\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// logCurrentStageLevelInfo\r\n\r\n// advanceStage **********************\r\n// This function advances the current stage and level, as they should...\r\nbool advanceStage()\r\n{\r\n\tint level;\r\n\tgameStagesEnum stage;\r\n\tint idx;\r\n\r\n\t// calculate the next stage and level\r\n\tlevel=getNextLevel(gameWorld.currentLevel, gameWorld.currentStage);\r\n\tstage=getNextStage(gameWorld.currentLevel, gameWorld.currentStage);\r\n\r\n\t// calculate the idx\r\n\tidx=getStageLevelIndex(level, stage);\r\n\r\n/*\t// execute the sound of stage advanced, in the case that happens\r\n\tif (stage==gmstg_freeHeads){\r\n\t\t// execute such sound\r\n\t\tmakeSoundAdvanceStage();\r\n\t}// if\r\n*/\r\n/*\t// execute the next ingame music, if that's the time for that\r\n\tswitch (idx){\r\n\tcase 2:\r\n\t\texecuteIngameMusic(2);\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\texecuteIngameMusic(3);\r\n\t\tbreak;\r\n\t}// switch\r\n*/\r\n\r\n\t// set the calculated stage and level up\r\n\tif (!setStageLevel(level, stage)) return false;\r\n\r\n\treturn true;// all ok\r\n}// advanceStage\r\n\r\n\r\n// getStageLevelIndex **********************\r\n// This function maps every pair (level, stage) with a number that tells\r\n// the index of such pair in the stageLevels sequence.\r\n// The stageLevel index is always as follows:\r\n// (1, gmstg_freeSheeps)=0\r\n// (1, gmstg_freeHeads)=1\r\n// (2, gmstg_freeSheeps)=2\r\n// (2, gmstg_freeHeads)=3\r\n// (n, gmstg_freeSheeps)=(n-1)*2+0\r\n// (n, gmstg_freeHeads)=(n-1)*2+1\r\n// Other strange levels: some strange value\r\nint getStageLevelIndex(int level, gameStagesEnum stage)\r\n{\r\n\tint stageNum;\r\n\r\n\t// assign a value to stageNum\r\n\tswitch(stage){\r\n\tcase gmstg_freeSheeps:\r\n\t\tstageNum=0;\r\n\t\tbreak;\r\n\tcase gmstg_freeHeads:\r\n\t\tstageNum=1;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// extra stages have other numbers\r\n\t\tstageNum=0;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n\t// return the calculated stageLevel index\r\n\treturn stageNum+(level-1)*2;\r\n}// getStageLevelIndex\r\n\r\n\r\n// getStageLevelProperties **********************\r\n// This function returns a structure filled with the properties of a\r\n// given stage and level.\r\nstageLevelPropertiesStruct getStageLevelProperties(\r\n\tint level, gameStagesEnum stage)// level and stage to get the properties of\r\n{\r\n\tstageLevelPropertiesStruct properties;\r\n\tint stIndex;\r\n\tdouble timeInSec;\r\n\r\n\t// obtain the stageLevel index for this (level, stage)\r\n\tstIndex=getStageLevelIndex(level, stage);\r\n\r\n\t// fill the properties\r\n\r\n\t// maximumTime:\r\n\t// maximum working time for a stage level, 0 for infinitum\r\n\t// Load in timeInSec the amount in seconds\r\n\tif (stage==gmstg_freeHeads){\r\n\t\t// heads\r\n\t\ttimeInSec=2+(level-1)*1.2;// 2 to infinitum seconds, 1.2 seconds more every time\r\n\t\ttimeInSec=MIN(timeInSec, 6);\r\n\t}else{\r\n\t\t// sheeps or some other level\r\n\t\ttimeInSec=20;\r\n\t}// if\r\n\tproperties.maximumTime=int(timeInSec*desiredFramesPerSecond);\r\n\r\n\t// return the final properties\r\n\treturn properties;\r\n}// getStageLevelProperties\r\n\r\n// getTimeLeftInSeconds **********************\r\n// This is a small function that tells how many seconds are left for the\r\n// switch of stages.\r\ndouble getTimeLeftInSeconds()\r\n{\r\n\t// return it in seconds\r\n\treturn gameWorld.timeLeftToNextStage/double(desiredFramesPerSecond);\r\n}// getTimeLeftInSeconds\r\n\r\n// manageAutomaticStaging **********************\r\n// This function manages the work of the automatic staging, it's to\r\n// be executed exactly once per frame, so it can check whether it's\r\n// time to advance the stage or not, and it can also decrement the\r\n// time counters.\r\nbool manageAutomaticStaging(\r\n\tDWORD frameNumber,// current frame number\r\n\tbool* didItSwitch)// pointer to a boolean where to put the information about whether the stage was changed or not\r\n{\r\n\t// did we advance a level?\r\n\tbool tempDidItSwitch=false;\r\n\r\n\tbool errorCode=true;// all ok\r\n\r\n\t// check for infinite time left\r\n\tif (gameWorld.timeLeftToNextStage!=0){\r\n\t\t// decrement the counter\r\n\t\tgameWorld.timeLeftToNextStage--;\r\n\r\n\t\t// check if it's time to advance\r\n\t\tif (gameWorld.timeLeftToNextStage<=0){\r\n\t\t\t// automatic stage advance\r\n\t\t\tif (!advanceStage())\r\n\t\t\t\terrorCode=false;// failed\r\n\r\n\t\t\t// we advanced a level\r\n\t\t\ttempDidItSwitch=true;\r\n\t\t}// if\r\n\t}// if\r\n\r\n\t// set the didItSwitch value\r\n\tif (didItSwitch!=NULL) *didItSwitch=tempDidItSwitch;\r\n\r\n\t// go away\r\n\treturn errorCode;\r\n}// manageAutomaticStaging\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n\r\n#include \"timewrap.h\"// for using the time wrapper class\r\n#include <SDL.h>\r\n\r\n#define MAX_TICKS 4294967295 // DWORD max-1= (2^32) -1\r\n\r\n// init ***************\r\n// Initialize the class and reset the clock\r\nbool timeWrapperClass::init()\r\n{\r\n\tif (isReady()) return false;\r\n\r\n\t// initialize all\r\n\tinitialized=true;\r\n\tpaused=false;\r\n\tmultiplier=1;// normal value\r\n\r\n\t// now reset the clock\r\n\tif (!reset()){\r\n\t\t// error!\r\n\t\tinitialized=false;\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// init\r\n\r\n// end ****************\r\n// End the class...\r\nbool timeWrapperClass::end()\r\n{\r\n\tif (!isReady()) return false;\r\n\r\n\t// finalize it...\r\n\tinitialized=false;\r\n\r\n\treturn true;// all ok\r\n}// end\r\n\r\n// reset ***************\r\n// Reset our internal \"clock\"...\r\n// It doesn't change the paused state\r\nbool timeWrapperClass::reset()\r\n{\r\n\tif (!isReady()) return false;\r\n\r\n\t// reset it\r\n\tstartTime=SDL_GetTicks();\r\n\tplusTime=0;\r\n\tmultiplier=1;// normal value\r\n\r\n\treturn true;// all ok\r\n}// reset\r\n\r\n// pause ****************\r\n// Pause the clock for a while.\r\nbool timeWrapperClass::pause()\r\n{\r\n\tif (!isReady()) return false;\r\n\tif (paused) return true;// no need to pause it again\r\n\r\n\t// pause the clock...\r\n\t// It works because the way the \"play\" method is supposed to work...\r\n\tplusTime=getTime();\r\n\r\n\t// set our flag\r\n\tpaused=true;\r\n\r\n\treturn true;// all ok\r\n}// pause\r\n\r\n// play *****************\r\n// Continue after being paused...\r\nbool timeWrapperClass::play()\r\n{\r\n\tif (!isReady()) return false;\r\n\tif (!paused) return true;// no need to play it if it's not paused\r\n\r\n\t// continue from where it was paused\r\n\t// It works because the way the \"pause\" and \"getTime\" methods are\r\n\t// supposed to work...\r\n\tstartTime=SDL_GetTicks();\r\n\r\n\t// clear our flag\r\n\tpaused=false;\r\n\r\n\treturn true;// all ok\r\n}// play\r\n\r\n// setMultiplier *********\r\n// Sets a new value for the multiplier (to change the speed of time).\r\nbool timeWrapperClass::setMultiplier(double newmul){\r\n\t// Check for errors...\r\n\tif (newmul<=0) return false;\r\n\r\n\t// make the clock start from this instant (to avoid changing the\r\n\t// speed of the time which has already passed)...\r\n\t// It works because the way the \"getTime\" method is supposed\r\n\t// to work...\r\n\tplusTime=getTime();\r\n\tstartTime=SDL_GetTicks();\r\n\r\n\t// set the multiplier\r\n\tmultiplier=newmul;\r\n\r\n\treturn true;// all ok\r\n}// setMultiplier\r\n\r\n// returns the time in milliseconds\r\nDWORD timeWrapperClass::getTime(bool* errorCode)\r\n{\r\n\tDWORD tickCount;\r\n\tDWORD tempTime;\r\n\r\n\tif (!isReady()){\r\n\t\t// error!\r\n\t\tif (errorCode!=NULL) *errorCode=false;\r\n\t\treturn 0;\r\n\t}// if\r\n\r\n\t// check for the wrap around zero \"feature\" of getTickCount\r\n\ttickCount=SDL_GetTicks();\r\n\tif (tickCount<startTime){\r\n\t\t// it has wrapped around zero, avoid errors by updating the\r\n\t\t// clock rightfully\r\n\t\t// With no multiplier, it would be:\r\n\t\t// plusTime=MAX_TICKS-startTime+1;\r\n\t\tplusTime=(DWORD)((MAX_TICKS-startTime-plusTime+1)*multiplier)\r\n\t\t\t+plusTime;\r\n\t\tstartTime=0;\r\n\t}// if\r\n\r\n\tif (paused){\r\n\t\t// when the clock is paused, we return always the same time\r\n\t\ttempTime=plusTime;\r\n\t}else{\r\n\t\t// get the current time (considering the multiplier value)\r\n\t\t// That is:\r\n\t\t// (tickCount-startTime): the time since the latest multiplier\r\n\t\t// was set\r\n\t\t// (tickCount-startTime)*multiplier: the time since the latest\r\n\t\t// multiplier was set, in such time speed\r\n\t\t// +plusTime: the value for initial time we use\r\n\t\ttempTime=(DWORD)((tickCount-startTime)*multiplier)+plusTime;\r\n\t}// if\r\n\r\n\t// all ok\r\n\tif (errorCode!=NULL) *errorCode=true;\r\n\r\n\treturn tempTime;\r\n}// getTime\r\n\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"virtualwalls.h\"// for obtaining information about the virtual walls that limit units movement\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n\r\n// memory where to store the virtual walls information\r\nstatic int* virtualWallLeft;\r\nstatic int* virtualWallRight;\r\nstatic int* virtualWallGround;\r\n\r\n// height of the virtual walls\r\nstatic int lWallSize;// left wall size\r\nstatic int rWallSize;// right wall size\r\nstatic int gWallSize;// ground wall size\r\n// information for this tad\r\nstatic bool initialized=false;\r\n\r\n// initializeVirtualWalls *******\r\n// Initialize our TAD of virtual walls\r\nbool initializeVirtualWalls()\r\n{\r\n\tint i;\r\n\tlua_State* lstate;\r\n\tint value;\r\n\r\n\t// check for initialization problems\r\n\tif (initialized) return false;\r\n\tinitialized=true;\r\n\r\n\t// get the lua state object\r\n\tlstate=scriptMan.getLuaObject();\r\n\r\n\t// set wallSize's value\r\n\tlWallSize=scriptMan.getIntVariable(\"leftWallSize\");\r\n\trWallSize=scriptMan.getIntVariable(\"rightWallSize\");\r\n\tgWallSize=scriptMan.getIntVariable(\"groundWallSize\");\r\n\r\n\t// allocate memory\r\n\tvirtualWallLeft=new int[lWallSize];\r\n\tvirtualWallRight=new int[rWallSize];\r\n\tvirtualWallGround=new int[gWallSize];\r\n\r\n\t// fill left wall with the right values\r\n\tfor (i=0; i<lWallSize; i++){\r\n\t\t// get leftVirtualWal[i]\r\n\t\tlua_getglobal(lstate, \"leftVirtualWall\");\r\n\t\tlua_pushnumber(lstate, i);\r\n\t\tlua_gettable(lstate, -2);\r\n\t\tvalue=int(lua_tonumber(lstate, -1));\r\n\t\tlua_pop(lstate, 2);\r\n\r\n\t\t// save the value\r\n\t\tvirtualWallLeft[i]=value;\r\n\t}// for\r\n\r\n\t// fill right wall with the right values\r\n\tfor (i=0; i<rWallSize; i++){\r\n\t\t// get rightVirtualWal[i]\r\n\t\tlua_getglobal(lstate, \"rightVirtualWall\");\r\n\t\tlua_pushnumber(lstate, i);\r\n\t\tlua_gettable(lstate, -2);\r\n\t\tvalue=int(lua_tonumber(lstate, -1));\r\n\t\tlua_pop(lstate, 2);\r\n\r\n\t\t// save the value\r\n\t\tvirtualWallRight[i]=value;\r\n\t}// for\r\n\r\n\t// fill ground wall with the right values\r\n\tfor (i=0; i<gWallSize; i++){\r\n\t\t// get groundVirtualWal[i]\r\n\t\tlua_getglobal(lstate, \"groundVirtualWall\");\r\n\t\tlua_pushnumber(lstate, i);\r\n\t\tlua_gettable(lstate, -2);\r\n\t\tvalue=int(lua_tonumber(lstate, -1));\r\n\t\tlua_pop(lstate, 2);\r\n\r\n\t\t// save the value\r\n\t\tvirtualWallGround[i]=value;\r\n\t}// for\r\n\r\n\treturn true;// all ok\r\n}// initializeVirtualWalls\r\n\r\n// deinitializeVirtualWalls *******\r\n// Deinitialize our Tad of virtual walls.\r\nbool deinitializeVirtualWalls()\r\n{\r\n\t// check for initialization problems\r\n\tif (!initialized) return false;\r\n\tinitialized=false;\r\n\r\n\tdelete[] virtualWallLeft;\r\n\tdelete[] virtualWallRight;\r\n\tdelete[] virtualWallGround;\r\n\r\n\treturn true;// all ok\r\n}// deinitializeVirtualWalls\r\n\r\n// getLeftWall *********************\r\n// Gets the x position of the wall at a given y value, for the left\r\n// wall\r\nint getLeftWall(int y)\r\n{\r\n\t// check for initialization problems\r\n\tif (!initialized) return -1;\r\n\r\n\t// check if we aren't outside the defined wall\r\n\tif (y<0 || y>=lWallSize) return virtualWallLeft[0];\r\n\r\n\treturn virtualWallLeft[y];\r\n}// getLeftWall\r\n\r\n// getRightWall *********************\r\n// Gets the x position of the wall at a given y value, for the right\r\n// wall\r\nint getRightWall(int y)\r\n{\r\n\t// check for initialization problems\r\n\tif (!initialized) return -1;\r\n\r\n\t// check if we aren't outside the defined wall\r\n\tif (y<0 || y>=rWallSize) return virtualWallRight[0];\r\n\r\n\treturn virtualWallRight[y];\r\n}// getRightWall\r\n\r\n// getGroundWall *********************\r\n// Gets the x position of the wall at a given y value, for the ground\r\n// wall (ground heights)\r\nint getGroundWall(int x)\r\n{\r\n\t// check for initialization problems\r\n\tif (!initialized) return -1;\r\n\r\n\t// check if we aren't outside the defined wall\r\n\tif (x<0 || x>=gWallSize) return virtualWallGround[0];\r\n\r\n\treturn virtualWallGround[x];\r\n}// getGroundWall\r\n","/*\r\n\r\nCopyright (c) 2007 Horacio Hernan Moraldo\r\n\r\nThis software is provided 'as-is', without any express or\r\nimplied warranty. In no event will the authors be held liable\r\nfor any damages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you\r\nmust not claim that you wrote the original software. If you use\r\nthis software in a product, an acknowledgment in the product\r\ndocumentation would be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"wavegens.h\"// for managing the wave generators\r\n#include \"globals.h\"// for using the program objects\r\n#include \"gameglobals.h\"// for using the game objects\r\n#include \"gamedata.h\"// data types of this game\r\n#include \"generalmaths.h\"// for mathematical functions\r\n#include \"genericunits.h\"// for managing the generic units...\r\n#include \"enemyai.h\"// for managing the enemy AI...\r\n/*#include \"gamesound.h\"// for accessing the functions that convert game events to sound executions*/\r\n#include \"scriptman.h\"// used for accessing to the script manager object\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n// Functions to be called before and after executing the game\r\n\r\n// This function sets all the wave generators up, in their\r\n// original positions.\r\n// Everything related to wave gens initialization is here.\r\nbool createWaveGenObjects()\r\n{\r\n\twaveGenUnitStruct waveGenData;\r\n\r\n\t// Add our wave generators to the list\r\n\t// The distance between waves is set in the Staging Manager\r\n\r\n\t// Drop the existent wave gens from the list\r\n\twaveGenList.resetList();\r\n\r\n\t// WaveGen that creates white sheep carriers:\r\n\t// Basic info\r\n\tsetupWaveGenUnit(waveGenData, FILE_GAMEDATA_WAVEGEN_WHITESHEEPS);\r\n\t// Generation data\r\n\twaveGenData.generatingNow=true;\r\n\t// Set the relative position stuff (relative to camera)\r\n\twaveGenData.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\twaveGenData.xFromCamera=\r\n\t\tscriptMan.getIntVariable(\"wSheepGenX\");\r\n\twaveGenData.yFromCamera=\r\n\t\t\t\tscriptMan.getIntVariable(\"wSheepGenY\");\r\n\t// Coordinates\r\n\twaveGenData.x=waveGenData.xFromCamera;\r\n\twaveGenData.y=waveGenData.yFromCamera;\r\n\t// Add this node\r\n\tif (!waveGenList.isValidIndex(waveGenList.addNode(waveGenData))){\r\n\t\tlogger.logLine(\"Failed adding node to waveGenList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// WaveGen that creates black sheep carriers:\r\n\t// Basic info\r\n\tsetupWaveGenUnit(waveGenData, FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS);\r\n\t// Generation data\r\n\twaveGenData.generatingNow=true;\r\n\t// Set the relative position stuff (relative to camera)\r\n\twaveGenData.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\twaveGenData.xFromCamera=\r\n\t\tscriptMan.getIntVariable(\"bSheepGenX\");\r\n\twaveGenData.yFromCamera=\r\n\t\tscriptMan.getIntVariable(\"bSheepGenY\");\r\n\t// Coordinates\r\n\twaveGenData.x=waveGenData.xFromCamera;\r\n\twaveGenData.y=waveGenData.yFromCamera;\r\n\t// Add this node\r\n\tif (!waveGenList.isValidIndex(waveGenList.addNode(waveGenData))){\r\n\t\tlogger.logLine(\"Failed adding node to waveGenList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// WaveGen that creates human head carriers:\r\n\t// Basic info\r\n\tsetupWaveGenUnit(waveGenData, FILE_GAMEDATA_WAVEGEN_HUMANHEADS);\r\n\t// Generation data\r\n\twaveGenData.generatingNow=true;\r\n\t// Set the relative position stuff (relative to camera)\r\n\twaveGenData.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\twaveGenData.xFromCamera=\r\n\t\tscriptMan.getIntVariable(\"headGenX\");\r\n\twaveGenData.yFromCamera=\r\n\t\tscriptMan.getIntVariable(\"headGenY\");\r\n\t// Coordinates\r\n\twaveGenData.x=waveGenData.xFromCamera;\r\n\twaveGenData.y=waveGenData.yFromCamera;\r\n\t// Add this node\r\n\tif (!waveGenList.isValidIndex(waveGenList.addNode(waveGenData))){\r\n\t\tlogger.logLine(\"Failed adding node to waveGenList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\t// WaveGen for sheeps to escape by:\r\n\t// Basic info\r\n\tsetupWaveGenUnit(waveGenData, FILE_GAMEDATA_WAVEGEN_SHEEPSOUT);\r\n\t// Generation data\r\n\twaveGenData.generatingNow=false;\r\n\t// Set the relative position stuff (relative to camera)\r\n\twaveGenData.isPosRelative=true;// are xFromCamera and yFromCamera used for relative position?\r\n\twaveGenData.xFromCamera=\r\n\t\tscriptMan.getIntVariable(\"sheepsOutGenX\");\r\n\twaveGenData.yFromCamera=\r\n\t\tscriptMan.getIntVariable(\"sheepsOutGenY\");\r\n\t// Coordinates\r\n\twaveGenData.x=waveGenData.xFromCamera;\r\n\twaveGenData.y=waveGenData.yFromCamera;\r\n\t// Add this node\r\n\tif (!waveGenList.isValidIndex(waveGenList.addNode(waveGenData))){\r\n\t\tlogger.logLine(\"Failed adding node to waveGenList\");\r\n\t\treturn false;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// createWaveGenObjects\r\n\r\n// This functions destroys all what's been created in\r\n// createWaveGenObjects.\r\nbool destroyWaveGenObjects()\r\n{\r\n\t// nothing to do yet...\r\n\r\n\treturn true;// all ok\r\n}// destroyWaveGenObjects\r\n\r\n// addEnemiesWaveGen ******\r\n// This method makes a given wave generator add units to the game world\r\nbool addEnemiesWaveGen(\r\n\tDWORD frameNumber,// current frame\r\n\tvectorListNodeStruct<waveGenUnitStruct>& unit)// wavegen unit to move\r\n{\r\n\tint i;\r\n\tframeDataStruct* enemyFrame;\r\n\tframeDataStruct* wgFrame;\r\n\tframeDataStruct combinedFrame;\r\n\r\n\t// value to multiply the speed of units (for progressive difficulty)\r\n\tdouble speedMultiplier;\r\n\r\n\t// add an enemy wave\r\n\tenemyUnitStruct enemyData;\r\n\tenemyUnitStruct carriedUnit;\r\n\r\n\t// pointer to the unit once it's been created\r\n\tgenericUnitStruct* eUnitPtr;\r\n\r\n\t// tells whether carriedUnit should be added to the enemy list as\r\n\t// well, and set as the slave unit of enemyData\r\n\tbool shouldISlavize;\r\n\r\n\t// tells how many units to generate...\r\n\tint unitsToGenerate;\r\n\r\n\t// node index numbers\r\n\tDWORD enemyIdx, carriedIdx;\r\n\r\n\t// get the current frame\r\n\twgFrame=\r\n\t\t&(waveGenType[unit.data.unitType].frames\r\n\t\t[unit.data.currentFrame]);\r\n\r\n\t// calculate speed to multiply now\r\n\tspeedMultiplier=1+(gameWorld.currentLevel-1)*0.20;\r\n\r\n\t// calculate unitsToGenerate first\r\n\tswitch (unit.data.unitType){\r\n\tcase FILE_GAMEDATA_WAVEGEN_WHITESHEEPS:\r\n\t\tunitsToGenerate=1;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS:\r\n\t\tunitsToGenerate=1;\r\n\t\tbreak;\r\n\tcase FILE_GAMEDATA_WAVEGEN_HUMANHEADS:\r\n\t\tunitsToGenerate=rand()%4+1;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// never mind...\r\n\t\tunitsToGenerate=0;\r\n\t\tbreak;\r\n\t}// switch\r\n\r\n/*\t// execute a sound if some unit will be generated\r\n\tif (unitsToGenerate>0){\r\n\t\tmakeSoundGeneratedUnit();\r\n\t}// if\r\n*/\r\n\t// execute the addition of units now\r\n\tfor (i=0; i<unitsToGenerate; i++){\r\n\t\t// initialize shouldISlavize to false, most of the units\r\n\t\t// won't have any slaves...\r\n\t\tshouldISlavize=false;\r\n\r\n\t\t// calculate the creation of units, for every wave generator\r\n\t\t// UNITS CREATION, FIRST PART BEGIN\r\n\t\t// The following code is devoted to the creation of units, and\r\n\t\t// their respective slaves. Coordinates of the spawned units\r\n\t\t// aren't still known.\r\n\t\tswitch (unit.data.unitType){\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_WHITESHEEPS:\r\n\t\t\t// create the units...\r\n\t\t\t// random says: create a sheep carrier for white sheeps\r\n\t\t\tsetupEnemyUnit(enemyData,\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_SHEEPCARRIER);\r\n\r\n\t\t\t// set this unit as just going out, so untouchable\r\n\t\t\t// until the next ai execution time\r\n\t\t\t// (that is, we don't want this unit to collide with\r\n\t\t\t// anything until it's somewhat away from the wave\r\n\t\t\t// generator)\r\n\t\t\tenemyData.justGoingOut=true;\r\n\t\t\tenemyData.canBeHitByBullets=false;\r\n\t\t\tenemyData.canBeHitByPlayers=false;\r\n\r\n\t\t\t// set some other things\r\n\t\t\tif (rand()%4<=2){// probabilities: 3 vs 1\r\n\t\t\t\t// the unit will have a slave\r\n\t\t\t\t// set the current frame to be the one of carrying\r\n\t\t\t\tenemyData.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\"sheepCarrierCarryingSheep\");\r\n\r\n\t\t\t\t// set it to be carrying a sheep\r\n\t\t\t\tsetupEnemyUnit(carriedUnit,\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP);\r\n\t\t\t\tshouldISlavize=true;// we'll need a slave unit\r\n\t\t\t\t// typical speed for sheeps\r\n\t\t\t\tcarriedUnit.linearSpeed=\r\n\t\t\t\t\t66/double(desiredFramesPerSecond);\r\n\t\t\t\t// typical speed for falling in sheeps\r\n\t\t\t\tcarriedUnit.aiSpecific.sheepData.sheepSpeedWhenFalling=\r\n\t\t\t\t\tcarriedUnit.linearSpeed*2;\r\n\t\t\t\t// set the being carried frame for this sheep\r\n\t\t\t\tcarriedUnit.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByNameInSheeps(\r\n\t\t\t\t\t\tunit.data.unitType==\r\n\t\t\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP,\r\n\t\t\t\t\t\t\"SheepCarried\");\r\n\t\t\t}else{\r\n\t\t\t\t// the unit won't have slaves\r\n\t\t\t\t// let the current frame to be the initial one (when\r\n\t\t\t\t// it isn't carrying anything)\r\n\t\t\t}// if\r\n\r\n\t\t\t// get the current frame\r\n\t\t\tenemyFrame=\r\n\t\t\t\t&(enemyType[enemyData.unitType].frames\r\n\t\t\t\t[enemyData.currentFrame]);\r\n\r\n\t\t\t// typical speed\r\n\t\t\tenemyData.linearSpeed=120/double(desiredFramesPerSecond);\r\n\t\t\t// set it according to the current level difficulty\r\n\t\t\tenemyData.linearSpeed*=speedMultiplier;\r\n\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS:\r\n\t\t\t// random says: create a sheep carrier for black sheeps\r\n\t\t\tsetupEnemyUnit(enemyData,\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_SHEEPCARRIER);\r\n\r\n\t\t\t// set this unit as just going out, so untouchable\r\n\t\t\t// until the next ai execution time\r\n\t\t\t// (that is, we don't want this unit to collide with\r\n\t\t\t// anything until it's somewhat away from the wave\r\n\t\t\t// generator)\r\n\t\t\tenemyData.justGoingOut=true;\r\n\t\t\tenemyData.canBeHitByBullets=false;\r\n\t\t\tenemyData.canBeHitByPlayers=false;\r\n\r\n\t\t\t// set some other things\r\n\t\t\tif (rand()%4<=2){// probabilities: 3 vs 1\r\n\t\t\t\t// the unit will have a slave\r\n\t\t\t\t// set the current frame to be the one of carrying\r\n\t\t\t\tenemyData.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\r\n\t\t\t\t\t\"sheepCarrierCarryingBody\");\r\n\r\n\t\t\t\t// set it to be carrying a sheep\r\n\t\t\t\tsetupEnemyUnit(carriedUnit,\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_BLACKSHEEP);\r\n\t\t\t\tshouldISlavize=true;// we'll need a slave unit\r\n\t\t\t\t// typical speed for sheeps\r\n\t\t\t\tcarriedUnit.linearSpeed=\r\n\t\t\t\t\t66/double(desiredFramesPerSecond);\r\n\t\t\t\t// typical speed for falling in sheeps\r\n\t\t\t\tcarriedUnit.aiSpecific.sheepData.sheepSpeedWhenFalling=\r\n\t\t\t\t\tcarriedUnit.linearSpeed*2;\r\n\t\t\t\t// set the being carried frame for this sheep\r\n\t\t\t\tcarriedUnit.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByNameInSheeps(\r\n\t\t\t\t\t\tunit.data.unitType==\r\n\t\t\t\t\t\t\tFILE_GAMEDATA_ENEMY_WHITESHEEP,\r\n\t\t\t\t\t\t\"SheepCarried\");\r\n\t\t\t}else{\r\n\t\t\t\t// the unit won't have slaves\r\n\t\t\t\t// let the current frame to be the initial one (when\r\n\t\t\t\t// it isn't carrying anything)\r\n\t\t\t}// if\r\n\r\n\t\t\t// get the current frame\r\n\t\t\tenemyFrame=\r\n\t\t\t\t&(enemyType[enemyData.unitType].frames\r\n\t\t\t\t[enemyData.currentFrame]);\r\n\r\n\t\t\t// typical speed\r\n\t\t\tenemyData.linearSpeed=120/double(desiredFramesPerSecond);\r\n\t\t\t// set it according to the current level difficulty\r\n\t\t\tenemyData.linearSpeed*=speedMultiplier;\r\n\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_HUMANHEADS:\r\n\t\t\t// create the units...\r\n\t\t\t// random says: create a head carrier\r\n\t\t\tsetupEnemyUnit(enemyData,\r\n\t\t\t\tFILE_GAMEDATA_ENEMY_HEADCARRIER);\r\n\r\n\t\t\t// set this unit as just going out, so untouchable\r\n\t\t\t// until the next ai execution time\r\n\t\t\t// (that is, we don't want this unit to collide with\r\n\t\t\t// anything until it's somewhat away from the wave\r\n\t\t\t// generator)\r\n\t\t\tenemyData.justGoingOut=true;\r\n\t\t\tenemyData.canBeHitByBullets=false;\r\n\t\t\tenemyData.canBeHitByPlayers=false;\r\n\r\n\t\t\t// set some other things\r\n\t\t\tif (rand()%4<=2){// probabilities: 3 vs 1\r\n\t\t\t\t// the unit will have a slave\r\n\t\t\t\t// set the current frame to be the one of carrying\r\n\t\t\t\tenemyData.currentFrame=\r\n\t\t\t\t\tgetFrameIndexAndListByName(\"headCarrierCarrying\");\r\n\r\n\t\t\t\t// set it to be carrying a sheep\r\n\t\t\t\tsetupEnemyUnit(carriedUnit,\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HUMANHEAD);\r\n\t\t\t\tshouldISlavize=true;// we'll need a slave unit\r\n\t\t\t\t// typical speed for heads\r\n\t\t\t\tcarriedUnit.linearSpeed=\r\n\t\t\t\t\t100/double(desiredFramesPerSecond);\r\n\t\t\t\t// typical speed for falling in heads\r\n\t\t\t\tcarriedUnit.aiSpecific.headData.headSpeedWhenFalling=\r\n\t\t\t\t\tcarriedUnit.linearSpeed*2;\r\n\t\t\t}else{\r\n\t\t\t\t// the unit won't have slaves\r\n\t\t\t\t// let the current frame to be the initial one (when\r\n\t\t\t\t// it isn't carrying anything)\r\n\t\t\t}// if\r\n\r\n\t\t\t// get the current frame\r\n\t\t\tenemyFrame=\r\n\t\t\t\t&(enemyType[enemyData.unitType].frames\r\n\t\t\t\t[enemyData.currentFrame]);\r\n\r\n\t\t\t// typical speed\r\n\t\t\tenemyData.linearSpeed=120/double(desiredFramesPerSecond);\r\n\t\t\t// set it according to the current level difficulty\r\n\t\t\tenemyData.linearSpeed*=speedMultiplier;\r\n\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_SHEEPSOUT:\r\n\t\t\t// sheeps don't generate, this should not be executed\r\n\t\t\treturn false;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn false;// that type of wave gen isn't known to us\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t\t// UNITS CREATION, FIRST PART END\r\n\r\n\t\t// GENERAL GENERATION CODE FIRST PART BEGIN\r\n\t\t// The following code adds the created units to their respective\r\n\t\t// lists, and calculates the real coordinates of those.\r\n\t\t// shouldISlavize 1 of 2\r\n\t\tif (shouldISlavize){\r\n\t\t\t// slaver\r\n\t\t\tenemyData.slaveUnit.id=carriedUnit.id;\r\n\t\t\tenemyData.slaveUnit.objectType=carriedUnit.objectType;\r\n\t\t\t// slave\r\n\t\t\tcarriedUnit.slaveOf.id=enemyData.id;\r\n\t\t\tcarriedUnit.slaveOf.objectType=enemyData.objectType;\r\n\t\t\tcarriedUnit.nowDrawable=false;// to be drawn only together to its owner\r\n\t\t\t// set carriedUnit as the slave unit of enemyData\r\n\t\t\t// (everything, but list indexes)\r\n\t\t\tcarriedIdx=enemyList.addNode(carriedUnit);\r\n\t\t\tif (!enemyList.isValidIndex(carriedIdx)){\r\n\t\t\t\tlogger.logLine(\"Failed adding node to enemyList\");\r\n\t\t\t\treturn false;\r\n\t\t\t}// if\r\n\t\t}// if\r\n\r\n\t\tenemyIdx=enemyList.addNode(enemyData);\r\n\t\tif (!enemyList.isValidIndex(enemyIdx)){\r\n\t\t\tlogger.logLine(\"Failed adding node to enemyList\");\r\n\t\t\treturn false;\r\n\t\t}// if\r\n\r\n\t\t// obtain a pointer to the added unit\r\n\t\teUnitPtr=&(enemyList.getNode(enemyIdx)->data);\r\n\r\n\t\t// shouldISlavize 2 of 2\r\n\t\tif (shouldISlavize){\r\n\t\t\t// (only list indexes now)\r\n\t\t\teUnitPtr->slaveUnit.listIndex=\r\n\t\t\t\tcarriedIdx;\r\n\t\t\t// slave...\r\n\t\t\tenemyList.getNode(carriedIdx)->data.slaveOf.listIndex=\r\n\t\t\t\tenemyIdx;\r\n\t\t}// if\r\n\r\n\t\t// create a frame information with the information of the unit\r\n\t\t// together with its slaves (if any)\r\n\t\t//if (!constructSlaverFullFrame(eUnitPtr, &combinedFrame))\r\n\t\t//\treturn false;\r\n\t\t// that's history: now we do it directly with the current\r\n\t\t// frame of that unit, usually the first one in the sequence,\r\n\t\t// a special marker of size\r\n\t\tcombinedFrame=*(getUnitFrame(eUnitPtr));\r\n\r\n\t\t// Set coordinates\r\n\t\t// X: just at the first pixel of the spawning rectangle\r\n\t\t// wgFrame->cX: the spawning rectangle x\r\n\t\t// +unit.data.x-(wgFrame->handlerX): plus the direction of\r\n\t\t// the first pixel of the wave generator\r\n\t\t// +enemyFrame->handlerX: plus the enemy frame handler x\r\n\t\teUnitPtr->x=\r\n\t\t\twgFrame->cX+unit.data.x-(wgFrame->handlerX)\r\n\t\t\t+combinedFrame.handlerX;\r\n\t\t// Y: just at the first pixel of the spawning rectangle\r\n\t\t// wgFrame->cY: the spawning rectangle y\r\n\t\t// +unit.data.y-(wgFrame->handlerY): plus the direction of\r\n\t\t// the first pixel of the wave generator\r\n\t\t// +enemyFrame->handlerY: plus the enemy frame handler y\r\n\t\t// +(rand()%(wgFrame->cW-enemyFrame->cW))\r\n\t\t//  : the random y position\r\n\t\teUnitPtr->y=\r\n\t\t\twgFrame->cY+unit.data.y-(wgFrame->handlerY)\r\n\t\t\t+combinedFrame.handlerY+\r\n\t\t\t// now we have a division by zero check here too\r\n\t\t\t((wgFrame->cH-combinedFrame.h)==0?0:(rand()%(wgFrame->cH-combinedFrame.h)));\r\n\t\t// GENERAL GENERATION CODE FIRST PART END\r\n\r\n\t\t// FOLLOWERS_TEST_BEGIN\r\n\t\t// no followers for now for a while...\r\n\t\tif (false &&\r\n\t\t\t(eUnitPtr->unitType==FILE_GAMEDATA_ENEMY_HEADCARRIER ||\r\n\t\t\teUnitPtr->unitType==FILE_GAMEDATA_ENEMY_SHEEPCARRIER)\r\n\t\t\t&& rand()%1==0){\r\n\t\t\tvectorListNodeStruct<enemyUnitStruct> *unit;\r\n\t\t\tenemyUnitStruct *eUnit=(enemyUnitStruct*)eUnitPtr;\r\n\t\t\tint someNum;\r\n\t\t\tint i, j;\r\n\t\t\tint distance;\r\n\r\n\t\t\t// look for the unit that is in that position of the list\r\n\t\t\tunit=enemyList.getFirstNode();\r\n\t\t\tif (unit!=NULL && unit->data.nowActive){\r\n\t\t\t\tunit=NULL;// this way the first unit isn't ignored in the first pass\r\n\r\n\t\t\t\tdistance=500;\r\n\t\t\t\tfor (j=0;\r\n\t\t\t\tj<30 && (unit==NULL ||\r\n\t\t\t\t((unit->data.unitType!=FILE_GAMEDATA_ENEMY_HEADCARRIER\r\n\t\t\t\t&& unit->data.unitType!=FILE_GAMEDATA_ENEMY_SHEEPCARRIER) ||\r\n\t\t\t\tdistance>=200));\r\n\t\t\t\tj++){\r\n\t\t\t\t\tsomeNum=1+(rand()%100);\r\n\r\n\t\t\t\t\tfor (i=0; i<someNum; i++){\r\n\t\t\t\t\t\tif (unit!=NULL)\r\n\t\t\t\t\t\t\tunit=enemyList.getNextNode(unit);\r\n\r\n\t\t\t\t\t\tif (unit==NULL)\r\n\t\t\t\t\t\t\tunit=enemyList.getFirstNode();\r\n\t\t\t\t\t}// for\r\n\r\n\t\t\t\t\tdistance=(int)\r\n\t\t\t\t\t\t(sqrt(SQUARE(unit->data.x-eUnit->x)+\r\n\t\t\t\t\t\tSQUARE(unit->data.y-eUnit->y)));\r\n\t\t\t\t}// for\r\n\r\n\t\t\t\tif (distance<200 &&\r\n\t\t\t\t\t(unit->data.unitType==\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_HEADCARRIER ||\r\n\t\t\t\t\tunit->data.unitType==\r\n\t\t\t\t\tFILE_GAMEDATA_ENEMY_SHEEPCARRIER)){\r\n\r\n\t\t\t\t\t// assign that one\r\n\t\t\t\t\teUnit->aiSpecific.flockerData.unitToFollow.objectType=\r\n\t\t\t\t\t\tunit->data.objectType;\r\n\t\t\t\t\teUnit->aiSpecific.flockerData.unitToFollow.id=\r\n\t\t\t\t\t\tunit->data.id;\r\n\t\t\t\t\teUnit->aiSpecific.flockerData.unitToFollow.listIndex=\r\n\t\t\t\t\t\tenemyList.getIndex(unit);\r\n\t\t\t\t}// if\r\n\t\t\t}// if\r\n\t\t}// if\r\n\t\t// FOLLOWERS_TEST_END\r\n\r\n\t\t// UNITS CREATION, SECOND PART BEGIN\r\n\t\t// The following code is to allow the setting of properties\r\n\t\t// in the units, once these have been created, and once the\r\n\t\t// real position (coordinates) of these is known.\r\n\t\tswitch (unit.data.unitType){\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_WHITESHEEPS:\r\n\t\t\t// set the going to fields\r\n\t\t\teUnitPtr->goingToPoint=true;\r\n\t\t\teUnitPtr->goingToPointX=eUnitPtr->x-100;\r\n\t\t\teUnitPtr->goingToPointY=eUnitPtr->y;\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_BLACKSHEEPS:\r\n\t\t\t// set the going to fields\r\n\t\t\teUnitPtr->goingToPoint=true;\r\n\t\t\teUnitPtr->goingToPointX=eUnitPtr->x-100;\r\n\t\t\teUnitPtr->goingToPointY=eUnitPtr->y;//+(rand()%60)-30;\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_HUMANHEADS:\r\n\t\t\t// set the going to fields\r\n\t\t\teUnitPtr->goingToPoint=true;\r\n\t\t\teUnitPtr->goingToPointX=eUnitPtr->x-100;\r\n\t\t\teUnitPtr->goingToPointY=eUnitPtr->y;//+(rand()%60)-30;\r\n\t\t\tbreak;\r\n\t\tcase FILE_GAMEDATA_WAVEGEN_SHEEPSOUT:\r\n\t\t\t// sheeps don't generate, this should not be executed\r\n\t\t\treturn false;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn false;// that type of wave gen isn't known to us\r\n\t\t\tbreak;\r\n\t\t}// switch\r\n\t\t// UNITS CREATION, SECOND PART END\r\n\r\n\t\t// GENERAL GENERATION CODE SECOND PART BEGIN\r\n\t\t// The following generic code finishes the creation of the units\r\n\t\t// the code below worked with, by setting the latest data of\r\n\t\t// these.\r\n\t\tif (eUnitPtr->isPosRelative){\r\n\t\t\t// correct the coordinates to be relative\r\n\t\t\teUnitPtr->goingToPointX-=gameWorld.xCamera;\r\n\t\t\teUnitPtr->goingToPointY-=gameWorld.yCamera;\r\n\t\t}// if\r\n\r\n\t\t// now do whatever is needed after having calculated\r\n\t\t// the initial coordinates\r\n\t\tif (eUnitPtr->goingToPoint){\r\n\r\n\t\t\t// set the speed for going to such point\r\n\t\t\tsetSpeedForLinealMove(eUnitPtr,\r\n\t\t\t\teUnitPtr->goingToPointX, eUnitPtr->goingToPointY,\r\n\t\t\t\teUnitPtr->linearSpeed);\r\n\t\t}// if\r\n\t\t// GENERAL GENERATION CODE SECOND PART END\r\n\t}// for\r\n\r\n\treturn true;// all ok\r\n}// addEnemiesWaveGen\r\n\r\n// executeWaveGenAI ******\r\n// This method executes the individual AI of a wave generator unit.\r\nbool executeWaveGenAI(\r\n\tDWORD frameNumber,// current frame\r\n\tvectorListNodeStruct<waveGenUnitStruct>& unit)// wavegen unit to move\r\n{\r\n\tif (!unit.data.generatingNow) return true;// nothing to do now...\r\n\r\n\t// This function works by putting a virtual wave at some distance\r\n\t// from the last enemy wave added, and then moving it as if it were\r\n\t// an object. When the virtual enemy wave object is detected to be\r\n\t// just inside the screen, a bunch of enemies is added and a new\r\n\t// virtual wave object is put.\r\n\r\n\t// Start moving the virtual wave object\r\n\tunit.data.nextEnemyWaveX-=unit.data.virtualEnemyWavesSpeedX;\r\n\r\n\t// see if it's time for adding an enemy wave\r\n\tif (unit.data.nextEnemyWaveX<=gameWorld.xCamera+gameWorld.wCamera){\r\n\t\t// Add the wave\r\n\t\tif (!addEnemiesWaveGen(frameNumber, unit)) return false;\r\n\r\n\t\t// Setup next virtual wave\r\n\t\tunit.data.nextEnemyWaveX=gameWorld.xCamera+gameWorld.wCamera+\r\n\t\t\tunit.data.distanceBetweenWaves;\r\n\t}// if\r\n\r\n\treturn true;// all ok\r\n}// executeUnitAI\r\n\r\n// A function to execute all the enemy waves (or rather those that are\r\n// active)\r\nbool executeEnemyWaves(DWORD frameNumber)\r\n{\r\n\tvectorListNodeStruct<waveGenUnitStruct> *unit;\r\n\r\n\t// Manage the AI of all the wave generators on screen...\r\n\tfor (unit=waveGenList.getFirstNode(); unit!=NULL; unit=waveGenList.getNextNode(unit)){\r\n\t\t// don't move this unit if it's not active now\r\n\t\tif (!unit->data.nowActive) continue;\r\n\r\n\t\t// execute the ai of this unit\r\n\t\tif (!executeWaveGenAI(frameNumber, *unit)) return false;\r\n\t}// for unit\r\n\r\n\treturn true;// all ok\r\n}// executeEnemyWaves\r\n","/*\n** $Id: lapi.c,v 2.171.1.1 2013/04/12 18:48:47 roberto Exp $\n** Lua API\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stdarg.h>\n#include <string.h>\n\n#define lapi_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n/* value at a non-valid index */\n#define NONVALIDVALUE\t\tcast(TValue *, luaO_nilobject)\n\n/* corresponding test */\n#define isvalid(o)\t((o) != luaO_nilobject)\n\n/* test for pseudo index */\n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n/* test for valid but not pseudo index */\n#define isstackindex(i, o)\t(isvalid(o) && !ispseudo(i))\n\n#define api_checkvalidindex(L, o)  api_check(L, isvalid(o), \"invalid index\")\n\n#define api_checkstackindex(L, i, o)  \\\n\tapi_check(L, isstackindex(i, o), \"index not in the stack\")\n\n\nstatic TValue *index2addr (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    TValue *o = ci->func + idx;\n    api_check(L, idx <= ci->top - (ci->func + 1), \"unacceptable index\");\n    if (o >= L->top) return NONVALIDVALUE;\n    else return o;\n  }\n  else if (!ispseudo(idx)) {  /* negative index */\n    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), \"invalid index\");\n    return L->top + idx;\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {  /* upvalues */\n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttislcf(ci->func))  /* light C function? */\n      return NONVALIDVALUE;  /* it has no upvalues */\n    else {\n      CClosure *func = clCvalue(ci->func);\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;\n    }\n  }\n}\n\n\n/*\n** to be called by 'lua_checkstack' in protected mode, to grow stack\n** capturing memory errors\n*/\nstatic void growstack (lua_State *L, void *ud) {\n  int size = *(int *)ud;\n  luaD_growstack(L, size);\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int size) {\n  int res;\n  CallInfo *ci = L->ci;\n  lua_lock(L);\n  if (L->stack_last - L->top > size)  /* stack large enough? */\n    res = 1;  /* yes; check is OK */\n  else {  /* no; need to grow stack */\n    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;\n    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */\n      res = 0;  /* no */\n    else  /* try to grow stack */\n      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);\n  }\n  if (res && ci->top < L->top + size)\n    ci->top = L->top + size;  /* adjust frame top */\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checknelems(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top - to->top >= n, \"not enough elements to move\");\n  from->top -= n;\n  for (i = 0; i < n; i++) {\n    setobj2s(to, to->top++, from->top + i);\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API const lua_Number *lua_version (lua_State *L) {\n  static const lua_Number version = LUA_VERSION_NUM;\n  if (L == NULL) return &version;\n  else return G(L)->version;\n}\n\n\n\n/*\n** basic stack manipulation\n*/\n\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top - L->ci->func + idx);\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top - (L->ci->func + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  StkId func = L->ci->func;\n  lua_lock(L);\n  if (idx >= 0) {\n    api_check(L, idx <= L->stack_last - (func + 1), \"new top too large\");\n    while (L->top < (func + 1) + idx)\n      setnilvalue(L->top++);\n    L->top = (func + 1) + idx;\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top - (func + 1)), \"invalid new top\");\n    L->top += idx+1;  /* `subtract' index (index is negative) */\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_remove (lua_State *L, int idx) {\n  StkId p;\n  lua_lock(L);\n  p = index2addr(L, idx);\n  api_checkstackindex(L, idx, p);\n  while (++p < L->top) setobjs2s(L, p-1, p);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_insert (lua_State *L, int idx) {\n  StkId p;\n  StkId q;\n  lua_lock(L);\n  p = index2addr(L, idx);\n  api_checkstackindex(L, idx, p);\n  for (q = L->top; q > p; q--)  /* use L->top as a temporary */\n    setobjs2s(L, q, q - 1);\n  setobjs2s(L, p, L->top);\n  lua_unlock(L);\n}\n\n\nstatic void moveto (lua_State *L, TValue *fr, int idx) {\n  TValue *to = index2addr(L, idx);\n  api_checkvalidindex(L, to);\n  setobj(L, to, fr);\n  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */\n    luaC_barrier(L, clCvalue(L->ci->func), fr);\n  /* LUA_REGISTRYINDEX does not need gc barrier\n     (collector revisits it before finishing collection) */\n}\n\n\nLUA_API void lua_replace (lua_State *L, int idx) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  moveto(L, L->top - 1, idx);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr;\n  lua_lock(L);\n  fr = index2addr(L, fromidx);\n  moveto(L, fr, toidx);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top, index2addr(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n/*\n** access functions (stack -> C)\n*/\n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  int t = lua_type(L, idx);\n  return (t == LUA_TSTRING || t == LUA_TNUMBER);\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisuserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  StkId o1 = index2addr(L, index1);\n  StkId o2 = index2addr(L, index2);\n  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  StkId o1;  /* 1st operand */\n  StkId o2;  /* 2nd operand */\n  lua_lock(L);\n  if (op != LUA_OPUNM) /* all other operations expect two operands */\n    api_checknelems(L, 2);\n  else {  /* for unary minus, add fake 2nd operand */\n    api_checknelems(L, 1);\n    setobjs2s(L, L->top, L->top - 1);\n    L->top++;\n  }\n  o1 = L->top - 2;\n  o2 = L->top - 1;\n  if (ttisnumber(o1) && ttisnumber(o2)) {\n    setnvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));\n  }\n  else\n    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  StkId o1, o2;\n  int i = 0;\n  lua_lock(L);  /* may call tag method */\n  o1 = index2addr(L, index1);\n  o2 = index2addr(L, index2);\n  if (isvalid(o1) && isvalid(o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    if (isnum) *isnum = 1;\n    return nvalue(o);\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    lua_Integer res;\n    lua_Number num = nvalue(o);\n    lua_number2integer(res, num);\n    if (isnum) *isnum = 1;\n    return res;\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    lua_Unsigned res;\n    lua_Number num = nvalue(o);\n    lua_number2unsigned(res, num);\n    if (isnum) *isnum = 1;\n    return res;\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  StkId o = index2addr(L, idx);\n  if (!ttisstring(o)) {\n    lua_lock(L);  /* `luaV_tostring' may create a new string */\n    if (!luaV_tostring(L, o)) {  /* conversion failed? */\n      if (len != NULL) *len = 0;\n      lua_unlock(L);\n      return NULL;\n    }\n    luaC_checkGC(L);\n    o = index2addr(L, idx);  /* previous call may reallocate the stack */\n    lua_unlock(L);\n  }\n  if (len != NULL) *len = tsvalue(o)->len;\n  return svalue(o);\n}\n\n\nLUA_API size_t lua_rawlen (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttypenv(o)) {\n    case LUA_TSTRING: return tsvalue(o)->len;\n    case LUA_TUSERDATA: return uvalue(o)->len;\n    case LUA_TTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;  /* not a C function */\n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttypenv(o)) {\n    case LUA_TUSERDATA: return (rawuvalue(o) + 1);\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TTABLE: return hvalue(o);\n    case LUA_TLCL: return clLvalue(o);\n    case LUA_TCCL: return clCvalue(o);\n    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));\n    case LUA_TTHREAD: return thvalue(o);\n    case LUA_TUSERDATA:\n    case LUA_TLIGHTUSERDATA:\n      return lua_touserdata(L, idx);\n    default: return NULL;\n  }\n}\n\n\n\n/*\n** push functions (C -> stack)\n*/\n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setnvalue(L->top, n);\n  luai_checknum(L, L->top,\n    luaG_runerror(L, \"C API - attempt to push a signaling NaN\"));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setnvalue(L->top, cast_num(n));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {\n  lua_Number n;\n  lua_lock(L);\n  n = lua_unsigned2number(u);\n  setnvalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  luaC_checkGC(L);\n  ts = luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top, ts);\n  api_incr_top(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  if (s == NULL) {\n    lua_pushnil(L);\n    return NULL;\n  }\n  else {\n    TString *ts;\n    lua_lock(L);\n    luaC_checkGC(L);\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top, ts);\n    api_incr_top(L);\n    lua_unlock(L);\n    return getstr(ts);\n  }\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  luaC_checkGC(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  luaC_checkGC(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(L->top, fn);\n  }\n  else {\n    Closure *cl;\n    api_checknelems(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    luaC_checkGC(L);\n    cl = luaF_newCclosure(L, n);\n    cl->c.f = fn;\n    L->top -= n;\n    while (n--)\n      setobj2n(L, &cl->c.upvalue[n], L->top + n);\n    setclCvalue(L, L->top, cl);\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(L->top, p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, L->top, L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n/*\n** get functions (Lua -> stack)\n*/\n\n\nLUA_API void lua_getglobal (lua_State *L, const char *var) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  const TValue *gt;  /* global table */\n  lua_lock(L);\n  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n  setsvalue2s(L, L->top++, luaS_new(L, var));\n  luaV_gettable(L, gt, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_gettable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_getfield (lua_State *L, int idx, const char *k) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  setsvalue2s(L, L->top, luaS_new(L, k));\n  api_incr_top(L);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawget (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawgeti (lua_State *L, int idx, int n) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top, luaH_getint(hvalue(t), n));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2s(L, L->top, luaH_get(hvalue(t), &k));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_createtable (lua_State *L, int narray, int nrec) {\n  Table *t;\n  lua_lock(L);\n  luaC_checkGC(L);\n  t = luaH_new(L);\n  sethvalue(L, L->top, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt = NULL;\n  int res;\n  lua_lock(L);\n  obj = index2addr(L, objindex);\n  switch (ttypenv(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttypenv(obj)];\n      break;\n  }\n  if (mt == NULL)\n    res = 0;\n  else {\n    sethvalue(L, L->top, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_getuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  o = index2addr(L, idx);\n  api_check(L, ttisuserdata(o), \"userdata expected\");\n  if (uvalue(o)->env) {\n    sethvalue(L, L->top, uvalue(o)->env);\n  } else\n    setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n/*\n** set functions (stack -> Lua)\n*/\n\n\nLUA_API void lua_setglobal (lua_State *L, const char *var) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  const TValue *gt;  /* global table */\n  lua_lock(L);\n  api_checknelems(L, 1);\n  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n  setsvalue2s(L, L->top++, luaS_new(L, var));\n  luaV_settable(L, gt, L->top - 1, L->top - 2);\n  L->top -= 2;  /* pop value and key */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  setsvalue2s(L, L->top++, luaS_new(L, k));\n  luaV_settable(L, t, L->top - 1, L->top - 2);\n  L->top -= 2;  /* pop value and key */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);\n  invalidateTMcache(hvalue(t));\n  luaC_barrierback(L, gcvalue(t), L->top-1);\n  L->top -= 2;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, int n) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  luaH_setint(L, hvalue(t), n, L->top - 1);\n  luaC_barrierback(L, gcvalue(t), L->top-1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);\n  luaC_barrierback(L, gcvalue(t), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  obj = index2addr(L, objindex);\n  if (ttisnil(L->top - 1))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    mt = hvalue(L->top - 1);\n  }\n  switch (ttypenv(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrierback(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, rawuvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttypenv(obj)] = mt;\n      break;\n    }\n  }\n  L->top--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API void lua_setuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttisuserdata(o), \"userdata expected\");\n  if (ttisnil(L->top - 1))\n    uvalue(o)->env = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    uvalue(o)->env = hvalue(L->top - 1);\n    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n  }\n  L->top--;\n  lua_unlock(L);\n}\n\n\n/*\n** `load' and `call' functions (run Lua code)\n*/\n\n\n#define checkresults(L,na,nr) \\\n     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\")\n\n\nLUA_API int lua_getctx (lua_State *L, int *ctx) {\n  if (L->ci->callstatus & CIST_YIELDED) {\n    if (ctx) *ctx = L->ci->u.c.ctx;\n    return L->ci->u.c.status;\n  }\n  else return LUA_OK;\n}\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,\n                        lua_CFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top - (nargs+1);\n  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */\n    L->ci->u.c.k = k;  /* save continuation */\n    L->ci->u.c.ctx = ctx;  /* save context */\n    luaD_call(L, func, nresults, 1);  /* do the call */\n  }\n  else  /* no continuation or no yieldable */\n    luaD_call(L, func, nresults, 0);  /* just do the call */\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n/*\n** Execute a protected call.\n*/\nstruct CallS {  /* data to `f_call' */\n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_call(L, c->func, c->nresults, 0);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        int ctx, lua_CFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);  /* function to be called */\n  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->extra = savestack(L, c.func);\n    ci->u.c.old_allowhook = L->allowhook;\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    /* mark that function may do error recovery */\n    ci->callstatus |= CIST_YPCALL;\n    luaD_call(L, c.func, nresults, 1);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {  /* no errors? */\n    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */\n    if (f->nupvalues == 1) {  /* does it have one upvalue? */\n      /* get global table from registry */\n      Table *reg = hvalue(&G(L)->l_registry);\n      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n      setobj(L, f->upvals[0]->v, gt);\n      luaC_barrier(L, f->upvals[0], gt);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {\n  int status;\n  TValue *o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = L->top - 1;\n  if (isLfunction(o))\n    status = luaU_dump(L, getproto(o), writer, data, 0);\n  else\n    status = 1;\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n/*\n** Garbage-collection function\n*/\n\nLUA_API int lua_gc (lua_State *L, int what, int data) {\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcrunning = 0;\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcrunning = 1;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(gettotalbytes(g) >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(gettotalbytes(g) & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      if (g->gckind == KGC_GEN) {  /* generational mode? */\n        res = (g->GCestimate == 0);  /* true if it will do major collection */\n        luaC_forcestep(L);  /* do a single step */\n      }\n      else {\n       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;\n       if (g->gcrunning)\n         debt += g->GCdebt;  /* include current debt */\n       luaE_setdebt(g, debt);\n       luaC_forcestep(L);\n       if (g->gcstate == GCSpause)  /* end of cycle? */\n         res = 1;  /* signal it */\n      }\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETMAJORINC: {\n      res = g->gcmajorinc;\n      g->gcmajorinc = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      g->gcstepmul = data;\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = g->gcrunning;\n      break;\n    }\n    case LUA_GCGEN: {  /* change collector to generational mode */\n      luaC_changemode(L, KGC_GEN);\n      break;\n    }\n    case LUA_GCINC: {  /* change collector to incremental mode */\n      luaC_changemode(L, KGC_NORMAL);\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\n\n/*\n** miscellaneous functions\n*/\n\n\nLUA_API int lua_error (lua_State *L) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  StkId t;\n  int more;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  more = luaH_next(L, hvalue(t), L->top - 1);\n  if (more) {\n    api_incr_top(L);\n  }\n  else  /* no more elements */\n    L->top -= 1;  /* remove key */\n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n >= 2) {\n    luaC_checkGC(L);\n    luaV_concat(L, n);\n  }\n  else if (n == 0) {  /* push empty string */\n    setsvalue2s(L, L->top, luaS_newlstr(L, \"\", 0));\n    api_incr_top(L);\n  }\n  /* else n == 1; nothing to do */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_objlen(L, L->top, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nLUA_API void *lua_newuserdata (lua_State *L, size_t size) {\n  Udata *u;\n  lua_lock(L);\n  luaC_checkGC(L);\n  u = luaS_newudata(L, size, NULL);\n  setuvalue(L, L->top, u);\n  api_incr_top(L);\n  lua_unlock(L);\n  return u + 1;\n}\n\n\n\nstatic const char *aux_upvalue (StkId fi, int n, TValue **val,\n                                GCObject **owner) {\n  switch (ttype(fi)) {\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (!(1 <= n && n <= f->nupvalues)) return NULL;\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = obj2gco(f);\n      return \"\";\n    }\n    case LUA_TLCL: {  /* Lua closure */\n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n      *val = f->upvals[n-1]->v;\n      if (owner) *owner = obj2gco(f->upvals[n - 1]);\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"\" : getstr(name);\n    }\n    default: return NULL;  /* not a closure */\n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  lua_lock(L);\n  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);\n  if (name) {\n    setobj2s(L, L->top, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  GCObject *owner = NULL;  /* to avoid warnings */\n  StkId fi;\n  lua_lock(L);\n  fi = index2addr(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner);\n  if (name) {\n    L->top--;\n    setobj(L, val, L->top);\n    luaC_barrier(L, owner, L->top);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  /* get its upvalue pointer */\n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  /* lua closure */\n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  *up1 = *up2;\n  luaC_objbarrier(L, f1, *up2);\n}\n\n","/*\n** $Id: ldump.c,v 2.17.1.1 2013/04/12 18:48:47 roberto Exp $\n** save precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#include <stddef.h>\n\n#define ldump_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lundump.h\"\n\ntypedef struct {\n lua_State* L;\n lua_Writer writer;\n void* data;\n int strip;\n int status;\n} DumpState;\n\n#define DumpMem(b,n,size,D)\tDumpBlock(b,(n)*(size),D)\n#define DumpVar(x,D)\t\tDumpMem(&x,1,sizeof(x),D)\n\nstatic void DumpBlock(const void* b, size_t size, DumpState* D)\n{\n if (D->status==0)\n {\n  lua_unlock(D->L);\n  D->status=(*D->writer)(D->L,b,size,D->data);\n  lua_lock(D->L);\n }\n}\n\nstatic void DumpChar(int y, DumpState* D)\n{\n char x=(char)y;\n DumpVar(x,D);\n}\n\nstatic void DumpInt(int x, DumpState* D)\n{\n DumpVar(x,D);\n}\n\nstatic void DumpNumber(lua_Number x, DumpState* D)\n{\n DumpVar(x,D);\n}\n\nstatic void DumpVector(const void* b, int n, size_t size, DumpState* D)\n{\n DumpInt(n,D);\n DumpMem(b,n,size,D);\n}\n\nstatic void DumpString(const TString* s, DumpState* D)\n{\n if (s==NULL)\n {\n  size_t size=0;\n  DumpVar(size,D);\n }\n else\n {\n  size_t size=s->tsv.len+1;\t\t/* include trailing '\\0' */\n  DumpVar(size,D);\n  DumpBlock(getstr(s),size*sizeof(char),D);\n }\n}\n\n#define DumpCode(f,D)\t DumpVector(f->code,f->sizecode,sizeof(Instruction),D)\n\nstatic void DumpFunction(const Proto* f, DumpState* D);\n\nstatic void DumpConstants(const Proto* f, DumpState* D)\n{\n int i,n=f->sizek;\n DumpInt(n,D);\n for (i=0; i<n; i++)\n {\n  const TValue* o=&f->k[i];\n  DumpChar(ttypenv(o),D);\n  switch (ttypenv(o))\n  {\n   case LUA_TNIL:\n\tbreak;\n   case LUA_TBOOLEAN:\n\tDumpChar(bvalue(o),D);\n\tbreak;\n   case LUA_TNUMBER:\n\tDumpNumber(nvalue(o),D);\n\tbreak;\n   case LUA_TSTRING:\n\tDumpString(rawtsvalue(o),D);\n\tbreak;\n    default: lua_assert(0);\n  }\n }\n n=f->sizep;\n DumpInt(n,D);\n for (i=0; i<n; i++) DumpFunction(f->p[i],D);\n}\n\nstatic void DumpUpvalues(const Proto* f, DumpState* D)\n{\n int i,n=f->sizeupvalues;\n DumpInt(n,D);\n for (i=0; i<n; i++)\n {\n  DumpChar(f->upvalues[i].instack,D);\n  DumpChar(f->upvalues[i].idx,D);\n }\n}\n\nstatic void DumpDebug(const Proto* f, DumpState* D)\n{\n int i,n;\n DumpString((D->strip) ? NULL : f->source,D);\n n= (D->strip) ? 0 : f->sizelineinfo;\n DumpVector(f->lineinfo,n,sizeof(int),D);\n n= (D->strip) ? 0 : f->sizelocvars;\n DumpInt(n,D);\n for (i=0; i<n; i++)\n {\n  DumpString(f->locvars[i].varname,D);\n  DumpInt(f->locvars[i].startpc,D);\n  DumpInt(f->locvars[i].endpc,D);\n }\n n= (D->strip) ? 0 : f->sizeupvalues;\n DumpInt(n,D);\n for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);\n}\n\nstatic void DumpFunction(const Proto* f, DumpState* D)\n{\n DumpInt(f->linedefined,D);\n DumpInt(f->lastlinedefined,D);\n DumpChar(f->numparams,D);\n DumpChar(f->is_vararg,D);\n DumpChar(f->maxstacksize,D);\n DumpCode(f,D);\n DumpConstants(f,D);\n DumpUpvalues(f,D);\n DumpDebug(f,D);\n}\n\nstatic void DumpHeader(DumpState* D)\n{\n lu_byte h[LUAC_HEADERSIZE];\n luaU_header(h);\n DumpBlock(h,LUAC_HEADERSIZE,D);\n}\n\n/*\n** dump Lua function as precompiled chunk\n*/\nint luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)\n{\n DumpState D;\n D.L=L;\n D.writer=w;\n D.data=data;\n D.strip=strip;\n D.status=0;\n DumpHeader(&D);\n DumpFunction(f,&D);\n return D.status;\n}\n","/*\n** $Id: llex.c,v 2.63.1.2 2013/08/30 15:49:41 roberto Exp $\n** Lexical Analyzer\n** See Copyright Notice in lua.h\n*/\n\n\n#include <locale.h>\n#include <string.h>\n\n#define llex_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldo.h\"\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lzio.h\"\n\n\n\n#define next(ls) (ls->current = zgetc(ls->z))\n\n\n\n#define currIsNewline(ls)\t(ls->current == '\\n' || ls->current == '\\r')\n\n\n/* ORDER RESERVED */\nstatic const char *const luaX_tokens [] = {\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\", \"::\", \"<eof>\",\n    \"<number>\", \"<name>\", \"<string>\"\n};\n\n\n#define save_and_next(ls) (save(ls, ls->current), next(ls))\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token);\n\n\nstatic void save (LexState *ls, int c) {\n  Mbuffer *b = ls->buff;\n  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {\n    size_t newsize;\n    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)\n      lexerror(ls, \"lexical element too long\", 0);\n    newsize = luaZ_sizebuffer(b) * 2;\n    luaZ_resizebuffer(ls->L, b, newsize);\n  }\n  b->buffer[luaZ_bufflen(b)++] = cast(char, c);\n}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaS_fix(ts);  /* reserved words are never collected */\n    ts->tsv.extra = cast_byte(i+1);  /* reserved word */\n  }\n}\n\n\nconst char *luaX_token2str (LexState *ls, int token) {\n  if (token < FIRST_RESERVED) {  /* single-byte symbols? */\n    lua_assert(token == cast(unsigned char, token));\n    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL(\"%c\"), token) :\n                              luaO_pushfstring(ls->L, \"char(%d)\", token);\n  }\n  else {\n    const char *s = luaX_tokens[token - FIRST_RESERVED];\n    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */\n      return luaO_pushfstring(ls->L, LUA_QS, s);\n    else  /* names, strings, and numerals */\n      return s;\n  }\n}\n\n\nstatic const char *txtToken (LexState *ls, int token) {\n  switch (token) {\n    case TK_NAME:\n    case TK_STRING:\n    case TK_NUMBER:\n      save(ls, '\\0');\n      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));\n    default:\n      return luaX_token2str(ls, token);\n  }\n}\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token) {\n  char buff[LUA_IDSIZE];\n  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);\n  msg = luaO_pushfstring(ls->L, \"%s:%d: %s\", buff, ls->linenumber, msg);\n  if (token)\n    luaO_pushfstring(ls->L, \"%s near %s\", msg, txtToken(ls, token));\n  luaD_throw(ls->L, LUA_ERRSYNTAX);\n}\n\n\nl_noret luaX_syntaxerror (LexState *ls, const char *msg) {\n  lexerror(ls, msg, ls->t.token);\n}\n\n\n/*\n** creates a new string and anchors it in function's table so that\n** it will not be collected until the end of the function's compilation\n** (by that time it should be anchored in function's prototype)\n*/\nTString *luaX_newstring (LexState *ls, const char *str, size_t l) {\n  lua_State *L = ls->L;\n  TValue *o;  /* entry for `str' */\n  TString *ts = luaS_newlstr(L, str, l);  /* create new string */\n  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */\n  o = luaH_set(L, ls->fs->h, L->top - 1);\n  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */\n    /* boolean value does not need GC barrier;\n       table has no metatable, so it does not need to invalidate cache */\n    setbvalue(o, 1);  /* t[string] = true */\n    luaC_checkGC(L);\n  }\n  else {  /* string already present */\n    ts = rawtsvalue(keyfromval(o));  /* re-use value previously stored */\n  }\n  L->top--;  /* remove string from stack */\n  return ts;\n}\n\n\n/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\nstatic void inclinenumber (LexState *ls) {\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);  /* skip `\\n' or `\\r' */\n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);  /* skip `\\n\\r' or `\\r\\n' */\n  if (++ls->linenumber >= MAX_INT)\n    luaX_syntaxerror(ls, \"chunk has too many lines\");\n}\n\n\nvoid luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,\n                    int firstchar) {\n  ls->decpoint = '.';\n  ls->L = L;\n  ls->current = firstchar;\n  ls->lookahead.token = TK_EOS;  /* no look-ahead token */\n  ls->z = z;\n  ls->fs = NULL;\n  ls->linenumber = 1;\n  ls->lastline = 1;\n  ls->source = source;\n  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */\n  luaS_fix(ls->envn);  /* never collect this name */\n  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */\n}\n\n\n\n/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n\n\n\nstatic int check_next (LexState *ls, const char *set) {\n  if (ls->current == '\\0' || !strchr(set, ls->current))\n    return 0;\n  save_and_next(ls);\n  return 1;\n}\n\n\n/*\n** change all characters 'from' in buffer to 'to'\n*/\nstatic void buffreplace (LexState *ls, char from, char to) {\n  size_t n = luaZ_bufflen(ls->buff);\n  char *p = luaZ_buffer(ls->buff);\n  while (n--)\n    if (p[n] == from) p[n] = to;\n}\n\n\n#if !defined(getlocaledecpoint)\n#define getlocaledecpoint()\t(localeconv()->decimal_point[0])\n#endif\n\n\n#define buff2d(b,e)\tluaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)\n\n/*\n** in case of format error, try to change decimal point separator to\n** the one defined in the current locale and check again\n*/\nstatic void trydecpoint (LexState *ls, SemInfo *seminfo) {\n  char old = ls->decpoint;\n  ls->decpoint = getlocaledecpoint();\n  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */\n  if (!buff2d(ls->buff, &seminfo->r)) {\n    /* format error with correct decimal point: no more options */\n    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */\n    lexerror(ls, \"malformed number\", TK_NUMBER);\n  }\n}\n\n\n/* LUA_NUMBER */\n/*\n** this function is quite liberal in what it accepts, as 'luaO_str2d'\n** will reject ill-formed numerals.\n*/\nstatic void read_numeral (LexState *ls, SemInfo *seminfo) {\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next(ls, \"Xx\"))  /* hexadecimal? */\n    expo = \"Pp\";\n  for (;;) {\n    if (check_next(ls, expo))  /* exponent part? */\n      check_next(ls, \"+-\");  /* optional exponent sign */\n    if (lisxdigit(ls->current) || ls->current == '.')\n      save_and_next(ls);\n    else  break;\n  }\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */\n  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */\n    trydecpoint(ls, seminfo); /* try to update decimal point separator */\n}\n\n\n/*\n** skip a sequence '[=*[' or ']=*]' and return its number of '='s or\n** -1 if sequence is malformed\n*/\nstatic int skip_sep (LexState *ls) {\n  int count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count : (-count) - 1;\n}\n\n\nstatic void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {\n  save_and_next(ls);  /* skip 2nd `[' */\n  if (currIsNewline(ls))  /* string starts with a newline? */\n    inclinenumber(ls);  /* skip it */\n  for (;;) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, (seminfo) ? \"unfinished long string\" :\n                                 \"unfinished long comment\", TK_EOS);\n        break;  /* to avoid warnings */\n      case ']': {\n        if (skip_sep(ls) == sep) {\n          save_and_next(ls);  /* skip 2nd `]' */\n          goto endloop;\n        }\n        break;\n      }\n      case '\\n': case '\\r': {\n        save(ls, '\\n');\n        inclinenumber(ls);\n        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */\n        break;\n      }\n      default: {\n        if (seminfo) save_and_next(ls);\n        else next(ls);\n      }\n    }\n  } endloop:\n  if (seminfo)\n    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),\n                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));\n}\n\n\nstatic void escerror (LexState *ls, int *c, int n, const char *msg) {\n  int i;\n  luaZ_resetbuffer(ls->buff);  /* prepare error message */\n  save(ls, '\\\\');\n  for (i = 0; i < n && c[i] != EOZ; i++)\n    save(ls, c[i]);\n  lexerror(ls, msg, TK_STRING);\n}\n\n\nstatic int readhexaesc (LexState *ls) {\n  int c[3], i;  /* keep input for error message */\n  int r = 0;  /* result accumulator */\n  c[0] = 'x';  /* for error message */\n  for (i = 1; i < 3; i++) {  /* read two hexadecimal digits */\n    c[i] = next(ls);\n    if (!lisxdigit(c[i]))\n      escerror(ls, c, i + 1, \"hexadecimal digit expected\");\n    r = (r << 4) + luaO_hexavalue(c[i]);\n  }\n  return r;\n}\n\n\nstatic int readdecesc (LexState *ls) {\n  int c[3], i;\n  int r = 0;  /* result accumulator */\n  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */\n    c[i] = ls->current;\n    r = 10*r + c[i] - '0';\n    next(ls);\n  }\n  if (r > UCHAR_MAX)\n    escerror(ls, c, i, \"decimal escape too large\");\n  return r;\n}\n\n\nstatic void read_string (LexState *ls, int del, SemInfo *seminfo) {\n  save_and_next(ls);  /* keep delimiter (for error messages) */\n  while (ls->current != del) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, \"unfinished string\", TK_EOS);\n        break;  /* to avoid warnings */\n      case '\\n':\n      case '\\r':\n        lexerror(ls, \"unfinished string\", TK_STRING);\n        break;  /* to avoid warnings */\n      case '\\\\': {  /* escape sequences */\n        int c;  /* final character to be saved */\n        next(ls);  /* do not save the `\\' */\n        switch (ls->current) {\n          case 'a': c = '\\a'; goto read_save;\n          case 'b': c = '\\b'; goto read_save;\n          case 'f': c = '\\f'; goto read_save;\n          case 'n': c = '\\n'; goto read_save;\n          case 'r': c = '\\r'; goto read_save;\n          case 't': c = '\\t'; goto read_save;\n          case 'v': c = '\\v'; goto read_save;\n          case 'x': c = readhexaesc(ls); goto read_save;\n          case '\\n': case '\\r':\n            inclinenumber(ls); c = '\\n'; goto only_save;\n          case '\\\\': case '\\\"': case '\\'':\n            c = ls->current; goto read_save;\n          case EOZ: goto no_save;  /* will raise an error next loop */\n          case 'z': {  /* zap following span of spaces */\n            next(ls);  /* skip the 'z' */\n            while (lisspace(ls->current)) {\n              if (currIsNewline(ls)) inclinenumber(ls);\n              else next(ls);\n            }\n            goto no_save;\n          }\n          default: {\n            if (!lisdigit(ls->current))\n              escerror(ls, &ls->current, 1, \"invalid escape sequence\");\n            /* digital escape \\ddd */\n            c = readdecesc(ls);\n            goto only_save;\n          }\n        }\n       read_save: next(ls);  /* read next character */\n       only_save: save(ls, c);  /* save 'c' */\n       no_save: break;\n      }\n      default:\n        save_and_next(ls);\n    }\n  }\n  save_and_next(ls);  /* skip delimiter */\n  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,\n                                   luaZ_bufflen(ls->buff) - 2);\n}\n\n\nstatic int llex (LexState *ls, SemInfo *seminfo) {\n  luaZ_resetbuffer(ls->buff);\n  for (;;) {\n    switch (ls->current) {\n      case '\\n': case '\\r': {  /* line breaks */\n        inclinenumber(ls);\n        break;\n      }\n      case ' ': case '\\f': case '\\t': case '\\v': {  /* spaces */\n        next(ls);\n        break;\n      }\n      case '-': {  /* '-' or '--' (comment) */\n        next(ls);\n        if (ls->current != '-') return '-';\n        /* else is a comment */\n        next(ls);\n        if (ls->current == '[') {  /* long comment? */\n          int sep = skip_sep(ls);\n          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */\n          if (sep >= 0) {\n            read_long_string(ls, NULL, sep);  /* skip long comment */\n            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */\n            break;\n          }\n        }\n        /* else short comment */\n        while (!currIsNewline(ls) && ls->current != EOZ)\n          next(ls);  /* skip until end of line (or end of file) */\n        break;\n      }\n      case '[': {  /* long string or simply '[' */\n        int sep = skip_sep(ls);\n        if (sep >= 0) {\n          read_long_string(ls, seminfo, sep);\n          return TK_STRING;\n        }\n        else if (sep == -1) return '[';\n        else lexerror(ls, \"invalid long string delimiter\", TK_STRING);\n      }\n      case '=': {\n        next(ls);\n        if (ls->current != '=') return '=';\n        else { next(ls); return TK_EQ; }\n      }\n      case '<': {\n        next(ls);\n        if (ls->current != '=') return '<';\n        else { next(ls); return TK_LE; }\n      }\n      case '>': {\n        next(ls);\n        if (ls->current != '=') return '>';\n        else { next(ls); return TK_GE; }\n      }\n      case '~': {\n        next(ls);\n        if (ls->current != '=') return '~';\n        else { next(ls); return TK_NE; }\n      }\n      case ':': {\n        next(ls);\n        if (ls->current != ':') return ':';\n        else { next(ls); return TK_DBCOLON; }\n      }\n      case '\"': case '\\'': {  /* short literal strings */\n        read_string(ls, ls->current, seminfo);\n        return TK_STRING;\n      }\n      case '.': {  /* '.', '..', '...', or number */\n        save_and_next(ls);\n        if (check_next(ls, \".\")) {\n          if (check_next(ls, \".\"))\n            return TK_DOTS;   /* '...' */\n          else return TK_CONCAT;   /* '..' */\n        }\n        else if (!lisdigit(ls->current)) return '.';\n        /* else go through */\n      }\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9': {\n        read_numeral(ls, seminfo);\n        return TK_NUMBER;\n      }\n      case EOZ: {\n        return TK_EOS;\n      }\n      default: {\n        if (lislalpha(ls->current)) {  /* identifier or reserved word? */\n          TString *ts;\n          do {\n            save_and_next(ls);\n          } while (lislalnum(ls->current));\n          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),\n                                  luaZ_bufflen(ls->buff));\n          seminfo->ts = ts;\n          if (isreserved(ts))  /* reserved word? */\n            return ts->tsv.extra - 1 + FIRST_RESERVED;\n          else {\n            return TK_NAME;\n          }\n        }\n        else {  /* single-char tokens (+ - / ...) */\n          int c = ls->current;\n          next(ls);\n          return c;\n        }\n      }\n    }\n  }\n}\n\n\nvoid luaX_next (LexState *ls) {\n  ls->lastline = ls->linenumber;\n  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */\n    ls->t = ls->lookahead;  /* use this one */\n    ls->lookahead.token = TK_EOS;  /* and discharge it */\n  }\n  else\n    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */\n}\n\n\nint luaX_lookahead (LexState *ls) {\n  lua_assert(ls->lookahead.token == TK_EOS);\n  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);\n  return ls->lookahead.token;\n}\n\n","/*\n** $Id: lstrlib.c,v 1.178.1.1 2013/04/12 18:48:47 roberto Exp $\n** Standard library for string operations and pattern-matching\n** See Copyright Notice in lua.h\n*/\n\n\n#include <ctype.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define lstrlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** maximum number of captures that a pattern can do during\n** pattern-matching. This limit is arbitrary.\n*/\n#if !defined(LUA_MAXCAPTURES)\n#define LUA_MAXCAPTURES\t\t32\n#endif\n\n\n/* macro to `unsign' a character */\n#define uchar(c)\t((unsigned char)(c))\n\n\n\nstatic int str_len (lua_State *L) {\n  size_t l;\n  luaL_checklstring(L, 1, &l);\n  lua_pushinteger(L, (lua_Integer)l);\n  return 1;\n}\n\n\n/* translate a relative string position: negative means back from end */\nstatic size_t posrelat (ptrdiff_t pos, size_t len) {\n  if (pos >= 0) return (size_t)pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return len - ((size_t)-pos) + 1;\n}\n\n\nstatic int str_sub (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t start = posrelat(luaL_checkinteger(L, 2), l);\n  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);\n  if (start < 1) start = 1;\n  if (end > l) end = l;\n  if (start <= end)\n    lua_pushlstring(L, s + start - 1, end - start + 1);\n  else lua_pushliteral(L, \"\");\n  return 1;\n}\n\n\nstatic int str_reverse (lua_State *L) {\n  size_t l, i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i = 0; i < l; i++)\n    p[i] = s[l - i - 1];\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_lower (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = tolower(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_upper (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = toupper(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\n/* reasonable limit to avoid arithmetic overflow */\n#define MAXSIZE\t\t((~(size_t)0) >> 1)\n\nstatic int str_rep (lua_State *L) {\n  size_t l, lsep;\n  const char *s = luaL_checklstring(L, 1, &l);\n  int n = luaL_checkint(L, 2);\n  const char *sep = luaL_optlstring(L, 3, \"\", &lsep);\n  if (n <= 0) lua_pushliteral(L, \"\");\n  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */\n    return luaL_error(L, \"resulting string too large\");\n  else {\n    size_t totallen = n * l + (n - 1) * lsep;\n    luaL_Buffer b;\n    char *p = luaL_buffinitsize(L, &b, totallen);\n    while (n-- > 1) {  /* first n-1 copies (followed by separator) */\n      memcpy(p, s, l * sizeof(char)); p += l;\n      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */\n        memcpy(p, sep, lsep * sizeof(char)); p += lsep;\n      }\n    }\n    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */\n    luaL_pushresultsize(&b, totallen);\n  }\n  return 1;\n}\n\n\nstatic int str_byte (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);\n  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);\n  int n, i;\n  if (posi < 1) posi = 1;\n  if (pose > l) pose = l;\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  n = (int)(pose -  posi + 1);\n  if (posi + n <= pose)  /* (size_t -> int) overflow? */\n    return luaL_error(L, \"string slice too long\");\n  luaL_checkstack(L, n, \"string slice too long\");\n  for (i=0; i<n; i++)\n    lua_pushinteger(L, uchar(s[posi+i-1]));\n  return n;\n}\n\n\nstatic int str_char (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_Buffer b;\n  char *p = luaL_buffinitsize(L, &b, n);\n  for (i=1; i<=n; i++) {\n    int c = luaL_checkint(L, i);\n    luaL_argcheck(L, uchar(c) == c, i, \"value out of range\");\n    p[i - 1] = uchar(c);\n  }\n  luaL_pushresultsize(&b, n);\n  return 1;\n}\n\n\nstatic int writer (lua_State *L, const void* b, size_t size, void* B) {\n  (void)L;\n  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);\n  return 0;\n}\n\n\nstatic int str_dump (lua_State *L) {\n  luaL_Buffer b;\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  lua_settop(L, 1);\n  luaL_buffinit(L,&b);\n  if (lua_dump(L, writer, &b) != 0)\n    return luaL_error(L, \"unable to dump given function\");\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\n\n/*\n** {======================================================\n** PATTERN MATCHING\n** =======================================================\n*/\n\n\n#define CAP_UNFINISHED\t(-1)\n#define CAP_POSITION\t(-2)\n\n\ntypedef struct MatchState {\n  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */\n  const char *src_init;  /* init of source string */\n  const char *src_end;  /* end ('\\0') of source string */\n  const char *p_end;  /* end ('\\0') of pattern */\n  lua_State *L;\n  int level;  /* total number of captures (finished or unfinished) */\n  struct {\n    const char *init;\n    ptrdiff_t len;\n  } capture[LUA_MAXCAPTURES];\n} MatchState;\n\n\n/* recursive function */\nstatic const char *match (MatchState *ms, const char *s, const char *p);\n\n\n/* maximum recursion depth for 'match' */\n#if !defined(MAXCCALLS)\n#define MAXCCALLS\t200\n#endif\n\n\n#define L_ESC\t\t'%'\n#define SPECIALS\t\"^$*+?.([%-\"\n\n\nstatic int check_capture (MatchState *ms, int l) {\n  l -= '1';\n  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)\n    return luaL_error(ms->L, \"invalid capture index %%%d\", l + 1);\n  return l;\n}\n\n\nstatic int capture_to_close (MatchState *ms) {\n  int level = ms->level;\n  for (level--; level>=0; level--)\n    if (ms->capture[level].len == CAP_UNFINISHED) return level;\n  return luaL_error(ms->L, \"invalid pattern capture\");\n}\n\n\nstatic const char *classend (MatchState *ms, const char *p) {\n  switch (*p++) {\n    case L_ESC: {\n      if (p == ms->p_end)\n        luaL_error(ms->L, \"malformed pattern (ends with \" LUA_QL(\"%%\") \")\");\n      return p+1;\n    }\n    case '[': {\n      if (*p == '^') p++;\n      do {  /* look for a `]' */\n        if (p == ms->p_end)\n          luaL_error(ms->L, \"malformed pattern (missing \" LUA_QL(\"]\") \")\");\n        if (*(p++) == L_ESC && p < ms->p_end)\n          p++;  /* skip escapes (e.g. `%]') */\n      } while (*p != ']');\n      return p+1;\n    }\n    default: {\n      return p;\n    }\n  }\n}\n\n\nstatic int match_class (int c, int cl) {\n  int res;\n  switch (tolower(cl)) {\n    case 'a' : res = isalpha(c); break;\n    case 'c' : res = iscntrl(c); break;\n    case 'd' : res = isdigit(c); break;\n    case 'g' : res = isgraph(c); break;\n    case 'l' : res = islower(c); break;\n    case 'p' : res = ispunct(c); break;\n    case 's' : res = isspace(c); break;\n    case 'u' : res = isupper(c); break;\n    case 'w' : res = isalnum(c); break;\n    case 'x' : res = isxdigit(c); break;\n    case 'z' : res = (c == 0); break;  /* deprecated option */\n    default: return (cl == c);\n  }\n  return (islower(cl) ? res : !res);\n}\n\n\nstatic int matchbracketclass (int c, const char *p, const char *ec) {\n  int sig = 1;\n  if (*(p+1) == '^') {\n    sig = 0;\n    p++;  /* skip the `^' */\n  }\n  while (++p < ec) {\n    if (*p == L_ESC) {\n      p++;\n      if (match_class(c, uchar(*p)))\n        return sig;\n    }\n    else if ((*(p+1) == '-') && (p+2 < ec)) {\n      p+=2;\n      if (uchar(*(p-2)) <= c && c <= uchar(*p))\n        return sig;\n    }\n    else if (uchar(*p) == c) return sig;\n  }\n  return !sig;\n}\n\n\nstatic int singlematch (MatchState *ms, const char *s, const char *p,\n                        const char *ep) {\n  if (s >= ms->src_end)\n    return 0;\n  else {\n    int c = uchar(*s);\n    switch (*p) {\n      case '.': return 1;  /* matches any char */\n      case L_ESC: return match_class(c, uchar(*(p+1)));\n      case '[': return matchbracketclass(c, p, ep-1);\n      default:  return (uchar(*p) == c);\n    }\n  }\n}\n\n\nstatic const char *matchbalance (MatchState *ms, const char *s,\n                                   const char *p) {\n  if (p >= ms->p_end - 1)\n    luaL_error(ms->L, \"malformed pattern \"\n                      \"(missing arguments to \" LUA_QL(\"%%b\") \")\");\n  if (*s != *p) return NULL;\n  else {\n    int b = *p;\n    int e = *(p+1);\n    int cont = 1;\n    while (++s < ms->src_end) {\n      if (*s == e) {\n        if (--cont == 0) return s+1;\n      }\n      else if (*s == b) cont++;\n    }\n  }\n  return NULL;  /* string ends out of balance */\n}\n\n\nstatic const char *max_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  ptrdiff_t i = 0;  /* counts maximum expand for item */\n  while (singlematch(ms, s + i, p, ep))\n    i++;\n  /* keeps trying to match with the maximum repetitions */\n  while (i>=0) {\n    const char *res = match(ms, (s+i), ep+1);\n    if (res) return res;\n    i--;  /* else didn't match; reduce 1 repetition to try again */\n  }\n  return NULL;\n}\n\n\nstatic const char *min_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  for (;;) {\n    const char *res = match(ms, s, ep+1);\n    if (res != NULL)\n      return res;\n    else if (singlematch(ms, s, p, ep))\n      s++;  /* try with one more repetition */\n    else return NULL;\n  }\n}\n\n\nstatic const char *start_capture (MatchState *ms, const char *s,\n                                    const char *p, int what) {\n  const char *res;\n  int level = ms->level;\n  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, \"too many captures\");\n  ms->capture[level].init = s;\n  ms->capture[level].len = what;\n  ms->level = level+1;\n  if ((res=match(ms, s, p)) == NULL)  /* match failed? */\n    ms->level--;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *end_capture (MatchState *ms, const char *s,\n                                  const char *p) {\n  int l = capture_to_close(ms);\n  const char *res;\n  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */\n  if ((res = match(ms, s, p)) == NULL)  /* match failed? */\n    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *match_capture (MatchState *ms, const char *s, int l) {\n  size_t len;\n  l = check_capture(ms, l);\n  len = ms->capture[l].len;\n  if ((size_t)(ms->src_end-s) >= len &&\n      memcmp(ms->capture[l].init, s, len) == 0)\n    return s+len;\n  else return NULL;\n}\n\n\nstatic const char *match (MatchState *ms, const char *s, const char *p) {\n  if (ms->matchdepth-- == 0)\n    luaL_error(ms->L, \"pattern too complex\");\n  init: /* using goto's to optimize tail recursion */\n  if (p != ms->p_end) {  /* end of pattern? */\n    switch (*p) {\n      case '(': {  /* start capture */\n        if (*(p + 1) == ')')  /* position capture? */\n          s = start_capture(ms, s, p + 2, CAP_POSITION);\n        else\n          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n        break;\n      }\n      case ')': {  /* end capture */\n        s = end_capture(ms, s, p + 1);\n        break;\n      }\n      case '$': {\n        if ((p + 1) != ms->p_end)  /* is the `$' the last char in pattern? */\n          goto dflt;  /* no; go to default */\n        s = (s == ms->src_end) ? s : NULL;  /* check end of string */\n        break;\n      }\n      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */\n        switch (*(p + 1)) {\n          case 'b': {  /* balanced string? */\n            s = matchbalance(ms, s, p + 2);\n            if (s != NULL) {\n              p += 4; goto init;  /* return match(ms, s, p + 4); */\n            }  /* else fail (s == NULL) */\n            break;\n          }\n          case 'f': {  /* frontier? */\n            const char *ep; char previous;\n            p += 2;\n            if (*p != '[')\n              luaL_error(ms->L, \"missing \" LUA_QL(\"[\") \" after \"\n                                 LUA_QL(\"%%f\") \" in pattern\");\n            ep = classend(ms, p);  /* points to what is next */\n            previous = (s == ms->src_init) ? '\\0' : *(s - 1);\n            if (!matchbracketclass(uchar(previous), p, ep - 1) &&\n               matchbracketclass(uchar(*s), p, ep - 1)) {\n              p = ep; goto init;  /* return match(ms, s, ep); */\n            }\n            s = NULL;  /* match failed */\n            break;\n          }\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n          case '8': case '9': {  /* capture results (%0-%9)? */\n            s = match_capture(ms, s, uchar(*(p + 1)));\n            if (s != NULL) {\n              p += 2; goto init;  /* return match(ms, s, p + 2) */\n            }\n            break;\n          }\n          default: goto dflt;\n        }\n        break;\n      }\n      default: dflt: {  /* pattern class plus optional suffix */\n        const char *ep = classend(ms, p);  /* points to optional suffix */\n        /* does not match at least once? */\n        if (!singlematch(ms, s, p, ep)) {\n          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */\n            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */\n          }\n          else  /* '+' or no suffix */\n            s = NULL;  /* fail */\n        }\n        else {  /* matched once */\n          switch (*ep) {  /* handle optional suffix */\n            case '?': {  /* optional */\n              const char *res;\n              if ((res = match(ms, s + 1, ep + 1)) != NULL)\n                s = res;\n              else {\n                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */\n              }\n              break;\n            }\n            case '+':  /* 1 or more repetitions */\n              s++;  /* 1 match already done */\n              /* go through */\n            case '*':  /* 0 or more repetitions */\n              s = max_expand(ms, s, p, ep);\n              break;\n            case '-':  /* 0 or more repetitions (minimum) */\n              s = min_expand(ms, s, p, ep);\n              break;\n            default:  /* no suffix */\n              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */\n          }\n        }\n        break;\n      }\n    }\n  }\n  ms->matchdepth++;\n  return s;\n}\n\n\n\nstatic const char *lmemfind (const char *s1, size_t l1,\n                               const char *s2, size_t l2) {\n  if (l2 == 0) return s1;  /* empty strings are everywhere */\n  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */\n  else {\n    const char *init;  /* to search for a `*s2' inside `s1' */\n    l2--;  /* 1st char will be checked by `memchr' */\n    l1 = l1-l2;  /* `s2' cannot be found after that */\n    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {\n      init++;   /* 1st char is already checked */\n      if (memcmp(init, s2+1, l2) == 0)\n        return init-1;\n      else {  /* correct `l1' and `s1' to try again */\n        l1 -= init-s1;\n        s1 = init;\n      }\n    }\n    return NULL;  /* not found */\n  }\n}\n\n\nstatic void push_onecapture (MatchState *ms, int i, const char *s,\n                                                    const char *e) {\n  if (i >= ms->level) {\n    if (i == 0)  /* ms->level == 0, too */\n      lua_pushlstring(ms->L, s, e - s);  /* add whole match */\n    else\n      luaL_error(ms->L, \"invalid capture index\");\n  }\n  else {\n    ptrdiff_t l = ms->capture[i].len;\n    if (l == CAP_UNFINISHED) luaL_error(ms->L, \"unfinished capture\");\n    if (l == CAP_POSITION)\n      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);\n    else\n      lua_pushlstring(ms->L, ms->capture[i].init, l);\n  }\n}\n\n\nstatic int push_captures (MatchState *ms, const char *s, const char *e) {\n  int i;\n  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;\n  luaL_checkstack(ms->L, nlevels, \"too many captures\");\n  for (i = 0; i < nlevels; i++)\n    push_onecapture(ms, i, s, e);\n  return nlevels;  /* number of strings pushed */\n}\n\n\n/* check whether pattern has no special characters */\nstatic int nospecials (const char *p, size_t l) {\n  size_t upto = 0;\n  do {\n    if (strpbrk(p + upto, SPECIALS))\n      return 0;  /* pattern has a special character */\n    upto += strlen(p + upto) + 1;  /* may have more after \\0 */\n  } while (upto <= l);\n  return 1;  /* no special chars found */\n}\n\n\nstatic int str_find_aux (lua_State *L, int find) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);\n  if (init < 1) init = 1;\n  else if (init > ls + 1) {  /* start after string's end? */\n    lua_pushnil(L);  /* cannot find anything */\n    return 1;\n  }\n  /* explicit request or no special characters? */\n  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n    /* do a plain search */\n    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);\n    if (s2) {\n      lua_pushinteger(L, s2 - s + 1);\n      lua_pushinteger(L, s2 - s + lp);\n      return 2;\n    }\n  }\n  else {\n    MatchState ms;\n    const char *s1 = s + init - 1;\n    int anchor = (*p == '^');\n    if (anchor) {\n      p++; lp--;  /* skip anchor character */\n    }\n    ms.L = L;\n    ms.matchdepth = MAXCCALLS;\n    ms.src_init = s;\n    ms.src_end = s + ls;\n    ms.p_end = p + lp;\n    do {\n      const char *res;\n      ms.level = 0;\n      lua_assert(ms.matchdepth == MAXCCALLS);\n      if ((res=match(&ms, s1, p)) != NULL) {\n        if (find) {\n          lua_pushinteger(L, s1 - s + 1);  /* start */\n          lua_pushinteger(L, res - s);   /* end */\n          return push_captures(&ms, NULL, 0) + 2;\n        }\n        else\n          return push_captures(&ms, s1, res);\n      }\n    } while (s1++ < ms.src_end && !anchor);\n  }\n  lua_pushnil(L);  /* not found */\n  return 1;\n}\n\n\nstatic int str_find (lua_State *L) {\n  return str_find_aux(L, 1);\n}\n\n\nstatic int str_match (lua_State *L) {\n  return str_find_aux(L, 0);\n}\n\n\nstatic int gmatch_aux (lua_State *L) {\n  MatchState ms;\n  size_t ls, lp;\n  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);\n  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);\n  const char *src;\n  ms.L = L;\n  ms.matchdepth = MAXCCALLS;\n  ms.src_init = s;\n  ms.src_end = s+ls;\n  ms.p_end = p + lp;\n  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));\n       src <= ms.src_end;\n       src++) {\n    const char *e;\n    ms.level = 0;\n    lua_assert(ms.matchdepth == MAXCCALLS);\n    if ((e = match(&ms, src, p)) != NULL) {\n      lua_Integer newstart = e-s;\n      if (e == src) newstart++;  /* empty match? go at least one position */\n      lua_pushinteger(L, newstart);\n      lua_replace(L, lua_upvalueindex(3));\n      return push_captures(&ms, src, e);\n    }\n  }\n  return 0;  /* not found */\n}\n\n\nstatic int gmatch (lua_State *L) {\n  luaL_checkstring(L, 1);\n  luaL_checkstring(L, 2);\n  lua_settop(L, 2);\n  lua_pushinteger(L, 0);\n  lua_pushcclosure(L, gmatch_aux, 3);\n  return 1;\n}\n\n\nstatic void add_s (MatchState *ms, luaL_Buffer *b, const char *s,\n                                                   const char *e) {\n  size_t l, i;\n  const char *news = lua_tolstring(ms->L, 3, &l);\n  for (i = 0; i < l; i++) {\n    if (news[i] != L_ESC)\n      luaL_addchar(b, news[i]);\n    else {\n      i++;  /* skip ESC */\n      if (!isdigit(uchar(news[i]))) {\n        if (news[i] != L_ESC)\n          luaL_error(ms->L, \"invalid use of \" LUA_QL(\"%c\")\n                           \" in replacement string\", L_ESC);\n        luaL_addchar(b, news[i]);\n      }\n      else if (news[i] == '0')\n          luaL_addlstring(b, s, e - s);\n      else {\n        push_onecapture(ms, news[i] - '1', s, e);\n        luaL_addvalue(b);  /* add capture to accumulated result */\n      }\n    }\n  }\n}\n\n\nstatic void add_value (MatchState *ms, luaL_Buffer *b, const char *s,\n                                       const char *e, int tr) {\n  lua_State *L = ms->L;\n  switch (tr) {\n    case LUA_TFUNCTION: {\n      int n;\n      lua_pushvalue(L, 3);\n      n = push_captures(ms, s, e);\n      lua_call(L, n, 1);\n      break;\n    }\n    case LUA_TTABLE: {\n      push_onecapture(ms, 0, s, e);\n      lua_gettable(L, 3);\n      break;\n    }\n    default: {  /* LUA_TNUMBER or LUA_TSTRING */\n      add_s(ms, b, s, e);\n      return;\n    }\n  }\n  if (!lua_toboolean(L, -1)) {  /* nil or false? */\n    lua_pop(L, 1);\n    lua_pushlstring(L, s, e - s);  /* keep original text */\n  }\n  else if (!lua_isstring(L, -1))\n    luaL_error(L, \"invalid replacement value (a %s)\", luaL_typename(L, -1));\n  luaL_addvalue(b);  /* add result to accumulator */\n}\n\n\nstatic int str_gsub (lua_State *L) {\n  size_t srcl, lp;\n  const char *src = luaL_checklstring(L, 1, &srcl);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  int tr = lua_type(L, 3);\n  size_t max_s = luaL_optinteger(L, 4, srcl+1);\n  int anchor = (*p == '^');\n  size_t n = 0;\n  MatchState ms;\n  luaL_Buffer b;\n  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n                      \"string/function/table expected\");\n  luaL_buffinit(L, &b);\n  if (anchor) {\n    p++; lp--;  /* skip anchor character */\n  }\n  ms.L = L;\n  ms.matchdepth = MAXCCALLS;\n  ms.src_init = src;\n  ms.src_end = src+srcl;\n  ms.p_end = p + lp;\n  while (n < max_s) {\n    const char *e;\n    ms.level = 0;\n    lua_assert(ms.matchdepth == MAXCCALLS);\n    e = match(&ms, src, p);\n    if (e) {\n      n++;\n      add_value(&ms, &b, src, e, tr);\n    }\n    if (e && e>src) /* non empty match? */\n      src = e;  /* skip it */\n    else if (src < ms.src_end)\n      luaL_addchar(&b, *src++);\n    else break;\n    if (anchor) break;\n  }\n  luaL_addlstring(&b, src, ms.src_end-src);\n  luaL_pushresult(&b);\n  lua_pushinteger(L, n);  /* number of substitutions */\n  return 2;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** STRING FORMAT\n** =======================================================\n*/\n\n/*\n** LUA_INTFRMLEN is the length modifier for integer conversions in\n** 'string.format'; LUA_INTFRM_T is the integer type corresponding to\n** the previous length\n*/\n#if !defined(LUA_INTFRMLEN)\t/* { */\n#if defined(LUA_USE_LONGLONG)\n\n#define LUA_INTFRMLEN\t\t\"ll\"\n#define LUA_INTFRM_T\t\tlong long\n\n#else\n\n#define LUA_INTFRMLEN\t\t\"l\"\n#define LUA_INTFRM_T\t\tlong\n\n#endif\n#endif\t\t\t\t/* } */\n\n\n/*\n** LUA_FLTFRMLEN is the length modifier for float conversions in\n** 'string.format'; LUA_FLTFRM_T is the float type corresponding to\n** the previous length\n*/\n#if !defined(LUA_FLTFRMLEN)\n\n#define LUA_FLTFRMLEN\t\t\"\"\n#define LUA_FLTFRM_T\t\tdouble\n\n#endif\n\n\n/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */\n#define MAX_ITEM\t512\n/* valid flags in a format specification */\n#define FLAGS\t\"-+ #0\"\n/*\n** maximum size of each format specification (such as '%-099.99d')\n** (+10 accounts for %99.99x plus margin of error)\n*/\n#define MAX_FORMAT\t(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)\n\n\nstatic void addquoted (lua_State *L, luaL_Buffer *b, int arg) {\n  size_t l;\n  const char *s = luaL_checklstring(L, arg, &l);\n  luaL_addchar(b, '\"');\n  while (l--) {\n    if (*s == '\"' || *s == '\\\\' || *s == '\\n') {\n      luaL_addchar(b, '\\\\');\n      luaL_addchar(b, *s);\n    }\n    else if (*s == '\\0' || iscntrl(uchar(*s))) {\n      char buff[10];\n      if (!isdigit(uchar(*(s+1))))\n        sprintf(buff, \"\\\\%d\", (int)uchar(*s));\n      else\n        sprintf(buff, \"\\\\%03d\", (int)uchar(*s));\n      luaL_addstring(b, buff);\n    }\n    else\n      luaL_addchar(b, *s);\n    s++;\n  }\n  luaL_addchar(b, '\"');\n}\n\nstatic const char *scanformat (lua_State *L, const char *strfrmt, char *form) {\n  const char *p = strfrmt;\n  while (*p != '\\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */\n  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))\n    luaL_error(L, \"invalid format (repeated flags)\");\n  if (isdigit(uchar(*p))) p++;  /* skip width */\n  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */\n  if (*p == '.') {\n    p++;\n    if (isdigit(uchar(*p))) p++;  /* skip precision */\n    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */\n  }\n  if (isdigit(uchar(*p)))\n    luaL_error(L, \"invalid format (width or precision too long)\");\n  *(form++) = '%';\n  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));\n  form += p - strfrmt + 1;\n  *form = '\\0';\n  return p;\n}\n\n\n/*\n** add length modifier into formats\n*/\nstatic void addlenmod (char *form, const char *lenmod) {\n  size_t l = strlen(form);\n  size_t lm = strlen(lenmod);\n  char spec = form[l - 1];\n  strcpy(form + l - 1, lenmod);\n  form[l + lm - 1] = spec;\n  form[l + lm] = '\\0';\n}\n\n\nstatic int str_format (lua_State *L) {\n  int top = lua_gettop(L);\n  int arg = 1;\n  size_t sfl;\n  const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n  const char *strfrmt_end = strfrmt+sfl;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while (strfrmt < strfrmt_end) {\n    if (*strfrmt != L_ESC)\n      luaL_addchar(&b, *strfrmt++);\n    else if (*++strfrmt == L_ESC)\n      luaL_addchar(&b, *strfrmt++);  /* %% */\n    else { /* format item */\n      char form[MAX_FORMAT];  /* to store the format (`%...') */\n      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */\n      int nb = 0;  /* number of bytes in added item */\n      if (++arg > top)\n        luaL_argerror(L, arg, \"no value\");\n      strfrmt = scanformat(L, strfrmt, form);\n      switch (*strfrmt++) {\n        case 'c': {\n          nb = sprintf(buff, form, luaL_checkint(L, arg));\n          break;\n        }\n        case 'd': case 'i': {\n          lua_Number n = luaL_checknumber(L, arg);\n          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;\n          lua_Number diff = n - (lua_Number)ni;\n          luaL_argcheck(L, -1 < diff && diff < 1, arg,\n                        \"not a number in proper range\");\n          addlenmod(form, LUA_INTFRMLEN);\n          nb = sprintf(buff, form, ni);\n          break;\n        }\n        case 'o': case 'u': case 'x': case 'X': {\n          lua_Number n = luaL_checknumber(L, arg);\n          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;\n          lua_Number diff = n - (lua_Number)ni;\n          luaL_argcheck(L, -1 < diff && diff < 1, arg,\n                        \"not a non-negative number in proper range\");\n          addlenmod(form, LUA_INTFRMLEN);\n          nb = sprintf(buff, form, ni);\n          break;\n        }\n        case 'e': case 'E': case 'f':\n#if defined(LUA_USE_AFORMAT)\n        case 'a': case 'A':\n#endif\n        case 'g': case 'G': {\n          addlenmod(form, LUA_FLTFRMLEN);\n          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));\n          break;\n        }\n        case 'q': {\n          addquoted(L, &b, arg);\n          break;\n        }\n        case 's': {\n          size_t l;\n          const char *s = luaL_tolstring(L, arg, &l);\n          if (!strchr(form, '.') && l >= 100) {\n            /* no precision and string is too long to be formatted;\n               keep original string */\n            luaL_addvalue(&b);\n            break;\n          }\n          else {\n            nb = sprintf(buff, form, s);\n            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */\n            break;\n          }\n        }\n        default: {  /* also treat cases `pnLlh' */\n          return luaL_error(L, \"invalid option \" LUA_QL(\"%%%c\") \" to \"\n                               LUA_QL(\"format\"), *(strfrmt - 1));\n        }\n      }\n      luaL_addsize(&b, nb);\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg strlib[] = {\n  {\"byte\", str_byte},\n  {\"char\", str_char},\n  {\"dump\", str_dump},\n  {\"find\", str_find},\n  {\"format\", str_format},\n  {\"gmatch\", gmatch},\n  {\"gsub\", str_gsub},\n  {\"len\", str_len},\n  {\"lower\", str_lower},\n  {\"match\", str_match},\n  {\"rep\", str_rep},\n  {\"reverse\", str_reverse},\n  {\"sub\", str_sub},\n  {\"upper\", str_upper},\n  {NULL, NULL}\n};\n\n\nstatic void createmetatable (lua_State *L) {\n  lua_createtable(L, 0, 1);  /* table to be metatable for strings */\n  lua_pushliteral(L, \"\");  /* dummy string */\n  lua_pushvalue(L, -2);  /* copy table */\n  lua_setmetatable(L, -2);  /* set table as metatable for strings */\n  lua_pop(L, 1);  /* pop dummy string */\n  lua_pushvalue(L, -2);  /* get string library */\n  lua_setfield(L, -2, \"__index\");  /* metatable.__index = string */\n  lua_pop(L, 1);  /* pop metatable */\n}\n\n\n/*\n** Open string library\n*/\nLUAMOD_API int luaopen_string (lua_State *L) {\n  luaL_newlib(L, strlib);\n  createmetatable(L);\n  return 1;\n}\n\n","/*\n** $Id: lauxlib.c,v 1.248.1.1 2013/04/12 18:48:47 roberto Exp $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n/* This file uses only the official API of Lua.\n** Any function declared here could be written as an application function.\n*/\n\n#define lauxlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n\n\n/*\n** {======================================================\n** Traceback\n** =======================================================\n*/\n\n\n#define LEVELS1\t12\t/* size of the first part of the stack */\n#define LEVELS2\t10\t/* size of the second part of the stack */\n\n\n\n/*\n** search for 'objidx' in table at index -1.\n** return 1 + string at top if find a good name.\n*/\nstatic int findfield (lua_State *L, int objidx, int level) {\n  if (level == 0 || !lua_istable(L, -1))\n    return 0;  /* not found */\n  lua_pushnil(L);  /* start 'next' loop */\n  while (lua_next(L, -2)) {  /* for each pair in table */\n    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */\n      if (lua_rawequal(L, objidx, -1)) {  /* found object? */\n        lua_pop(L, 1);  /* remove value (but keep name) */\n        return 1;\n      }\n      else if (findfield(L, objidx, level - 1)) {  /* try recursively */\n        lua_remove(L, -2);  /* remove table (but keep name) */\n        lua_pushliteral(L, \".\");\n        lua_insert(L, -2);  /* place '.' between the two names */\n        lua_concat(L, 3);\n        return 1;\n      }\n    }\n    lua_pop(L, 1);  /* remove value */\n  }\n  return 0;  /* not found */\n}\n\n\nstatic int pushglobalfuncname (lua_State *L, lua_Debug *ar) {\n  int top = lua_gettop(L);\n  lua_getinfo(L, \"f\", ar);  /* push function */\n  lua_pushglobaltable(L);\n  if (findfield(L, top + 1, 2)) {\n    lua_copy(L, -1, top + 1);  /* move name to proper place */\n    lua_pop(L, 2);  /* remove pushed values */\n    return 1;\n  }\n  else {\n    lua_settop(L, top);  /* remove function and global table */\n    return 0;\n  }\n}\n\n\nstatic void pushfuncname (lua_State *L, lua_Debug *ar) {\n  if (*ar->namewhat != '\\0')  /* is there a name? */\n    lua_pushfstring(L, \"function \" LUA_QS, ar->name);\n  else if (*ar->what == 'm')  /* main? */\n      lua_pushliteral(L, \"main chunk\");\n  else if (*ar->what == 'C') {\n    if (pushglobalfuncname(L, ar)) {\n      lua_pushfstring(L, \"function \" LUA_QS, lua_tostring(L, -1));\n      lua_remove(L, -2);  /* remove name */\n    }\n    else\n      lua_pushliteral(L, \"?\");\n  }\n  else\n    lua_pushfstring(L, \"function <%s:%d>\", ar->short_src, ar->linedefined);\n}\n\n\nstatic int countlevels (lua_State *L) {\n  lua_Debug ar;\n  int li = 1, le = 1;\n  /* find an upper bound */\n  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }\n  /* do a binary search */\n  while (li < le) {\n    int m = (li + le)/2;\n    if (lua_getstack(L, m, &ar)) li = m + 1;\n    else le = m;\n  }\n  return le - 1;\n}\n\n\nLUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,\n                                const char *msg, int level) {\n  lua_Debug ar;\n  int top = lua_gettop(L);\n  int numlevels = countlevels(L1);\n  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;\n  if (msg) lua_pushfstring(L, \"%s\\n\", msg);\n  lua_pushliteral(L, \"stack traceback:\");\n  while (lua_getstack(L1, level++, &ar)) {\n    if (level == mark) {  /* too many levels? */\n      lua_pushliteral(L, \"\\n\\t...\");  /* add a '...' */\n      level = numlevels - LEVELS2;  /* and skip to last ones */\n    }\n    else {\n      lua_getinfo(L1, \"Slnt\", &ar);\n      lua_pushfstring(L, \"\\n\\t%s:\", ar.short_src);\n      if (ar.currentline > 0)\n        lua_pushfstring(L, \"%d:\", ar.currentline);\n      lua_pushliteral(L, \" in \");\n      pushfuncname(L, &ar);\n      if (ar.istailcall)\n        lua_pushliteral(L, \"\\n\\t(...tail calls...)\");\n      lua_concat(L, lua_gettop(L) - top);\n    }\n  }\n  lua_concat(L, lua_gettop(L) - top);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Error-report functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {\n  lua_Debug ar;\n  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */\n    return luaL_error(L, \"bad argument #%d (%s)\", narg, extramsg);\n  lua_getinfo(L, \"n\", &ar);\n  if (strcmp(ar.namewhat, \"method\") == 0) {\n    narg--;  /* do not count `self' */\n    if (narg == 0)  /* error is in the self argument itself? */\n      return luaL_error(L, \"calling \" LUA_QS \" on bad self (%s)\",\n                           ar.name, extramsg);\n  }\n  if (ar.name == NULL)\n    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : \"?\";\n  return luaL_error(L, \"bad argument #%d to \" LUA_QS \" (%s)\",\n                        narg, ar.name, extramsg);\n}\n\n\nstatic int typeerror (lua_State *L, int narg, const char *tname) {\n  const char *msg = lua_pushfstring(L, \"%s expected, got %s\",\n                                    tname, luaL_typename(L, narg));\n  return luaL_argerror(L, narg, msg);\n}\n\n\nstatic void tag_error (lua_State *L, int narg, int tag) {\n  typeerror(L, narg, lua_typename(L, tag));\n}\n\n\nLUALIB_API void luaL_where (lua_State *L, int level) {\n  lua_Debug ar;\n  if (lua_getstack(L, level, &ar)) {  /* check function at level */\n    lua_getinfo(L, \"Sl\", &ar);  /* get info about it */\n    if (ar.currentline > 0) {  /* is there info? */\n      lua_pushfstring(L, \"%s:%d: \", ar.short_src, ar.currentline);\n      return;\n    }\n  }\n  lua_pushliteral(L, \"\");  /* else, no information available... */\n}\n\n\nLUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {\n  va_list argp;\n  va_start(argp, fmt);\n  luaL_where(L, 1);\n  lua_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_concat(L, 2);\n  return lua_error(L);\n}\n\n\nLUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {\n  int en = errno;  /* calls to Lua API may change this value */\n  if (stat) {\n    lua_pushboolean(L, 1);\n    return 1;\n  }\n  else {\n    lua_pushnil(L);\n    if (fname)\n      lua_pushfstring(L, \"%s: %s\", fname, strerror(en));\n    else\n      lua_pushstring(L, strerror(en));\n    lua_pushinteger(L, en);\n    return 3;\n  }\n}\n\n\n#if !defined(inspectstat)\t/* { */\n\n#if defined(LUA_USE_POSIX)\n\n#include <sys/wait.h>\n\n/*\n** use appropriate macros to interpret 'pclose' return status\n*/\n#define inspectstat(stat,what)  \\\n   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \\\n   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = \"signal\"; }\n\n#else\n\n#define inspectstat(stat,what)  /* no op */\n\n#endif\n\n#endif\t\t\t\t/* } */\n\n\nLUALIB_API int luaL_execresult (lua_State *L, int stat) {\n  const char *what = \"exit\";  /* type of termination */\n  if (stat == -1)  /* error? */\n    return luaL_fileresult(L, 0, NULL);\n  else {\n    inspectstat(stat, what);  /* interpret result */\n    if (*what == 'e' && stat == 0)  /* successful termination? */\n      lua_pushboolean(L, 1);\n    else\n      lua_pushnil(L);\n    lua_pushstring(L, what);\n    lua_pushinteger(L, stat);\n    return 3;  /* return true/nil,what,code */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Userdata's metatable manipulation\n** =======================================================\n*/\n\nLUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);  /* try to get metatable */\n  if (!lua_isnil(L, -1))  /* name already in use? */\n    return 0;  /* leave previous value on top, but return 0 */\n  lua_pop(L, 1);\n  lua_newtable(L);  /* create metatable */\n  lua_pushvalue(L, -1);\n  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */\n  return 1;\n}\n\n\nLUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);\n  lua_setmetatable(L, -2);\n}\n\n\nLUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {\n  void *p = lua_touserdata(L, ud);\n  if (p != NULL) {  /* value is a userdata? */\n    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n      luaL_getmetatable(L, tname);  /* get correct metatable */\n      if (!lua_rawequal(L, -1, -2))  /* not the same? */\n        p = NULL;  /* value is a userdata with wrong metatable */\n      lua_pop(L, 2);  /* remove both metatables */\n      return p;\n    }\n  }\n  return NULL;  /* value is not a userdata with a metatable */\n}\n\n\nLUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n  void *p = luaL_testudata(L, ud, tname);\n  if (p == NULL) typeerror(L, ud, tname);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Argument check functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,\n                                 const char *const lst[]) {\n  const char *name = (def) ? luaL_optstring(L, narg, def) :\n                             luaL_checkstring(L, narg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, narg,\n                       lua_pushfstring(L, \"invalid option \" LUA_QS, name));\n}\n\n\nLUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {\n  /* keep some extra space to run error routines, if needed */\n  const int extra = LUA_MINSTACK;\n  if (!lua_checkstack(L, space + extra)) {\n    if (msg)\n      luaL_error(L, \"stack overflow (%s)\", msg);\n    else\n      luaL_error(L, \"stack overflow\");\n  }\n}\n\n\nLUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {\n  if (lua_type(L, narg) != t)\n    tag_error(L, narg, t);\n}\n\n\nLUALIB_API void luaL_checkany (lua_State *L, int narg) {\n  if (lua_type(L, narg) == LUA_TNONE)\n    luaL_argerror(L, narg, \"value expected\");\n}\n\n\nLUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {\n  const char *s = lua_tolstring(L, narg, len);\n  if (!s) tag_error(L, narg, LUA_TSTRING);\n  return s;\n}\n\n\nLUALIB_API const char *luaL_optlstring (lua_State *L, int narg,\n                                        const char *def, size_t *len) {\n  if (lua_isnoneornil(L, narg)) {\n    if (len)\n      *len = (def ? strlen(def) : 0);\n    return def;\n  }\n  else return luaL_checklstring(L, narg, len);\n}\n\n\nLUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {\n  int isnum;\n  lua_Number d = lua_tonumberx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {\n  return luaL_opt(L, luaL_checknumber, narg, def);\n}\n\n\nLUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {\n  int isnum;\n  lua_Integer d = lua_tointegerx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {\n  int isnum;\n  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,\n                                                      lua_Integer def) {\n  return luaL_opt(L, luaL_checkinteger, narg, def);\n}\n\n\nLUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,\n                                                        lua_Unsigned def) {\n  return luaL_opt(L, luaL_checkunsigned, narg, def);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\n/*\n** check whether buffer is using a userdata on the stack as a temporary\n** buffer\n*/\n#define buffonstack(B)\t((B)->b != (B)->initb)\n\n\n/*\n** returns a pointer to a free area with at least 'sz' bytes\n*/\nLUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {\n  lua_State *L = B->L;\n  if (B->size - B->n < sz) {  /* not enough space? */\n    char *newbuff;\n    size_t newsize = B->size * 2;  /* double buffer size */\n    if (newsize - B->n < sz)  /* not big enough? */\n      newsize = B->n + sz;\n    if (newsize < B->n || newsize - B->n < sz)\n      luaL_error(L, \"buffer too large\");\n    /* create larger buffer */\n    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));\n    /* move content to new buffer */\n    memcpy(newbuff, B->b, B->n * sizeof(char));\n    if (buffonstack(B))\n      lua_remove(L, -2);  /* remove old buffer */\n    B->b = newbuff;\n    B->size = newsize;\n  }\n  return &B->b[B->n];\n}\n\n\nLUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {\n  char *b = luaL_prepbuffsize(B, l);\n  memcpy(b, s, l * sizeof(char));\n  luaL_addsize(B, l);\n}\n\n\nLUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {\n  luaL_addlstring(B, s, strlen(s));\n}\n\n\nLUALIB_API void luaL_pushresult (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  lua_pushlstring(L, B->b, B->n);\n  if (buffonstack(B))\n    lua_remove(L, -2);  /* remove old buffer */\n}\n\n\nLUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {\n  luaL_addsize(B, sz);\n  luaL_pushresult(B);\n}\n\n\nLUALIB_API void luaL_addvalue (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  size_t l;\n  const char *s = lua_tolstring(L, -1, &l);\n  if (buffonstack(B))\n    lua_insert(L, -2);  /* put value below buffer */\n  luaL_addlstring(B, s, l);\n  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */\n}\n\n\nLUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {\n  B->L = L;\n  B->b = B->initb;\n  B->n = 0;\n  B->size = LUAL_BUFFERSIZE;\n}\n\n\nLUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {\n  luaL_buffinit(L, B);\n  return luaL_prepbuffsize(B, sz);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Reference system\n** =======================================================\n*/\n\n/* index of free-list header */\n#define freelist\t0\n\n\nLUALIB_API int luaL_ref (lua_State *L, int t) {\n  int ref;\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* `nil' has a unique fixed reference */\n  }\n  t = lua_absindex(L, t);\n  lua_rawgeti(L, t, freelist);  /* get first free element */\n  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */\n  lua_pop(L, 1);  /* remove it from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */\n  }\n  else  /* no free elements */\n    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */\n  lua_rawseti(L, t, ref);\n  return ref;\n}\n\n\nLUALIB_API void luaL_unref (lua_State *L, int t, int ref) {\n  if (ref >= 0) {\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, freelist);\n    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */\n    lua_pushinteger(L, ref);\n    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Load functions\n** =======================================================\n*/\n\ntypedef struct LoadF {\n  int n;  /* number of pre-read characters */\n  FILE *f;  /* file being read */\n  char buff[LUAL_BUFFERSIZE];  /* area for reading file */\n} LoadF;\n\n\nstatic const char *getF (lua_State *L, void *ud, size_t *size) {\n  LoadF *lf = (LoadF *)ud;\n  (void)L;  /* not used */\n  if (lf->n > 0) {  /* are there pre-read characters to be read? */\n    *size = lf->n;  /* return them (chars already in buffer) */\n    lf->n = 0;  /* no more pre-read characters */\n  }\n  else {  /* read a block from file */\n    /* 'fread' can return > 0 *and* set the EOF flag. If next call to\n       'getF' called 'fread', it might still wait for user input.\n       The next check avoids this problem. */\n    if (feof(lf->f)) return NULL;\n    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */\n  }\n  return lf->buff;\n}\n\n\nstatic int errfile (lua_State *L, const char *what, int fnameindex) {\n  const char *serr = strerror(errno);\n  const char *filename = lua_tostring(L, fnameindex) + 1;\n  lua_pushfstring(L, \"cannot %s %s: %s\", what, filename, serr);\n  lua_remove(L, fnameindex);\n  return LUA_ERRFILE;\n}\n\n\nstatic int skipBOM (LoadF *lf) {\n  const char *p = \"\\xEF\\xBB\\xBF\";  /* Utf8 BOM mark */\n  int c;\n  lf->n = 0;\n  do {\n    c = getc(lf->f);\n    if (c == EOF || c != *(const unsigned char *)p++) return c;\n    lf->buff[lf->n++] = c;  /* to be read by the parser */\n  } while (*p != '\\0');\n  lf->n = 0;  /* prefix matched; discard it */\n  return getc(lf->f);  /* return next character */\n}\n\n\n/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\nstatic int skipcomment (LoadF *lf, int *cp) {\n  int c = *cp = skipBOM(lf);\n  if (c == '#') {  /* first line is a comment (Unix exec. file)? */\n    do {  /* skip first line */\n      c = getc(lf->f);\n    } while (c != EOF && c != '\\n') ;\n    *cp = getc(lf->f);  /* skip end-of-line, if present */\n    return 1;  /* there was a comment */\n  }\n  else return 0;  /* no comment */\n}\n\n\nLUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,\n                                             const char *mode) {\n  LoadF lf;\n  int status, readstatus;\n  int c;\n  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n  if (filename == NULL) {\n    lua_pushliteral(L, \"=stdin\");\n    lf.f = stdin;\n  }\n  else {\n    lua_pushfstring(L, \"@%s\", filename);\n    lf.f = fopen(filename, \"r\");\n    if (lf.f == NULL) return errfile(L, \"open\", fnameindex);\n  }\n  if (skipcomment(&lf, &c))  /* read initial portion */\n    lf.buff[lf.n++] = '\\n';  /* add line to correct line numbers */\n  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */\n    lf.f = freopen(filename, \"rb\", lf.f);  /* reopen in binary mode */\n    if (lf.f == NULL) return errfile(L, \"reopen\", fnameindex);\n    skipcomment(&lf, &c);  /* re-read initial portion */\n  }\n  if (c != EOF)\n    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */\n  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);\n  readstatus = ferror(lf.f);\n  if (filename) fclose(lf.f);  /* close file (even in case of errors) */\n  if (readstatus) {\n    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */\n    return errfile(L, \"read\", fnameindex);\n  }\n  lua_remove(L, fnameindex);\n  return status;\n}\n\n\ntypedef struct LoadS {\n  const char *s;\n  size_t size;\n} LoadS;\n\n\nstatic const char *getS (lua_State *L, void *ud, size_t *size) {\n  LoadS *ls = (LoadS *)ud;\n  (void)L;  /* not used */\n  if (ls->size == 0) return NULL;\n  *size = ls->size;\n  ls->size = 0;\n  return ls->s;\n}\n\n\nLUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,\n                                 const char *name, const char *mode) {\n  LoadS ls;\n  ls.s = buff;\n  ls.size = size;\n  return lua_load(L, getS, &ls, name, mode);\n}\n\n\nLUALIB_API int luaL_loadstring (lua_State *L, const char *s) {\n  return luaL_loadbuffer(L, s, strlen(s), s);\n}\n\n/* }====================================================== */\n\n\n\nLUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {\n  if (!lua_getmetatable(L, obj))  /* no metatable? */\n    return 0;\n  lua_pushstring(L, event);\n  lua_rawget(L, -2);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 2);  /* remove metatable and metafield */\n    return 0;\n  }\n  else {\n    lua_remove(L, -2);  /* remove only metatable */\n    return 1;\n  }\n}\n\n\nLUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {\n  obj = lua_absindex(L, obj);\n  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */\n    return 0;\n  lua_pushvalue(L, obj);\n  lua_call(L, 1, 1);\n  return 1;\n}\n\n\nLUALIB_API int luaL_len (lua_State *L, int idx) {\n  int l;\n  int isnum;\n  lua_len(L, idx);\n  l = (int)lua_tointegerx(L, -1, &isnum);\n  if (!isnum)\n    luaL_error(L, \"object length is not a number\");\n  lua_pop(L, 1);  /* remove object */\n  return l;\n}\n\n\nLUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {\n  if (!luaL_callmeta(L, idx, \"__tostring\")) {  /* no metafield? */\n    switch (lua_type(L, idx)) {\n      case LUA_TNUMBER:\n      case LUA_TSTRING:\n        lua_pushvalue(L, idx);\n        break;\n      case LUA_TBOOLEAN:\n        lua_pushstring(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n        break;\n      case LUA_TNIL:\n        lua_pushliteral(L, \"nil\");\n        break;\n      default:\n        lua_pushfstring(L, \"%s: %p\", luaL_typename(L, idx),\n                                            lua_topointer(L, idx));\n        break;\n    }\n  }\n  return lua_tolstring(L, -1, len);\n}\n\n\n/*\n** {======================================================\n** Compatibility with 5.1 module functions\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\nstatic const char *luaL_findtable (lua_State *L, int idx,\n                                   const char *fname, int szhint) {\n  const char *e;\n  if (idx) lua_pushvalue(L, idx);\n  do {\n    e = strchr(fname, '.');\n    if (e == NULL) e = fname + strlen(fname);\n    lua_pushlstring(L, fname, e - fname);\n    lua_rawget(L, -2);\n    if (lua_isnil(L, -1)) {  /* no such field? */\n      lua_pop(L, 1);  /* remove this nil */\n      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */\n      lua_pushlstring(L, fname, e - fname);\n      lua_pushvalue(L, -2);\n      lua_settable(L, -4);  /* set new table into field */\n    }\n    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */\n      lua_pop(L, 2);  /* remove table and value */\n      return fname;  /* return problematic part of the name */\n    }\n    lua_remove(L, -2);  /* remove previous table */\n    fname = e + 1;\n  } while (*e == '.');\n  return NULL;\n}\n\n\n/*\n** Count number of elements in a luaL_Reg list.\n*/\nstatic int libsize (const luaL_Reg *l) {\n  int size = 0;\n  for (; l && l->name; l++) size++;\n  return size;\n}\n\n\n/*\n** Find or create a module table with a given name. The function\n** first looks at the _LOADED table and, if that fails, try a\n** global variable with that name. In any case, leaves on the stack\n** the module table.\n*/\nLUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,\n                                 int sizehint) {\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 1);  /* get _LOADED table */\n  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    lua_pushglobaltable(L);\n    if (luaL_findtable(L, 0, modname, sizehint) != NULL)\n      luaL_error(L, \"name conflict for module \" LUA_QS, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */\n  }\n  lua_remove(L, -2);  /* remove _LOADED table */\n}\n\n\nLUALIB_API void luaL_openlib (lua_State *L, const char *libname,\n                               const luaL_Reg *l, int nup) {\n  luaL_checkversion(L);\n  if (libname) {\n    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */\n    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */\n  }\n  if (l)\n    luaL_setfuncs(L, l, nup);\n  else\n    lua_pop(L, nup);  /* remove upvalues */\n}\n\n#endif\n/* }====================================================== */\n\n/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\nLUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {\n  luaL_checkversion(L);\n  luaL_checkstack(L, nup, \"too many upvalues\");\n  for (; l->name != NULL; l++) {  /* fill the table with given functions */\n    int i;\n    for (i = 0; i < nup; i++)  /* copy upvalues to the top */\n      lua_pushvalue(L, -nup);\n    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */\n    lua_setfield(L, -(nup + 2), l->name);\n  }\n  lua_pop(L, nup);  /* remove upvalues */\n}\n\n\n/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\nLUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {\n  lua_getfield(L, idx, fname);\n  if (lua_istable(L, -1)) return 1;  /* table already there */\n  else {\n    lua_pop(L, 1);  /* remove previous result */\n    idx = lua_absindex(L, idx);\n    lua_newtable(L);\n    lua_pushvalue(L, -1);  /* copy to be left at top */\n    lua_setfield(L, idx, fname);  /* assign new table to field */\n    return 0;  /* false, because did not find table there */\n  }\n}\n\n\n/*\n** stripped-down 'require'. Calls 'openf' to open a module,\n** registers the result in 'package.loaded' table and, if 'glb'\n** is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\nLUALIB_API void luaL_requiref (lua_State *L, const char *modname,\n                               lua_CFunction openf, int glb) {\n  lua_pushcfunction(L, openf);\n  lua_pushstring(L, modname);  /* argument to open function */\n  lua_call(L, 1, 1);  /* open module */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_pushvalue(L, -2);  /* make copy of module (call result) */\n  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */\n  lua_pop(L, 1);  /* remove _LOADED table */\n  if (glb) {\n    lua_pushvalue(L, -1);  /* copy of 'mod' */\n    lua_setglobal(L, modname);  /* _G[modname] = module */\n  }\n}\n\n\nLUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,\n                                                               const char *r) {\n  const char *wild;\n  size_t l = strlen(p);\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(&b, s, wild - s);  /* push prefix */\n    luaL_addstring(&b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after `p' */\n  }\n  luaL_addstring(&b, s);  /* push last suffix */\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}\n\n\nstatic void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n  (void)ud; (void)osize;  /* not used */\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}\n\n\nstatic int panic (lua_State *L) {\n  luai_writestringerror(\"PANIC: unprotected error in call to Lua API (%s)\\n\",\n                   lua_tostring(L, -1));\n  return 0;  /* return to Lua to abort */\n}\n\n\nLUALIB_API lua_State *luaL_newstate (void) {\n  lua_State *L = lua_newstate(l_alloc, NULL);\n  if (L) lua_atpanic(L, &panic);\n  return L;\n}\n\n\nLUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {\n  const lua_Number *v = lua_version(L);\n  if (v != lua_version(NULL))\n    luaL_error(L, \"multiple Lua VMs detected\");\n  else if (*v != ver)\n    luaL_error(L, \"version mismatch: app. needs %f, Lua core provides %f\",\n                  ver, *v);\n  /* check conversions number -> integer types */\n  lua_pushnumber(L, -(lua_Number)0x1234);\n  if (lua_tointeger(L, -1) != -0x1234 ||\n      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)\n    luaL_error(L, \"bad conversion number->int;\"\n                  \" must recompile Lua with proper settings\");\n  lua_pop(L, 1);\n}\n\n","/*\n** $Id: lfunc.c,v 2.30.1.1 2013/04/12 18:48:47 roberto Exp $\n** Auxiliary functions to manipulate prototypes and closures\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stddef.h>\n\n#define lfunc_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\nClosure *luaF_newCclosure (lua_State *L, int n) {\n  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;\n  c->c.nupvalues = cast_byte(n);\n  return c;\n}\n\n\nClosure *luaF_newLclosure (lua_State *L, int n) {\n  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;\n  c->l.p = NULL;\n  c->l.nupvalues = cast_byte(n);\n  while (n--) c->l.upvals[n] = NULL;\n  return c;\n}\n\n\nUpVal *luaF_newupval (lua_State *L) {\n  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;\n  uv->v = &uv->u.value;\n  setnilvalue(uv->v);\n  return uv;\n}\n\n\nUpVal *luaF_findupval (lua_State *L, StkId level) {\n  global_State *g = G(L);\n  GCObject **pp = &L->openupval;\n  UpVal *p;\n  UpVal *uv;\n  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {\n    GCObject *o = obj2gco(p);\n    lua_assert(p->v != &p->u.value);\n    lua_assert(!isold(o) || isold(obj2gco(L)));\n    if (p->v == level) {  /* found a corresponding upvalue? */\n      if (isdead(g, o))  /* is it dead? */\n        changewhite(o);  /* resurrect it */\n      return p;\n    }\n    pp = &p->next;\n  }\n  /* not found: create a new one */\n  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;\n  uv->v = level;  /* current value lives in the stack */\n  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */\n  uv->u.l.next = g->uvhead.u.l.next;\n  uv->u.l.next->u.l.prev = uv;\n  g->uvhead.u.l.next = uv;\n  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);\n  return uv;\n}\n\n\nstatic void unlinkupval (UpVal *uv) {\n  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);\n  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */\n  uv->u.l.prev->u.l.next = uv->u.l.next;\n}\n\n\nvoid luaF_freeupval (lua_State *L, UpVal *uv) {\n  if (uv->v != &uv->u.value)  /* is it open? */\n    unlinkupval(uv);  /* remove from open list */\n  luaM_free(L, uv);  /* free upvalue */\n}\n\n\nvoid luaF_close (lua_State *L, StkId level) {\n  UpVal *uv;\n  global_State *g = G(L);\n  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {\n    GCObject *o = obj2gco(uv);\n    lua_assert(!isblack(o) && uv->v != &uv->u.value);\n    L->openupval = uv->next;  /* remove from `open' list */\n    if (isdead(g, o))\n      luaF_freeupval(L, uv);  /* free upvalue */\n    else {\n      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */\n      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */\n      uv->v = &uv->u.value;  /* now current value lives here */\n      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */\n      g->allgc = o;\n      luaC_checkupvalcolor(g, uv);\n    }\n  }\n}\n\n\nProto *luaF_newproto (lua_State *L) {\n  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;\n  f->k = NULL;\n  f->sizek = 0;\n  f->p = NULL;\n  f->sizep = 0;\n  f->code = NULL;\n  f->cache = NULL;\n  f->sizecode = 0;\n  f->lineinfo = NULL;\n  f->sizelineinfo = 0;\n  f->upvalues = NULL;\n  f->sizeupvalues = 0;\n  f->numparams = 0;\n  f->is_vararg = 0;\n  f->maxstacksize = 0;\n  f->locvars = NULL;\n  f->sizelocvars = 0;\n  f->linedefined = 0;\n  f->lastlinedefined = 0;\n  f->source = NULL;\n  return f;\n}\n\n\nvoid luaF_freeproto (lua_State *L, Proto *f) {\n  luaM_freearray(L, f->code, f->sizecode);\n  luaM_freearray(L, f->p, f->sizep);\n  luaM_freearray(L, f->k, f->sizek);\n  luaM_freearray(L, f->lineinfo, f->sizelineinfo);\n  luaM_freearray(L, f->locvars, f->sizelocvars);\n  luaM_freearray(L, f->upvalues, f->sizeupvalues);\n  luaM_free(L, f);\n}\n\n\n/*\n** Look for n-th local variable at line `line' in function `func'.\n** Returns NULL if not found.\n*/\nconst char *luaF_getlocalname (const Proto *f, int local_number, int pc) {\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}\n\n","/*\n** $Id: lmathlib.c,v 1.83.1.1 2013/04/12 18:48:47 roberto Exp $\n** Standard mathematical library\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stdlib.h>\n#include <math.h>\n\n#define lmathlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n#undef PI\n#define PI\t((lua_Number)(3.1415926535897932384626433832795))\n#define RADIANS_PER_DEGREE\t((lua_Number)(PI/180.0))\n\n\n\nstatic int math_abs (lua_State *L) {\n  lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sinh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_cos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_cosh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tan (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tanh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_asin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_acos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_atan (lua_State *L) {\n  lua_pushnumber(L, l_mathop(atan)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_atan2 (lua_State *L) {\n  lua_pushnumber(L, l_mathop(atan2)(luaL_checknumber(L, 1),\n                                luaL_checknumber(L, 2)));\n  return 1;\n}\n\nstatic int math_ceil (lua_State *L) {\n  lua_pushnumber(L, l_mathop(ceil)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_floor (lua_State *L) {\n  lua_pushnumber(L, l_mathop(floor)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_fmod (lua_State *L) {\n  lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),\n                               luaL_checknumber(L, 2)));\n  return 1;\n}\n\nstatic int math_modf (lua_State *L) {\n  lua_Number ip;\n  lua_Number fp = l_mathop(modf)(luaL_checknumber(L, 1), &ip);\n  lua_pushnumber(L, ip);\n  lua_pushnumber(L, fp);\n  return 2;\n}\n\nstatic int math_sqrt (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_pow (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number y = luaL_checknumber(L, 2);\n  lua_pushnumber(L, l_mathop(pow)(x, y));\n  return 1;\n}\n\nstatic int math_log (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number res;\n  if (lua_isnoneornil(L, 2))\n    res = l_mathop(log)(x);\n  else {\n    lua_Number base = luaL_checknumber(L, 2);\n    if (base == (lua_Number)10.0) res = l_mathop(log10)(x);\n    else res = l_mathop(log)(x)/l_mathop(log)(base);\n  }\n  lua_pushnumber(L, res);\n  return 1;\n}\n\n#if defined(LUA_COMPAT_LOG10)\nstatic int math_log10 (lua_State *L) {\n  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));\n  return 1;\n}\n#endif\n\nstatic int math_exp (lua_State *L) {\n  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_deg (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);\n  return 1;\n}\n\nstatic int math_rad (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);\n  return 1;\n}\n\nstatic int math_frexp (lua_State *L) {\n  int e;\n  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));\n  lua_pushinteger(L, e);\n  return 2;\n}\n\nstatic int math_ldexp (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  int ep = luaL_checkint(L, 2);\n  lua_pushnumber(L, l_mathop(ldexp)(x, ep));\n  return 1;\n}\n\n\n\nstatic int math_min (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  lua_Number dmin = luaL_checknumber(L, 1);\n  int i;\n  for (i=2; i<=n; i++) {\n    lua_Number d = luaL_checknumber(L, i);\n    if (d < dmin)\n      dmin = d;\n  }\n  lua_pushnumber(L, dmin);\n  return 1;\n}\n\n\nstatic int math_max (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  lua_Number dmax = luaL_checknumber(L, 1);\n  int i;\n  for (i=2; i<=n; i++) {\n    lua_Number d = luaL_checknumber(L, i);\n    if (d > dmax)\n      dmax = d;\n  }\n  lua_pushnumber(L, dmax);\n  return 1;\n}\n\n\nstatic int math_random (lua_State *L) {\n  /* the `%' avoids the (rare) case of r==1, and is needed also because on\n     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */\n  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;\n  switch (lua_gettop(L)) {  /* check number of arguments */\n    case 0: {  /* no arguments */\n      lua_pushnumber(L, r);  /* Number between 0 and 1 */\n      break;\n    }\n    case 1: {  /* only upper limit */\n      lua_Number u = luaL_checknumber(L, 1);\n      luaL_argcheck(L, (lua_Number)1.0 <= u, 1, \"interval is empty\");\n      lua_pushnumber(L, l_mathop(floor)(r*u) + (lua_Number)(1.0));  /* [1, u] */\n      break;\n    }\n    case 2: {  /* lower and upper limits */\n      lua_Number l = luaL_checknumber(L, 1);\n      lua_Number u = luaL_checknumber(L, 2);\n      luaL_argcheck(L, l <= u, 2, \"interval is empty\");\n      lua_pushnumber(L, l_mathop(floor)(r*(u-l+1)) + l);  /* [l, u] */\n      break;\n    }\n    default: return luaL_error(L, \"wrong number of arguments\");\n  }\n  return 1;\n}\n\n\nstatic int math_randomseed (lua_State *L) {\n  srand(luaL_checkunsigned(L, 1));\n  (void)rand(); /* discard first value to avoid undesirable correlations */\n  return 0;\n}\n\n\nstatic const luaL_Reg mathlib[] = {\n  {\"abs\",   math_abs},\n  {\"acos\",  math_acos},\n  {\"asin\",  math_asin},\n  {\"atan2\", math_atan2},\n  {\"atan\",  math_atan},\n  {\"ceil\",  math_ceil},\n  {\"cosh\",   math_cosh},\n  {\"cos\",   math_cos},\n  {\"deg\",   math_deg},\n  {\"exp\",   math_exp},\n  {\"floor\", math_floor},\n  {\"fmod\",   math_fmod},\n  {\"frexp\", math_frexp},\n  {\"ldexp\", math_ldexp},\n#if defined(LUA_COMPAT_LOG10)\n  {\"log10\", math_log10},\n#endif\n  {\"log\",   math_log},\n  {\"max\",   math_max},\n  {\"min\",   math_min},\n  {\"modf\",   math_modf},\n  {\"pow\",   math_pow},\n  {\"rad\",   math_rad},\n  {\"random\",     math_random},\n  {\"randomseed\", math_randomseed},\n  {\"sinh\",   math_sinh},\n  {\"sin\",   math_sin},\n  {\"sqrt\",  math_sqrt},\n  {\"tanh\",   math_tanh},\n  {\"tan\",   math_tan},\n  {NULL, NULL}\n};\n\n\n/*\n** Open math library\n*/\nLUAMOD_API int luaopen_math (lua_State *L) {\n  luaL_newlib(L, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n  return 1;\n}\n\n","/*\n** $Id: ltable.c,v 2.72.1.1 2013/04/12 18:48:47 roberto Exp $\n** Lua tables (hash)\n** See Copyright Notice in lua.h\n*/\n\n\n/*\n** Implementation of tables (aka arrays, objects, or hash tables).\n** Tables keep its elements in two parts: an array part and a hash part.\n** Non-negative integer keys are all candidates to be kept in the array\n** part. The actual size of the array is the largest `n' such that at\n** least half the slots between 0 and n are in use.\n** Hash uses a mix of chained scatter table with Brent's variation.\n** A main invariant of these tables is that, if an element is not\n** in its main position (i.e. the `original' position that its hash gives\n** to it), then the colliding element is in its own main position.\n** Hence even when the load factor reaches 100%, performance remains good.\n*/\n\n#include <string.h>\n\n#define ltable_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n/*\n** max size of array part is 2^MAXBITS\n*/\n#if LUAI_BITSINT >= 32\n#define MAXBITS\t\t30\n#else\n#define MAXBITS\t\t(LUAI_BITSINT-2)\n#endif\n\n#define MAXASIZE\t(1 << MAXBITS)\n\n\n#define hashpow2(t,n)\t\t(gnode(t, lmod((n), sizenode(t))))\n\n#define hashstr(t,str)\t\thashpow2(t, (str)->tsv.hash)\n#define hashboolean(t,p)\thashpow2(t, p)\n\n\n/*\n** for some types, it is better to avoid modulus by power of 2, as\n** they tend to have many 2 factors.\n*/\n#define hashmod(t,n)\t(gnode(t, ((n) % ((sizenode(t)-1)|1))))\n\n\n#define hashpointer(t,p)\thashmod(t, IntPoint(p))\n\n\n#define dummynode\t\t(&dummynode_)\n\n#define isdummy(n)\t\t((n) == dummynode)\n\nstatic const Node dummynode_ = {\n  {NILCONSTANT},  /* value */\n  {{NILCONSTANT, NULL}}  /* key */\n};\n\n\n/*\n** hash for lua_Numbers\n*/\nstatic Node *hashnum (const Table *t, lua_Number n) {\n  int i;\n  luai_hashnum(i, n);\n  if (i < 0) {\n    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */\n      i = 0;  /* handle INT_MIN */\n    i = -i;  /* must be a positive value */\n  }\n  return hashmod(t, i);\n}\n\n\n\n/*\n** returns the `main' position of an element in a table (that is, the index\n** of its hash value)\n*/\nstatic Node *mainposition (const Table *t, const TValue *key) {\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TLNGSTR: {\n      TString *s = rawtsvalue(key);\n      if (s->tsv.extra == 0) {  /* no hash? */\n        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);\n        s->tsv.extra = 1;  /* now it has its hash */\n      }\n      return hashstr(t, rawtsvalue(key));\n    }\n    case LUA_TSHRSTR:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    case LUA_TLCF:\n      return hashpointer(t, fvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}\n\n\n/*\n** returns the index for `key' if `key' is an appropriate key to live in\n** the array part of the table, -1 otherwise.\n*/\nstatic int arrayindex (const TValue *key) {\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;  /* `key' did not match some condition */\n}\n\n\n/*\n** returns the index of a `key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signaled by -1.\n*/\nstatic int findindex (lua_State *L, Table *t, StkId key) {\n  int i;\n  if (ttisnil(key)) return -1;  /* first iteration */\n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */\n    return i-1;  /* yes; that's the index (corrected to C) */\n  else {\n    Node *n = mainposition(t, key);\n    for (;;) {  /* check whether `key' is somewhere in the chain */\n      /* key may be dead already, but it is ok to use it in `next' */\n      if (luaV_rawequalobj(gkey(n), key) ||\n            (ttisdeadkey(gkey(n)) && iscollectable(key) &&\n             deadvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));  /* key index in hash table */\n        /* hash elements are numbered after array ones */\n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n      if (n == NULL)\n        luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));  /* key not found */\n    }\n  }\n}\n\n\nint luaH_next (lua_State *L, Table *t, StkId key) {\n  int i = findindex(L, t, key);  /* find original element */\n  for (i++; i < t->sizearray; i++) {  /* try first array part */\n    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */\n      setnvalue(key, cast_num(i+1));\n      setobj2s(L, key+1, &t->array[i]);\n      return 1;\n    }\n  }\n  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */\n    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */\n      setobj2s(L, key, gkey(gnode(t, i)));\n      setobj2s(L, key+1, gval(gnode(t, i)));\n      return 1;\n    }\n  }\n  return 0;  /* no more elements */\n}\n\n\n/*\n** {=============================================================\n** Rehash\n** ==============================================================\n*/\n\n\nstatic int computesizes (int nums[], int *narray) {\n  int i;\n  int twotoi;  /* 2^i */\n  int a = 0;  /* number of elements smaller than 2^i */\n  int na = 0;  /* number of elements to go to array part */\n  int n = 0;  /* optimal size for array part */\n  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {\n    if (nums[i] > 0) {\n      a += nums[i];\n      if (a > twotoi/2) {  /* more than half elements present? */\n        n = twotoi;  /* optimal size (till now) */\n        na = a;  /* all elements smaller than n will go to array part */\n      }\n    }\n    if (a == *narray) break;  /* all elements already counted */\n  }\n  *narray = n;\n  lua_assert(*narray/2 <= na && na <= *narray);\n  return na;\n}\n\n\nstatic int countint (const TValue *key, int *nums) {\n  int k = arrayindex(key);\n  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */\n    nums[luaO_ceillog2(k)]++;  /* count as such */\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\nstatic int numusearray (const Table *t, int *nums) {\n  int lg;\n  int ttlg;  /* 2^lg */\n  int ause = 0;  /* summation of `nums' */\n  int i = 1;  /* count to traverse all array keys */\n  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */\n    int lc = 0;  /* counter */\n    int lim = ttlg;\n    if (lim > t->sizearray) {\n      lim = t->sizearray;  /* adjust upper limit */\n      if (i > lim)\n        break;  /* no more elements to count */\n    }\n    /* count elements in range (2^(lg-1), 2^lg] */\n    for (; i <= lim; i++) {\n      if (!ttisnil(&t->array[i-1]))\n        lc++;\n    }\n    nums[lg] += lc;\n    ause += lc;\n  }\n  return ause;\n}\n\n\nstatic int numusehash (const Table *t, int *nums, int *pnasize) {\n  int totaluse = 0;  /* total number of elements */\n  int ause = 0;  /* summation of `nums' */\n  int i = sizenode(t);\n  while (i--) {\n    Node *n = &t->node[i];\n    if (!ttisnil(gval(n))) {\n      ause += countint(gkey(n), nums);\n      totaluse++;\n    }\n  }\n  *pnasize += ause;\n  return totaluse;\n}\n\n\nstatic void setarrayvector (lua_State *L, Table *t, int size) {\n  int i;\n  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);\n  for (i=t->sizearray; i<size; i++)\n     setnilvalue(&t->array[i]);\n  t->sizearray = size;\n}\n\n\nstatic void setnodevector (lua_State *L, Table *t, int size) {\n  int lsize;\n  if (size == 0) {  /* no elements to hash part? */\n    t->node = cast(Node *, dummynode);  /* use common `dummynode' */\n    lsize = 0;\n  }\n  else {\n    int i;\n    lsize = luaO_ceillog2(size);\n    if (lsize > MAXBITS)\n      luaG_runerror(L, \"table overflow\");\n    size = twoto(lsize);\n    t->node = luaM_newvector(L, size, Node);\n    for (i=0; i<size; i++) {\n      Node *n = gnode(t, i);\n      gnext(n) = NULL;\n      setnilvalue(gkey(n));\n      setnilvalue(gval(n));\n    }\n  }\n  t->lsizenode = cast_byte(lsize);\n  t->lastfree = gnode(t, size);  /* all positions are free */\n}\n\n\nvoid luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {\n  int i;\n  int oldasize = t->sizearray;\n  int oldhsize = t->lsizenode;\n  Node *nold = t->node;  /* save old hash ... */\n  if (nasize > oldasize)  /* array part must grow? */\n    setarrayvector(L, t, nasize);\n  /* create new hash part with appropriate size */\n  setnodevector(L, t, nhsize);\n  if (nasize < oldasize) {  /* array part must shrink? */\n    t->sizearray = nasize;\n    /* re-insert elements from vanishing slice */\n    for (i=nasize; i<oldasize; i++) {\n      if (!ttisnil(&t->array[i]))\n        luaH_setint(L, t, i + 1, &t->array[i]);\n    }\n    /* shrink array */\n    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);\n  }\n  /* re-insert elements from hash part */\n  for (i = twoto(oldhsize) - 1; i >= 0; i--) {\n    Node *old = nold+i;\n    if (!ttisnil(gval(old))) {\n      /* doesn't need barrier/invalidate cache, as entry was\n         already present in the table */\n      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));\n    }\n  }\n  if (!isdummy(nold))\n    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize))); /* free old array */\n}\n\n\nvoid luaH_resizearray (lua_State *L, Table *t, int nasize) {\n  int nsize = isdummy(t->node) ? 0 : sizenode(t);\n  luaH_resize(L, t, nasize, nsize);\n}\n\n\nstatic void rehash (lua_State *L, Table *t, const TValue *ek) {\n  int nasize, na;\n  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */\n  int i;\n  int totaluse;\n  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */\n  nasize = numusearray(t, nums);  /* count keys in array part */\n  totaluse = nasize;  /* all those keys are integer keys */\n  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */\n  /* count extra key */\n  nasize += countint(ek, nums);\n  totaluse++;\n  /* compute new size for array part */\n  na = computesizes(nums, &nasize);\n  /* resize the table to new computed sizes */\n  luaH_resize(L, t, nasize, totaluse - na);\n}\n\n\n\n/*\n** }=============================================================\n*/\n\n\nTable *luaH_new (lua_State *L) {\n  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  t->array = NULL;\n  t->sizearray = 0;\n  setnodevector(L, t, 0);\n  return t;\n}\n\n\nvoid luaH_free (lua_State *L, Table *t) {\n  if (!isdummy(t->node))\n    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));\n  luaM_freearray(L, t->array, t->sizearray);\n  luaM_free(L, t);\n}\n\n\nstatic Node *getfreepos (Table *t) {\n  while (t->lastfree > t->node) {\n    t->lastfree--;\n    if (ttisnil(gkey(t->lastfree)))\n      return t->lastfree;\n  }\n  return NULL;  /* could not find a free place */\n}\n\n\n\n/*\n** inserts a new key into a hash table; first, check whether key's main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place and\n** put new key in its main position; otherwise (colliding node is in its main\n** position), new key goes to an empty position.\n*/\nTValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {\n  Node *mp;\n  if (ttisnil(key)) luaG_runerror(L, \"table index is nil\");\n  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))\n    luaG_runerror(L, \"table index is NaN\");\n  mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */\n    Node *othern;\n    Node *n = getfreepos(t);  /* get a free place */\n    if (n == NULL) {  /* cannot find a free place? */\n      rehash(L, t, key);  /* grow table */\n      /* whatever called 'newkey' take care of TM cache and GC barrier */\n      return luaH_set(L, t, key);  /* insert key into grown table */\n    }\n    lua_assert(!isdummy(n));\n    othern = mainposition(t, gkey(mp));\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */\n      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */\n      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      gnext(mp) = NULL;  /* now `mp' is free */\n      setnilvalue(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      gnext(n) = gnext(mp);  /* chain new position */\n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  setobj2t(L, gkey(mp), key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}\n\n\n/*\n** search function for integers\n*/\nconst TValue *luaH_getint (Table *t, int key) {\n  /* (1 <= key && key <= t->sizearray) */\n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {  /* check whether `key' is somewhere in the chain */\n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);  /* that's it */\n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}\n\n\n/*\n** search function for short strings\n*/\nconst TValue *luaH_getstr (Table *t, TString *key) {\n  Node *n = hashstr(t, key);\n  lua_assert(key->tsv.tt == LUA_TSHRSTR);\n  do {  /* check whether `key' is somewhere in the chain */\n    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))\n      return gval(n);  /* that's it */\n    else n = gnext(n);\n  } while (n);\n  return luaO_nilobject;\n}\n\n\n/*\n** main search function\n*/\nconst TValue *luaH_get (Table *t, const TValue *key) {\n  switch (ttype(key)) {\n    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TNUMBER: {\n      int k;\n      lua_Number n = nvalue(key);\n      lua_number2int(k, n);\n      if (luai_numeq(cast_num(k), n)) /* index is int? */\n        return luaH_getint(t, k);  /* use specialized version */\n      /* else go through */\n    }\n    default: {\n      Node *n = mainposition(t, key);\n      do {  /* check whether `key' is somewhere in the chain */\n        if (luaV_rawequalobj(gkey(n), key))\n          return gval(n);  /* that's it */\n        else n = gnext(n);\n      } while (n);\n      return luaO_nilobject;\n    }\n  }\n}\n\n\n/*\n** beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\nTValue *luaH_set (lua_State *L, Table *t, const TValue *key) {\n  const TValue *p = luaH_get(t, key);\n  if (p != luaO_nilobject)\n    return cast(TValue *, p);\n  else return luaH_newkey(L, t, key);\n}\n\n\nvoid luaH_setint (lua_State *L, Table *t, int key, TValue *value) {\n  const TValue *p = luaH_getint(t, key);\n  TValue *cell;\n  if (p != luaO_nilobject)\n    cell = cast(TValue *, p);\n  else {\n    TValue k;\n    setnvalue(&k, cast_num(key));\n    cell = luaH_newkey(L, t, &k);\n  }\n  setobj2t(L, cell, value);\n}\n\n\nstatic int unbound_search (Table *t, unsigned int j) {\n  unsigned int i = j;  /* i is zero or a present index */\n  j++;\n  /* find `i' and `j' such that i is present and j is not */\n  while (!ttisnil(luaH_getint(t, j))) {\n    i = j;\n    j *= 2;\n    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */\n      /* table was built with bad purposes: resort to linear search */\n      i = 1;\n      while (!ttisnil(luaH_getint(t, i))) i++;\n      return i - 1;\n    }\n  }\n  /* now do a binary search between them */\n  while (j - i > 1) {\n    unsigned int m = (i+j)/2;\n    if (ttisnil(luaH_getint(t, m))) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\n/*\n** Try to find a boundary in table `t'. A `boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\nint luaH_getn (Table *t) {\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n    /* there is a boundary in the array part: (binary) search for it */\n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n  /* else must find a boundary in hash part */\n  else if (isdummy(t->node))  /* hash part is empty? */\n    return j;  /* that is easy... */\n  else return unbound_search(t, j);\n}\n\n\n\n#if defined(LUA_DEBUG)\n\nNode *luaH_mainposition (const Table *t, const TValue *key) {\n  return mainposition(t, key);\n}\n\nint luaH_isdummy (Node *n) { return isdummy(n); }\n\n#endif\n","/*\n** $Id: lundump.c,v 2.22.1.1 2013/04/12 18:48:47 roberto Exp $\n** load precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#include <string.h>\n\n#define lundump_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstring.h\"\n#include \"lundump.h\"\n#include \"lzio.h\"\n\ntypedef struct {\n lua_State* L;\n ZIO* Z;\n Mbuffer* b;\n const char* name;\n} LoadState;\n\nstatic l_noret error(LoadState* S, const char* why)\n{\n luaO_pushfstring(S->L,\"%s: %s precompiled chunk\",S->name,why);\n luaD_throw(S->L,LUA_ERRSYNTAX);\n}\n\n#define LoadMem(S,b,n,size)\tLoadBlock(S,b,(n)*(size))\n#define LoadByte(S)\t\t(lu_byte)LoadChar(S)\n#define LoadVar(S,x)\t\tLoadMem(S,&x,1,sizeof(x))\n#define LoadVector(S,b,n,size)\tLoadMem(S,b,n,size)\n\n#if !defined(luai_verifycode)\n#define luai_verifycode(L,b,f)\t/* empty */\n#endif\n\nstatic void LoadBlock(LoadState* S, void* b, size_t size)\n{\n if (luaZ_read(S->Z,b,size)!=0) error(S,\"truncated\");\n}\n\nstatic int LoadChar(LoadState* S)\n{\n char x;\n LoadVar(S,x);\n return x;\n}\n\nstatic int LoadInt(LoadState* S)\n{\n int x;\n LoadVar(S,x);\n if (x<0) error(S,\"corrupted\");\n return x;\n}\n\nstatic lua_Number LoadNumber(LoadState* S)\n{\n lua_Number x;\n LoadVar(S,x);\n return x;\n}\n\nstatic TString* LoadString(LoadState* S)\n{\n size_t size;\n LoadVar(S,size);\n if (size==0)\n  return NULL;\n else\n {\n  char* s=luaZ_openspace(S->L,S->b,size);\n  LoadBlock(S,s,size*sizeof(char));\n  return luaS_newlstr(S->L,s,size-1);\t\t/* remove trailing '\\0' */\n }\n}\n\nstatic void LoadCode(LoadState* S, Proto* f)\n{\n int n=LoadInt(S);\n f->code=luaM_newvector(S->L,n,Instruction);\n f->sizecode=n;\n LoadVector(S,f->code,n,sizeof(Instruction));\n}\n\nstatic void LoadFunction(LoadState* S, Proto* f);\n\nstatic void LoadConstants(LoadState* S, Proto* f)\n{\n int i,n;\n n=LoadInt(S);\n f->k=luaM_newvector(S->L,n,TValue);\n f->sizek=n;\n for (i=0; i<n; i++) setnilvalue(&f->k[i]);\n for (i=0; i<n; i++)\n {\n  TValue* o=&f->k[i];\n  int t=LoadChar(S);\n  switch (t)\n  {\n   case LUA_TNIL:\n\tsetnilvalue(o);\n\tbreak;\n   case LUA_TBOOLEAN:\n\tsetbvalue(o,LoadChar(S));\n\tbreak;\n   case LUA_TNUMBER:\n\tsetnvalue(o,LoadNumber(S));\n\tbreak;\n   case LUA_TSTRING:\n\tsetsvalue2n(S->L,o,LoadString(S));\n\tbreak;\n    default: lua_assert(0);\n  }\n }\n n=LoadInt(S);\n f->p=luaM_newvector(S->L,n,Proto*);\n f->sizep=n;\n for (i=0; i<n; i++) f->p[i]=NULL;\n for (i=0; i<n; i++)\n {\n  f->p[i]=luaF_newproto(S->L);\n  LoadFunction(S,f->p[i]);\n }\n}\n\nstatic void LoadUpvalues(LoadState* S, Proto* f)\n{\n int i,n;\n n=LoadInt(S);\n f->upvalues=luaM_newvector(S->L,n,Upvaldesc);\n f->sizeupvalues=n;\n for (i=0; i<n; i++) f->upvalues[i].name=NULL;\n for (i=0; i<n; i++)\n {\n  f->upvalues[i].instack=LoadByte(S);\n  f->upvalues[i].idx=LoadByte(S);\n }\n}\n\nstatic void LoadDebug(LoadState* S, Proto* f)\n{\n int i,n;\n f->source=LoadString(S);\n n=LoadInt(S);\n f->lineinfo=luaM_newvector(S->L,n,int);\n f->sizelineinfo=n;\n LoadVector(S,f->lineinfo,n,sizeof(int));\n n=LoadInt(S);\n f->locvars=luaM_newvector(S->L,n,LocVar);\n f->sizelocvars=n;\n for (i=0; i<n; i++) f->locvars[i].varname=NULL;\n for (i=0; i<n; i++)\n {\n  f->locvars[i].varname=LoadString(S);\n  f->locvars[i].startpc=LoadInt(S);\n  f->locvars[i].endpc=LoadInt(S);\n }\n n=LoadInt(S);\n for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);\n}\n\nstatic void LoadFunction(LoadState* S, Proto* f)\n{\n f->linedefined=LoadInt(S);\n f->lastlinedefined=LoadInt(S);\n f->numparams=LoadByte(S);\n f->is_vararg=LoadByte(S);\n f->maxstacksize=LoadByte(S);\n LoadCode(S,f);\n LoadConstants(S,f);\n LoadUpvalues(S,f);\n LoadDebug(S,f);\n}\n\n/* the code below must be consistent with the code in luaU_header */\n#define N0\tLUAC_HEADERSIZE\n#define N1\t(sizeof(LUA_SIGNATURE)-sizeof(char))\n#define N2\tN1+2\n#define N3\tN2+6\n\nstatic void LoadHeader(LoadState* S)\n{\n lu_byte h[LUAC_HEADERSIZE];\n lu_byte s[LUAC_HEADERSIZE];\n luaU_header(h);\n memcpy(s,h,sizeof(char));\t\t\t/* first char already read */\n LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));\n if (memcmp(h,s,N0)==0) return;\n if (memcmp(h,s,N1)!=0) error(S,\"not a\");\n if (memcmp(h,s,N2)!=0) error(S,\"version mismatch in\");\n if (memcmp(h,s,N3)!=0) error(S,\"incompatible\"); else error(S,\"corrupted\");\n}\n\n/*\n** load precompiled chunk\n*/\nClosure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)\n{\n LoadState S;\n Closure* cl;\n if (*name=='@' || *name=='=')\n  S.name=name+1;\n else if (*name==LUA_SIGNATURE[0])\n  S.name=\"binary string\";\n else\n  S.name=name;\n S.L=L;\n S.Z=Z;\n S.b=buff;\n LoadHeader(&S);\n cl=luaF_newLclosure(L,1);\n setclLvalue(L,L->top,cl); incr_top(L);\n cl->l.p=luaF_newproto(L);\n LoadFunction(&S,cl->l.p);\n if (cl->l.p->sizeupvalues != 1)\n {\n  Proto* p=cl->l.p;\n  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);\n  cl->l.p=p;\n  setclLvalue(L,L->top-1,cl);\n }\n luai_verifycode(L,buff,cl->l.p);\n return cl;\n}\n\n#define MYINT(s)\t(s[0]-'0')\n#define VERSION\t\tMYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)\n#define FORMAT\t\t0\t\t/* this is the official format */\n\n/*\n* make header for precompiled chunks\n* if you change the code below be sure to update LoadHeader and FORMAT above\n* and LUAC_HEADERSIZE in lundump.h\n*/\nvoid luaU_header (lu_byte* h)\n{\n int x=1;\n memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));\n h+=sizeof(LUA_SIGNATURE)-sizeof(char);\n *h++=cast_byte(VERSION);\n *h++=cast_byte(FORMAT);\n *h++=cast_byte(*(char*)&x);\t\t\t/* endianness */\n *h++=cast_byte(sizeof(int));\n *h++=cast_byte(sizeof(size_t));\n *h++=cast_byte(sizeof(Instruction));\n *h++=cast_byte(sizeof(lua_Number));\n *h++=cast_byte(((lua_Number)0.5)==0);\t\t/* is lua_Number integral? */\n memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));\n}\n","/*\n** $Id: lbaselib.c,v 1.276.1.1 2013/04/12 18:48:47 roberto Exp $\n** Basic library\n** See Copyright Notice in lua.h\n*/\n\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define lbaselib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\nstatic int luaB_print (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  lua_getglobal(L, \"tostring\");\n  for (i=1; i<=n; i++) {\n    const char *s;\n    size_t l;\n    lua_pushvalue(L, -1);  /* function to be called */\n    lua_pushvalue(L, i);   /* value to print */\n    lua_call(L, 1, 1);\n    s = lua_tolstring(L, -1, &l);  /* get result */\n    if (s == NULL)\n      return luaL_error(L,\n         LUA_QL(\"tostring\") \" must return a string to \" LUA_QL(\"print\"));\n    if (i>1) luai_writestring(\"\\t\", 1);\n    luai_writestring(s, l);\n    lua_pop(L, 1);  /* pop result */\n  }\n  luai_writeline();\n  return 0;\n}\n\n\n#define SPACECHARS\t\" \\f\\n\\r\\t\\v\"\n\nstatic int luaB_tonumber (lua_State *L) {\n  if (lua_isnoneornil(L, 2)) {  /* standard conversion */\n    int isnum;\n    lua_Number n = lua_tonumberx(L, 1, &isnum);\n    if (isnum) {\n      lua_pushnumber(L, n);\n      return 1;\n    }  /* else not a number; must be something */\n    luaL_checkany(L, 1);\n  }\n  else {\n    size_t l;\n    const char *s = luaL_checklstring(L, 1, &l);\n    const char *e = s + l;  /* end point for 's' */\n    int base = luaL_checkint(L, 2);\n    int neg = 0;\n    luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n    s += strspn(s, SPACECHARS);  /* skip initial spaces */\n    if (*s == '-') { s++; neg = 1; }  /* handle signal */\n    else if (*s == '+') s++;\n    if (isalnum((unsigned char)*s)) {\n      lua_Number n = 0;\n      do {\n        int digit = (isdigit((unsigned char)*s)) ? *s - '0'\n                       : toupper((unsigned char)*s) - 'A' + 10;\n        if (digit >= base) break;  /* invalid numeral; force a fail */\n        n = n * (lua_Number)base + (lua_Number)digit;\n        s++;\n      } while (isalnum((unsigned char)*s));\n      s += strspn(s, SPACECHARS);  /* skip trailing spaces */\n      if (s == e) {  /* no invalid trailing characters? */\n        lua_pushnumber(L, (neg) ? -n : n);\n        return 1;\n      }  /* else not a number */\n    }  /* else not a number */\n  }\n  lua_pushnil(L);  /* not a number */\n  return 1;\n}\n\n\nstatic int luaB_error (lua_State *L) {\n  int level = luaL_optint(L, 2, 1);\n  lua_settop(L, 1);\n  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */\n    luaL_where(L, level);\n    lua_pushvalue(L, 1);\n    lua_concat(L, 2);\n  }\n  return lua_error(L);\n}\n\n\nstatic int luaB_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);\n    return 1;  /* no metatable */\n  }\n  luaL_getmetafield(L, 1, \"__metatable\");\n  return 1;  /* returns either __metatable field (if present) or metatable */\n}\n\n\nstatic int luaB_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,\n                    \"nil or table expected\");\n  if (luaL_getmetafield(L, 1, \"__metatable\"))\n    return luaL_error(L, \"cannot change a protected metatable\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_rawequal (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_checkany(L, 2);\n  lua_pushboolean(L, lua_rawequal(L, 1, 2));\n  return 1;\n}\n\n\nstatic int luaB_rawlen (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,\n                   \"table or string expected\");\n  lua_pushinteger(L, lua_rawlen(L, 1));\n  return 1;\n}\n\n\nstatic int luaB_rawget (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  lua_rawget(L, 1);\n  return 1;\n}\n\nstatic int luaB_rawset (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  luaL_checkany(L, 3);\n  lua_settop(L, 3);\n  lua_rawset(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_collectgarbage (lua_State *L) {\n  static const char *const opts[] = {\"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"setpause\", \"setstepmul\",\n    \"setmajorinc\", \"isrunning\", \"generational\", \"incremental\", NULL};\n  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,\n    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,\n    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};\n  int o = optsnum[luaL_checkoption(L, 1, \"collect\", opts)];\n  int ex = luaL_optint(L, 2, 0);\n  int res = lua_gc(L, o, ex);\n  switch (o) {\n    case LUA_GCCOUNT: {\n      int b = lua_gc(L, LUA_GCCOUNTB, 0);\n      lua_pushnumber(L, res + ((lua_Number)b/1024));\n      lua_pushinteger(L, b);\n      return 2;\n    }\n    case LUA_GCSTEP: case LUA_GCISRUNNING: {\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    default: {\n      lua_pushinteger(L, res);\n      return 1;\n    }\n  }\n}\n\n\nstatic int luaB_type (lua_State *L) {\n  luaL_checkany(L, 1);\n  lua_pushstring(L, luaL_typename(L, 1));\n  return 1;\n}\n\n\nstatic int pairsmeta (lua_State *L, const char *method, int iszero,\n                      lua_CFunction iter) {\n  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */\n    luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */\n    lua_pushcfunction(L, iter);  /* will return generator, */\n    lua_pushvalue(L, 1);  /* state, */\n    if (iszero) lua_pushinteger(L, 0);  /* and initial value */\n    else lua_pushnil(L);\n  }\n  else {\n    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */\n    lua_call(L, 1, 3);  /* get 3 values from metamethod */\n  }\n  return 3;\n}\n\n\nstatic int luaB_next (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */\n  if (lua_next(L, 1))\n    return 2;\n  else {\n    lua_pushnil(L);\n    return 1;\n  }\n}\n\n\nstatic int luaB_pairs (lua_State *L) {\n  return pairsmeta(L, \"__pairs\", 0, luaB_next);\n}\n\n\nstatic int ipairsaux (lua_State *L) {\n  int i = luaL_checkint(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i++;  /* next value */\n  lua_pushinteger(L, i);\n  lua_rawgeti(L, 1, i);\n  return (lua_isnil(L, -1)) ? 1 : 2;\n}\n\n\nstatic int luaB_ipairs (lua_State *L) {\n  return pairsmeta(L, \"__ipairs\", 1, ipairsaux);\n}\n\n\nstatic int load_aux (lua_State *L, int status, int envidx) {\n  if (status == LUA_OK) {\n    if (envidx != 0) {  /* 'env' parameter? */\n      lua_pushvalue(L, envidx);  /* environment for loaded function */\n      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n        lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n    }\n    return 1;\n  }\n  else {  /* error (message is on top of the stack) */\n    lua_pushnil(L);\n    lua_insert(L, -2);  /* put before error message */\n    return 2;  /* return nil plus error message */\n  }\n}\n\n\nstatic int luaB_loadfile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  const char *mode = luaL_optstring(L, 2, NULL);\n  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */\n  int status = luaL_loadfilex(L, fname, mode);\n  return load_aux(L, status, env);\n}\n\n\n/*\n** {======================================================\n** Generic Read function\n** =======================================================\n*/\n\n\n/*\n** reserved slot, above all arguments, to hold a copy of the returned\n** string to avoid it being collected while parsed. 'load' has four\n** optional arguments (chunk, source name, mode, and environment).\n*/\n#define RESERVEDSLOT\t5\n\n\n/*\n** Reader for generic `load' function: `lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\nstatic const char *generic_reader (lua_State *L, void *ud, size_t *size) {\n  (void)(ud);  /* not used */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* pop result */\n    *size = 0;\n    return NULL;\n  }\n  else if (!lua_isstring(L, -1))\n    luaL_error(L, \"reader function must return a string\");\n  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */\n  return lua_tolstring(L, RESERVEDSLOT, size);\n}\n\n\nstatic int luaB_load (lua_State *L) {\n  int status;\n  size_t l;\n  const char *s = lua_tolstring(L, 1, &l);\n  const char *mode = luaL_optstring(L, 3, \"bt\");\n  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */\n  if (s != NULL) {  /* loading a string? */\n    const char *chunkname = luaL_optstring(L, 2, s);\n    status = luaL_loadbufferx(L, s, l, chunkname, mode);\n  }\n  else {  /* loading from a reader function */\n    const char *chunkname = luaL_optstring(L, 2, \"=(load)\");\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */\n    status = lua_load(L, generic_reader, NULL, chunkname, mode);\n  }\n  return load_aux(L, status, env);\n}\n\n/* }====================================================== */\n\n\nstatic int dofilecont (lua_State *L) {\n  return lua_gettop(L) - 1;\n}\n\n\nstatic int luaB_dofile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  lua_settop(L, 1);\n  if (luaL_loadfile(L, fname) != LUA_OK)\n    return lua_error(L);\n  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);\n  return dofilecont(L);\n}\n\n\nstatic int luaB_assert (lua_State *L) {\n  if (!lua_toboolean(L, 1))\n    return luaL_error(L, \"%s\", luaL_optstring(L, 2, \"assertion failed!\"));\n  return lua_gettop(L);\n}\n\n\nstatic int luaB_select (lua_State *L) {\n  int n = lua_gettop(L);\n  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {\n    lua_pushinteger(L, n-1);\n    return 1;\n  }\n  else {\n    int i = luaL_checkint(L, 1);\n    if (i < 0) i = n + i;\n    else if (i > n) i = n;\n    luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n    return n - i;\n  }\n}\n\n\nstatic int finishpcall (lua_State *L, int status) {\n  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */\n    lua_settop(L, 0);  /* create space for return values */\n    lua_pushboolean(L, 0);\n    lua_pushstring(L, \"stack overflow\");\n    return 2;  /* return false, msg */\n  }\n  lua_pushboolean(L, status);  /* first result (status) */\n  lua_replace(L, 1);  /* put first result in first slot */\n  return lua_gettop(L);\n}\n\n\nstatic int pcallcont (lua_State *L) {\n  int status = lua_getctx(L, NULL);\n  return finishpcall(L, (status == LUA_YIELD));\n}\n\n\nstatic int luaB_pcall (lua_State *L) {\n  int status;\n  luaL_checkany(L, 1);\n  lua_pushnil(L);\n  lua_insert(L, 1);  /* create space for status result */\n  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);\n  return finishpcall(L, (status == LUA_OK));\n}\n\n\nstatic int luaB_xpcall (lua_State *L) {\n  int status;\n  int n = lua_gettop(L);\n  luaL_argcheck(L, n >= 2, 2, \"value expected\");\n  lua_pushvalue(L, 1);  /* exchange function... */\n  lua_copy(L, 2, 1);  /* ...and error handler */\n  lua_replace(L, 2);\n  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);\n  return finishpcall(L, (status == LUA_OK));\n}\n\n\nstatic int luaB_tostring (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_tolstring(L, 1, NULL);\n  return 1;\n}\n\n\nstatic const luaL_Reg base_funcs[] = {\n  {\"assert\", luaB_assert},\n  {\"collectgarbage\", luaB_collectgarbage},\n  {\"dofile\", luaB_dofile},\n  {\"error\", luaB_error},\n  {\"getmetatable\", luaB_getmetatable},\n  {\"ipairs\", luaB_ipairs},\n  {\"loadfile\", luaB_loadfile},\n  {\"load\", luaB_load},\n#if defined(LUA_COMPAT_LOADSTRING)\n  {\"loadstring\", luaB_load},\n#endif\n  {\"next\", luaB_next},\n  {\"pairs\", luaB_pairs},\n  {\"pcall\", luaB_pcall},\n  {\"print\", luaB_print},\n  {\"rawequal\", luaB_rawequal},\n  {\"rawlen\", luaB_rawlen},\n  {\"rawget\", luaB_rawget},\n  {\"rawset\", luaB_rawset},\n  {\"select\", luaB_select},\n  {\"setmetatable\", luaB_setmetatable},\n  {\"tonumber\", luaB_tonumber},\n  {\"tostring\", luaB_tostring},\n  {\"type\", luaB_type},\n  {\"xpcall\", luaB_xpcall},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_base (lua_State *L) {\n  /* set global _G */\n  lua_pushglobaltable(L);\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"_G\");\n  /* open lib into global table */\n  luaL_setfuncs(L, base_funcs, 0);\n  lua_pushliteral(L, LUA_VERSION);\n  lua_setfield(L, -2, \"_VERSION\");  /* set global _VERSION */\n  return 1;\n}\n\n","/*\n** $Id: lgc.c,v 2.140.1.2 2013/04/26 18:22:05 roberto Exp $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#include <string.h>\n\n#define lgc_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n\n/*\n** cost of sweeping one element (the size of a small object divided\n** by some adjust for the sweep speed)\n*/\n#define GCSWEEPCOST\t((sizeof(TString) + 4) / 4)\n\n/* maximum number of elements to sweep in each single step */\n#define GCSWEEPMAX\t(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))\n\n/* maximum number of finalizers to call in each GC step */\n#define GCFINALIZENUM\t4\n\n\n/*\n** macro to adjust 'stepmul': 'stepmul' is actually used like\n** 'stepmul / STEPMULADJ' (value chosen by tests)\n*/\n#define STEPMULADJ\t\t200\n\n\n/*\n** macro to adjust 'pause': 'pause' is actually used like\n** 'pause / PAUSEADJ' (value chosen by tests)\n*/\n#define PAUSEADJ\t\t100\n\n\n/*\n** 'makewhite' erases all color bits plus the old bit and then\n** sets only the current white bit\n*/\n#define maskcolors\t(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))\n#define makewhite(g,x)\t\\\n (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))\n\n#define white2gray(x)\tresetbits(gch(x)->marked, WHITEBITS)\n#define black2gray(x)\tresetbit(gch(x)->marked, BLACKBIT)\n\n\n#define isfinalized(x)\t\ttestbit(gch(x)->marked, FINALIZEDBIT)\n\n#define checkdeadkey(n)\tlua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))\n\n\n#define checkconsistency(obj)  \\\n  lua_longassert(!iscollectable(obj) || righttt(obj))\n\n\n#define markvalue(g,o) { checkconsistency(o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \\\n\t\treallymarkobject(g, obj2gco(t)); }\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\n\n\n/*\n** {======================================================\n** Generic functions\n** =======================================================\n*/\n\n\n/*\n** one after last element in a hash array\n*/\n#define gnodelast(h)\tgnode(h, cast(size_t, sizenode(h)))\n\n\n/*\n** link table 'h' into list pointed by 'p'\n*/\n#define linktable(h,p)\t((h)->gclist = *(p), *(p) = obj2gco(h))\n\n\n/*\n** if key is not marked, mark its entry as dead (therefore removing it\n** from the table)\n*/\nstatic void removeentry (Node *n) {\n  lua_assert(ttisnil(gval(n)));\n  if (valiswhite(gkey(n)))\n    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */\n}\n\n\n/*\n** tells whether a key or value can be cleared from a weak\n** table. Non-collectable objects are never removed from weak\n** tables. Strings behave as `values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for objects\n** being finalized, keep them in keys, but not in values\n*/\nstatic int iscleared (global_State *g, const TValue *o) {\n  if (!iscollectable(o)) return 0;\n  else if (ttisstring(o)) {\n    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */\n    return 0;\n  }\n  else return iswhite(gcvalue(o));\n}\n\n\n/*\n** barrier that moves collector forward, that is, mark the white object\n** being pointed by a black object.\n*/\nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  lua_assert(g->gcstate != GCSpause);\n  lua_assert(gch(o)->tt != LUA_TTABLE);\n  if (keepinvariantout(g))  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}\n\n\n/*\n** barrier that moves collector backward, that is, mark the black object\n** pointing to a white object as gray again. (Current implementation\n** only works for tables; access to 'gclist' is not uniform across\n** different types.)\n*/\nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);\n  black2gray(o);  /* make object gray (again) */\n  gco2t(o)->gclist = g->grayagain;\n  g->grayagain = o;\n}\n\n\n/*\n** barrier for prototypes. When creating first closure (cache is\n** NULL), use a forward barrier; this may be the only closure of the\n** prototype (if it is a \"regular\" function, with a single instance)\n** and the prototype may be big, so it is better to avoid traversing\n** it again. Otherwise, use a backward barrier, to avoid marking all\n** possible instances.\n*/\nLUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {\n  global_State *g = G(L);\n  lua_assert(isblack(obj2gco(p)));\n  if (p->cache == NULL) {  /* first time? */\n    luaC_objbarrier(L, p, c);\n  }\n  else {  /* use a backward barrier */\n    black2gray(obj2gco(p));  /* make prototype gray (again) */\n    p->gclist = g->grayagain;\n    g->grayagain = obj2gco(p);\n  }\n}\n\n\n/*\n** check color (and invariants) for an upvalue that was closed,\n** i.e., moved into the 'allgc' list\n*/\nvoid luaC_checkupvalcolor (global_State *g, UpVal *uv) {\n  GCObject *o = obj2gco(uv);\n  lua_assert(!isblack(o));  /* open upvalues are never black */\n  if (isgray(o)) {\n    if (keepinvariant(g)) {\n      resetoldbit(o);  /* see MOVE OLD rule */\n      gray2black(o);  /* it is being visited now */\n      markvalue(g, uv->v);\n    }\n    else {\n      lua_assert(issweepphase(g));\n      makewhite(g, o);\n    }\n  }\n}\n\n\n/*\n** create a new collectable object (with given type and size) and link\n** it to '*list'. 'offset' tells how many bytes to allocate before the\n** object itself (used only by states).\n*/\nGCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,\n                       int offset) {\n  global_State *g = G(L);\n  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));\n  GCObject *o = obj2gco(raw + offset);\n  if (list == NULL)\n    list = &g->allgc;  /* standard list for collectable objects */\n  gch(o)->marked = luaC_white(g);\n  gch(o)->tt = tt;\n  gch(o)->next = *list;\n  *list = o;\n  return o;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Mark functions\n** =======================================================\n*/\n\n\n/*\n** mark an object. Userdata, strings, and closed upvalues are visited\n** and turned black here. Other objects are marked gray and added\n** to appropriate list to be visited (and turned black) later. (Open\n** upvalues are already linked in 'headuv' list.)\n*/\nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  lu_mem size;\n  white2gray(o);\n  switch (gch(o)->tt) {\n    case LUA_TSHRSTR:\n    case LUA_TLNGSTR: {\n      size = sizestring(gco2ts(o));\n      break;  /* nothing else to mark; make it black */\n    }\n    case LUA_TUSERDATA: {\n      Table *mt = gco2u(o)->metatable;\n      markobject(g, mt);\n      markobject(g, gco2u(o)->env);\n      size = sizeudata(gco2u(o));\n      break;\n    }\n    case LUA_TUPVAL: {\n      UpVal *uv = gco2uv(o);\n      markvalue(g, uv->v);\n      if (uv->v != &uv->u.value)  /* open? */\n        return;  /* open upvalues remain gray */\n      size = sizeof(UpVal);\n      break;\n    }\n    case LUA_TLCL: {\n      gco2lcl(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TCCL: {\n      gco2ccl(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TTABLE: {\n      linktable(gco2t(o), &g->gray);\n      return;\n    }\n    case LUA_TTHREAD: {\n      gco2th(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TPROTO: {\n      gco2p(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    default: lua_assert(0); return;\n  }\n  gray2black(o);\n  g->GCmemtrav += size;\n}\n\n\n/*\n** mark metamethods for basic types\n*/\nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobject(g, g->mt[i]);\n}\n\n\n/*\n** mark all objects in list of being-finalized\n*/\nstatic void markbeingfnz (global_State *g) {\n  GCObject *o;\n  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {\n    makewhite(g, o);\n    reallymarkobject(g, o);\n  }\n}\n\n\n/*\n** mark all values stored in marked open upvalues. (See comment in\n** 'lstate.h'.)\n*/\nstatic void remarkupvals (global_State *g) {\n  UpVal *uv;\n  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {\n    if (isgray(obj2gco(uv)))\n      markvalue(g, uv->v);\n  }\n}\n\n\n/*\n** mark root set and reset all gray lists, to start a new\n** incremental (or full) collection\n*/\nstatic void restartcollection (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Traverse functions\n** =======================================================\n*/\n\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  /* if there is array part, assume it may have white values (do not\n     traverse it just to check) */\n  int hasclears = (h->sizearray > 0);\n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))  /* entry is empty? */\n      removeentry(n);  /* remove it */\n    else {\n      lua_assert(!ttisnil(gkey(n)));\n      markvalue(g, gkey(n));  /* mark key */\n      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */\n        hasclears = 1;  /* table will have to be cleared */\n    }\n  }\n  if (hasclears)\n    linktable(h, &g->weak);  /* has to be cleared later */\n  else  /* no white values */\n    linktable(h, &g->grayagain);  /* no need to clean */\n}\n\n\nstatic int traverseephemeron (global_State *g, Table *h) {\n  int marked = 0;  /* true if an object is marked in this traversal */\n  int hasclears = 0;  /* true if table has white keys */\n  int prop = 0;  /* true if table has entry \"white-key -> white-value\" */\n  Node *n, *limit = gnodelast(h);\n  int i;\n  /* traverse array part (numeric keys are 'strong') */\n  for (i = 0; i < h->sizearray; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n  /* traverse hash part */\n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))  /* entry is empty? */\n      removeentry(n);  /* remove it */\n    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        prop = 1;  /* must propagate again */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  if (prop)\n    linktable(h, &g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* does table have white keys? */\n    linktable(h, &g->allweak);  /* may have to clean white keys */\n  else  /* no white keys */\n    linktable(h, &g->grayagain);  /* no need to clean */\n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  int i;\n  for (i = 0; i < h->sizearray; i++)  /* traverse array part */\n    markvalue(g, &h->array[i]);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))  /* entry is empty? */\n      removeentry(n);  /* remove it */\n    else {\n      lua_assert(!ttisnil(gkey(n)));\n      markvalue(g, gkey(n));  /* mark key */\n      markvalue(g, gval(n));  /* mark value */\n    }\n  }\n}\n\n\nstatic lu_mem traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  markobject(g, h->metatable);\n  if (mode && ttisstring(mode) &&  /* is there a weak mode? */\n      ((weakkey = strchr(svalue(mode), 'k')),\n       (weakvalue = strchr(svalue(mode), 'v')),\n       (weakkey || weakvalue))) {  /* is really weak? */\n    black2gray(obj2gco(h));  /* keep table gray */\n    if (!weakkey)  /* strong keys? */\n      traverseweakvalue(g, h);\n    else if (!weakvalue)  /* strong values? */\n      traverseephemeron(g, h);\n    else  /* all weak */\n      linktable(h, &g->allweak);  /* nothing to traverse now */\n  }\n  else  /* not weak */\n    traversestrongtable(g, h);\n  return sizeof(Table) + sizeof(TValue) * h->sizearray +\n                         sizeof(Node) * cast(size_t, sizenode(h));\n}\n\n\nstatic int traverseproto (global_State *g, Proto *f) {\n  int i;\n  if (f->cache && iswhite(obj2gco(f->cache)))\n    f->cache = NULL;  /* allow cache to be collected */\n  markobject(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobject(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobject(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobject(g, f->locvars[i].varname);\n  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +\n                         sizeof(Proto *) * f->sizep +\n                         sizeof(TValue) * f->sizek +\n                         sizeof(int) * f->sizelineinfo +\n                         sizeof(LocVar) * f->sizelocvars +\n                         sizeof(Upvaldesc) * f->sizeupvalues;\n}\n\n\nstatic lu_mem traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markvalue(g, &cl->upvalue[i]);\n  return sizeCclosure(cl->nupvalues);\n}\n\nstatic lu_mem traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobject(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markobject(g, cl->upvals[i]);\n  return sizeLclosure(cl->nupvalues);\n}\n\n\nstatic lu_mem traversestack (global_State *g, lua_State *th) {\n  int n = 0;\n  StkId o = th->stack;\n  if (o == NULL)\n    return 1;  /* stack not completely built yet */\n  for (; o < th->top; o++)  /* mark live elements in the stack */\n    markvalue(g, o);\n  if (g->gcstate == GCSatomic) {  /* final traversal? */\n    StkId lim = th->stack + th->stacksize;  /* real end of stack */\n    for (; o < lim; o++)  /* clear not-marked stack slice */\n      setnilvalue(o);\n  }\n  else {  /* count call infos to compute size */\n    CallInfo *ci;\n    for (ci = &th->base_ci; ci != th->ci; ci = ci->next)\n      n++;\n  }\n  return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n         sizeof(CallInfo) * n;\n}\n\n\n/*\n** traverse one gray object, turning it to black (except for threads,\n** which are always gray).\n*/\nstatic void propagatemark (global_State *g) {\n  lu_mem size;\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (gch(o)->tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2t(o);\n      g->gray = h->gclist;  /* remove from 'gray' list */\n      size = traversetable(g, h);\n      break;\n    }\n    case LUA_TLCL: {\n      LClosure *cl = gco2lcl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseLclosure(g, cl);\n      break;\n    }\n    case LUA_TCCL: {\n      CClosure *cl = gco2ccl(o);\n      g->gray = cl->gclist;  /* remove from 'gray' list */\n      size = traverseCclosure(g, cl);\n      break;\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;  /* remove from 'gray' list */\n      th->gclist = g->grayagain;\n      g->grayagain = o;  /* insert into 'grayagain' list */\n      black2gray(o);\n      size = traversestack(g, th);\n      break;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;  /* remove from 'gray' list */\n      size = traverseproto(g, p);\n      break;\n    }\n    default: lua_assert(0); return;\n  }\n  g->GCmemtrav += size;\n}\n\n\nstatic void propagateall (global_State *g) {\n  while (g->gray) propagatemark(g);\n}\n\n\nstatic void propagatelist (global_State *g, GCObject *l) {\n  lua_assert(g->gray == NULL);  /* no grays left */\n  g->gray = l;\n  propagateall(g);  /* traverse all elements from 'l' */\n}\n\n/*\n** retraverse all gray lists. Because tables may be reinserted in other\n** lists when traversed, traverse the original lists to avoid traversing\n** twice the same table (which is not wrong, but inefficient)\n*/\nstatic void retraversegrays (global_State *g) {\n  GCObject *weak = g->weak;  /* save original lists */\n  GCObject *grayagain = g->grayagain;\n  GCObject *ephemeron = g->ephemeron;\n  g->weak = g->grayagain = g->ephemeron = NULL;\n  propagateall(g);  /* traverse main gray list */\n  propagatelist(g, grayagain);\n  propagatelist(g, weak);\n  propagatelist(g, ephemeron);\n}\n\n\nstatic void convergeephemerons (global_State *g) {\n  int changed;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;  /* get ephemeron list */\n    g->ephemeron = NULL;  /* tables will return to this list when traversed */\n    changed = 0;\n    while ((w = next) != NULL) {\n      next = gco2t(w)->gclist;\n      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */\n        propagateall(g);  /* propagate changes */\n        changed = 1;  /* will have to revisit all ephemeron tables */\n      }\n    }\n  } while (changed);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Sweep Functions\n** =======================================================\n*/\n\n\n/*\n** clear entries with unmarked keys from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic void clearkeys (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {\n        setnilvalue(gval(n));  /* remove value ... */\n        removeentry(n);  /* and remove entry from table */\n      }\n    }\n  }\n}\n\n\n/*\n** clear entries with unmarked values from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic void clearvalues (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    int i;\n    for (i = 0; i < h->sizearray; i++) {\n      TValue *o = &h->array[i];\n      if (iscleared(g, o))  /* value was collected? */\n        setnilvalue(o);  /* remove value */\n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {\n        setnilvalue(gval(n));  /* remove value ... */\n        removeentry(n);  /* and remove entry from table */\n      }\n    }\n  }\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  switch (gch(o)->tt) {\n    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;\n    case LUA_TLCL: {\n      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));\n      break;\n    }\n    case LUA_TCCL: {\n      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));\n      break;\n    }\n    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;\n    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;\n    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;\n    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;\n    case LUA_TSHRSTR:\n      G(L)->strt.nuse--;\n      /* go through */\n    case LUA_TLNGSTR: {\n      luaM_freemem(L, o, sizestring(gco2ts(o)));\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\n#define sweepwholelist(L,p)\tsweeplist(L,p,MAX_LUMEM)\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);\n\n\n/*\n** sweep the (open) upvalues of a thread and resize its stack and\n** list of call-info structures.\n*/\nstatic void sweepthread (lua_State *L, lua_State *L1) {\n  if (L1->stack == NULL) return;  /* stack not completely built yet */\n  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */\n  luaE_freeCI(L1);  /* free extra CallInfo slots */\n  /* should not change the stack during an emergency gc cycle */\n  if (G(L)->gckind != KGC_EMERGENCY)\n    luaD_shrinkstack(L1);\n}\n\n\n/*\n** sweep at most 'count' elements from a list of GCObjects erasing dead\n** objects, where a dead (not alive) object is one marked with the \"old\"\n** (non current) white and not fixed.\n** In non-generational mode, change all non-dead objects back to white,\n** preparing for next collection cycle.\n** In generational mode, keep black objects black, and also mark them as\n** old; stop when hitting an old object, as all objects after that\n** one will be old too.\n** When object is a thread, sweep its list of open upvalues too.\n*/\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int toclear, toset;  /* bits to clear and to set in all live objects */\n  int tostop;  /* stop sweep when this is true */\n  if (isgenerational(g)) {  /* generational mode? */\n    toclear = ~0;  /* clear nothing */\n    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */\n    tostop = bitmask(OLDBIT);  /* do not sweep old generation */\n  }\n  else {  /* normal mode */\n    toclear = maskcolors;  /* clear all color bits + old bit */\n    toset = luaC_white(g);  /* make object white */\n    tostop = 0;  /* do not stop */\n  }\n  while (*p != NULL && count-- > 0) {\n    GCObject *curr = *p;\n    int marked = gch(curr)->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = gch(curr)->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {\n      if (testbits(marked, tostop))\n        return NULL;  /* stop sweeping this list */\n      if (gch(curr)->tt == LUA_TTHREAD)\n        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */\n      /* update marks */\n      gch(curr)->marked = cast_byte((marked & toclear) | toset);\n      p = &gch(curr)->next;  /* go to next element */\n    }\n  }\n  return (*p == NULL) ? NULL : p;\n}\n\n\n/*\n** sweep a list until a live object (or end of list)\n*/\nstatic GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {\n  GCObject ** old = p;\n  int i = 0;\n  do {\n    i++;\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  if (n) *n += i;\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Finalization\n** =======================================================\n*/\n\nstatic void checkSizes (lua_State *L) {\n  global_State *g = G(L);\n  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */\n    int hs = g->strt.size / 2;  /* half the size of the string table */\n    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */\n      luaS_resize(L, hs);  /* halve its size */\n    luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */\n  }\n}\n\n\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;  /* get first element */\n  lua_assert(isfinalized(o));\n  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */\n  gch(o)->next = g->allgc;  /* return it to 'allgc' list */\n  g->allgc = o;\n  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */\n  lua_assert(!isold(o));  /* see MOVE OLD rule */\n  if (!keepinvariantout(g))  /* not keeping invariant? */\n    makewhite(g, o);  /* \"sweep\" object */\n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_call(L, L->top - 2, 0, 0);\n}\n\n\nstatic void GCTM (lua_State *L, int propagateerrors) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */\n    int status;\n    lu_byte oldah = L->allowhook;\n    int running  = g->gcrunning;\n    L->allowhook = 0;  /* stop debug hooks during GC metamethod */\n    g->gcrunning = 0;  /* avoid GC steps */\n    setobj2s(L, L->top, tm);  /* push finalizer... */\n    setobj2s(L, L->top + 1, &v);  /* ... and its argument */\n    L->top += 2;  /* and (next line) call the finalizer */\n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);\n    L->allowhook = oldah;  /* restore hooks */\n    g->gcrunning = running;  /* restore state */\n    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */\n      if (status == LUA_ERRRUN) {  /* is there an error object? */\n        const char *msg = (ttisstring(L->top - 1))\n                            ? svalue(L->top - 1)\n                            : \"no message\";\n        luaO_pushfstring(L, \"error in __gc metamethod (%s)\", msg);\n        status = LUA_ERRGCMM;  /* error in __gc metamethod */\n      }\n      luaD_throw(L, status);  /* re-throw error */\n    }\n  }\n}\n\n\n/*\n** move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized)\n*/\nstatic void separatetobefnz (lua_State *L, int all) {\n  global_State *g = G(L);\n  GCObject **p = &g->finobj;\n  GCObject *curr;\n  GCObject **lastnext = &g->tobefnz;\n  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */\n  while (*lastnext != NULL)\n    lastnext = &gch(*lastnext)->next;\n  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */\n    lua_assert(!isfinalized(curr));\n    lua_assert(testbit(gch(curr)->marked, SEPARATED));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &gch(curr)->next;  /* don't bother with it */\n    else {\n      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */\n      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */\n      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &gch(curr)->next;\n    }\n  }\n}\n\n\n/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */\n      isfinalized(o) ||                           /* ... or is finalized... */\n      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    GCheader *ho = gch(o);\n    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */\n      lua_assert(issweepphase(g));\n      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);\n    }\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }\n    *p = ho->next;  /* remove 'o' from root list */\n    ho->next = g->finobj;  /* link it in list 'finobj' */\n    g->finobj = o;\n    l_setbit(ho->marked, SEPARATED);  /* mark it as such */\n    if (!keepinvariantout(g))  /* not keeping invariant? */\n      makewhite(g, o);  /* \"sweep\" object */\n    else\n      resetoldbit(o);  /* see MOVE OLD rule */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** GC control\n** =======================================================\n*/\n\n\n/*\n** set a reasonable \"time\" to wait before starting a new GC cycle;\n** cycle will start when memory use hits threshold\n*/\nstatic void setpause (global_State *g, l_mem estimate) {\n  l_mem debt, threshold;\n  estimate = estimate / PAUSEADJ;  /* adjust 'estimate' */\n  threshold = (g->gcpause < MAX_LMEM / estimate)  /* overflow? */\n            ? estimate * g->gcpause  /* no overflow */\n            : MAX_LMEM;  /* overflow; truncate to maximum */\n  debt = -cast(l_mem, threshold - gettotalbytes(g));\n  luaE_setdebt(g, debt);\n}\n\n\n#define sweepphases  \\\n\t(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))\n\n\n/*\n** enter first sweep phase (strings) and prepare pointers for other\n** sweep phases.  The calls to 'sweeptolive' make pointers point to an\n** object inside the list (instead of to the header), so that the real\n** sweep do not need to skip objects created between \"now\" and the start\n** of the real sweep.\n** Returns how many objects it swept.\n*/\nstatic int entersweep (lua_State *L) {\n  global_State *g = G(L);\n  int n = 0;\n  g->gcstate = GCSsweepstring;\n  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);\n  /* prepare to sweep strings, finalizable objects, and regular objects */\n  g->sweepstrgc = 0;\n  g->sweepfin = sweeptolive(L, &g->finobj, &n);\n  g->sweepgc = sweeptolive(L, &g->allgc, &n);\n  return n;\n}\n\n\n/*\n** change GC mode\n*/\nvoid luaC_changemode (lua_State *L, int mode) {\n  global_State *g = G(L);\n  if (mode == g->gckind) return;  /* nothing to change */\n  if (mode == KGC_GEN) {  /* change to generational mode */\n    /* make sure gray lists are consistent */\n    luaC_runtilstate(L, bitmask(GCSpropagate));\n    g->GCestimate = gettotalbytes(g);\n    g->gckind = KGC_GEN;\n  }\n  else {  /* change to incremental mode */\n    /* sweep all objects to turn them back to white\n       (as white has not changed, nothing extra will be collected) */\n    g->gckind = KGC_NORMAL;\n    entersweep(L);\n    luaC_runtilstate(L, ~sweepphases);\n  }\n}\n\n\n/*\n** call all pending finalizers\n*/\nstatic void callallpendingfinalizers (lua_State *L, int propagateerrors) {\n  global_State *g = G(L);\n  while (g->tobefnz) {\n    resetoldbit(g->tobefnz);\n    GCTM(L, propagateerrors);\n  }\n}\n\n\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  int i;\n  separatetobefnz(L, 1);  /* separate all objects with finalizers */\n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L, 0);\n  g->currentwhite = WHITEBITS; /* this \"white\" makes all objects look dead */\n  g->gckind = KGC_NORMAL;\n  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */\n  sweepwholelist(L, &g->allgc);\n  for (i = 0; i < g->strt.size; i++)  /* free all string lists */\n    sweepwholelist(L, &g->strt.hash[i]);\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic l_mem atomic (lua_State *L) {\n  global_State *g = G(L);\n  l_mem work = -cast(l_mem, g->GCmemtrav);  /* start counting work */\n  GCObject *origweak, *origall;\n  lua_assert(!iswhite(obj2gco(g->mainthread)));\n  markobject(g, L);  /* mark running thread */\n  /* registry and global metatables may be changed by API */\n  markvalue(g, &g->l_registry);\n  markmt(g);  /* mark basic metatables */\n  /* remark occasional upvalues of (maybe) dead threads */\n  remarkupvals(g);\n  propagateall(g);  /* propagate changes */\n  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */\n  /* traverse objects caught by write barrier and by 'remarkupvals' */\n  retraversegrays(g);\n  work -= g->GCmemtrav;  /* restart counting */\n  convergeephemerons(g);\n  /* at this point, all strongly accessible objects are marked. */\n  /* clear values from weak tables, before checking finalizers */\n  clearvalues(g, g->weak, NULL);\n  clearvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  work += g->GCmemtrav;  /* stop counting (objects being finalized) */\n  separatetobefnz(L, 0);  /* separate objects to be finalized */\n  markbeingfnz(g);  /* mark objects that will be finalized */\n  propagateall(g);  /* remark, to propagate `preserveness' */\n  work -= g->GCmemtrav;  /* restart counting */\n  convergeephemerons(g);\n  /* at this point, all resurrected objects are marked. */\n  /* remove dead objects from weak tables */\n  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */\n  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */\n  /* clear values from resurrected weak tables */\n  clearvalues(g, g->weak, origweak);\n  clearvalues(g, g->allweak, origall);\n  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */\n  work += g->GCmemtrav;  /* complete counting */\n  return work;  /* estimate of memory marked by 'atomic' */\n}\n\n\nstatic lu_mem singlestep (lua_State *L) {\n  global_State *g = G(L);\n  switch (g->gcstate) {\n    case GCSpause: {\n      /* start to count memory traversed */\n      g->GCmemtrav = g->strt.size * sizeof(GCObject*);\n      lua_assert(!isgenerational(g));\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      return g->GCmemtrav;\n    }\n    case GCSpropagate: {\n      if (g->gray) {\n        lu_mem oldtrav = g->GCmemtrav;\n        propagatemark(g);\n        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */\n      }\n      else {  /* no more `gray' objects */\n        lu_mem work;\n        int sw;\n        g->gcstate = GCSatomic;  /* finish mark phase */\n        g->GCestimate = g->GCmemtrav;  /* save what was counted */;\n        work = atomic(L);  /* add what was traversed by 'atomic' */\n        g->GCestimate += work;  /* estimate of total memory traversed */ \n        sw = entersweep(L);\n        return work + sw * GCSWEEPCOST;\n      }\n    }\n    case GCSsweepstring: {\n      int i;\n      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)\n        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);\n      g->sweepstrgc += i;\n      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */\n        g->gcstate = GCSsweepudata;\n      return i * GCSWEEPCOST;\n    }\n    case GCSsweepudata: {\n      if (g->sweepfin) {\n        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);\n        return GCSWEEPMAX*GCSWEEPCOST;\n      }\n      else {\n        g->gcstate = GCSsweep;\n        return 0;\n      }\n    }\n    case GCSsweep: {\n      if (g->sweepgc) {\n        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);\n        return GCSWEEPMAX*GCSWEEPCOST;\n      }\n      else {\n        /* sweep main thread */\n        GCObject *mt = obj2gco(g->mainthread);\n        sweeplist(L, &mt, 1);\n        checkSizes(L);\n        g->gcstate = GCSpause;  /* finish collection */\n        return GCSWEEPCOST;\n      }\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** advances the garbage collector until it reaches a state allowed\n** by 'statemask'\n*/\nvoid luaC_runtilstate (lua_State *L, int statesmask) {\n  global_State *g = G(L);\n  while (!testbit(statesmask, g->gcstate))\n    singlestep(L);\n}\n\n\nstatic void generationalcollection (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(g->gcstate == GCSpropagate);\n  if (g->GCestimate == 0) {  /* signal for another major collection? */\n    luaC_fullgc(L, 0);  /* perform a full regular collection */\n    g->GCestimate = gettotalbytes(g);  /* update control */\n  }\n  else {\n    lu_mem estimate = g->GCestimate;\n    luaC_runtilstate(L, bitmask(GCSpause));  /* run complete (minor) cycle */\n    g->gcstate = GCSpropagate;  /* skip restart */\n    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)\n      g->GCestimate = 0;  /* signal for a major collection */\n    else\n      g->GCestimate = estimate;  /* keep estimate from last major coll. */\n\n  }\n  setpause(g, gettotalbytes(g));\n  lua_assert(g->gcstate == GCSpropagate);\n}\n\n\nstatic void incstep (lua_State *L) {\n  global_State *g = G(L);\n  l_mem debt = g->GCdebt;\n  int stepmul = g->gcstepmul;\n  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values (and 0) */\n  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */\n  debt = (debt / STEPMULADJ) + 1;\n  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;\n  do {  /* always perform at least one single step */\n    lu_mem work = singlestep(L);  /* do some work */\n    debt -= work;\n  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g, g->GCestimate);  /* pause until next cycle */\n  else {\n    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */\n    luaE_setdebt(g, debt);\n  }\n}\n\n\n/*\n** performs a basic GC step\n*/\nvoid luaC_forcestep (lua_State *L) {\n  global_State *g = G(L);\n  int i;\n  if (isgenerational(g)) generationalcollection(L);\n  else incstep(L);\n  /* run a few finalizers (or all of them at the end of a collect cycle) */\n  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)\n    GCTM(L, 1);  /* call one finalizer */\n}\n\n\n/*\n** performs a basic GC step only if collector is running\n*/\nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  if (g->gcrunning) luaC_forcestep(L);\n  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */\n}\n\n\n\n/*\n** performs a full GC cycle; if \"isemergency\", does not call\n** finalizers (which could change stack positions)\n*/\nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  int origkind = g->gckind;\n  lua_assert(origkind != KGC_EMERGENCY);\n  if (isemergency)  /* do not run finalizers during emergency GC */\n    g->gckind = KGC_EMERGENCY;\n  else {\n    g->gckind = KGC_NORMAL;\n    callallpendingfinalizers(L, 1);\n  }\n  if (keepinvariant(g)) {  /* may there be some black objects? */\n    /* must sweep all objects to turn them back to white\n       (as white has not changed, nothing will be collected) */\n    entersweep(L);\n  }\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */\n  luaC_runtilstate(L, bitmask(GCSpause));  /* run entire collection */\n  if (origkind == KGC_GEN) {  /* generational mode? */\n    /* generational mode must be kept in propagate phase */\n    luaC_runtilstate(L, bitmask(GCSpropagate));\n  }\n  g->gckind = origkind;\n  setpause(g, gettotalbytes(g));\n  if (!isemergency)   /* do not run finalizers during emergency GC */\n    callallpendingfinalizers(L, 1);\n}\n\n/* }====================================================== */\n\n\n","/*\n** $Id: lmem.c,v 1.84.1.1 2013/04/12 18:48:47 roberto Exp $\n** Interface to Memory Manager\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stddef.h>\n\n#define lmem_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\n/*\n** About the realloc function:\n** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);\n** (`osize' is the old size, `nsize' is the new size)\n**\n** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no\n** matter 'x').\n**\n** * frealloc(ud, p, x, 0) frees the block `p'\n** (in this specific case, frealloc must return NULL);\n** particularly, frealloc(ud, NULL, 0, 0) does nothing\n** (which is equivalent to free(NULL) in ANSI C)\n**\n** frealloc returns NULL if it cannot create or reallocate the area\n** (any reallocation to an equal or smaller size cannot fail!)\n*/\n\n\n\n#define MINSIZEARRAY\t4\n\n\nvoid *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,\n                     int limit, const char *what) {\n  void *newblock;\n  int newsize;\n  if (*size >= limit/2) {  /* cannot double it? */\n    if (*size >= limit)  /* cannot grow even a little? */\n      luaG_runerror(L, \"too many %s (limit is %d)\", what, limit);\n    newsize = limit;  /* still have at least one free place */\n  }\n  else {\n    newsize = (*size)*2;\n    if (newsize < MINSIZEARRAY)\n      newsize = MINSIZEARRAY;  /* minimum size */\n  }\n  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);\n  *size = newsize;  /* update only when everything else is OK */\n  return newblock;\n}\n\n\nl_noret luaM_toobig (lua_State *L) {\n  luaG_runerror(L, \"memory allocation error: block too big\");\n}\n\n\n\n/*\n** generic allocation routine.\n*/\nvoid *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {\n  void *newblock;\n  global_State *g = G(L);\n  size_t realosize = (block) ? osize : 0;\n  lua_assert((realosize == 0) == (block == NULL));\n#if defined(HARDMEMTESTS)\n  if (nsize > realosize && g->gcrunning)\n    luaC_fullgc(L, 1);  /* force a GC whenever possible */\n#endif\n  newblock = (*g->frealloc)(g->ud, block, osize, nsize);\n  if (newblock == NULL && nsize > 0) {\n    api_check(L, nsize > realosize,\n                 \"realloc cannot fail when shrinking a block\");\n    if (g->gcrunning) {\n      luaC_fullgc(L, 1);  /* try to free some memory... */\n      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */\n    }\n    if (newblock == NULL)\n      luaD_throw(L, LUA_ERRMEM);\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt = (g->GCdebt + nsize) - realosize;\n  return newblock;\n}\n\n","/*\n** $Id: lparser.c,v 2.130.1.1 2013/04/12 18:48:47 roberto Exp $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n\n#include <string.h>\n\n#define lparser_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n/* maximum number of local variables per function (must be smaller\n   than 250, due to the bytecode format) */\n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n\n/*\n** nodes for block list (list of active blocks)\n*/\ntypedef struct BlockCnt {\n  struct BlockCnt *previous;  /* chain */\n  short firstlabel;  /* index of first label in this block */\n  short firstgoto;  /* index of first pending goto in this block */\n  lu_byte nactvar;  /* # active locals outside the block */\n  lu_byte upval;  /* true if some variable in the block is an upvalue */\n  lu_byte isloop;  /* true if `block' is a loop */\n} BlockCnt;\n\n\n\n/*\n** prototypes for recursive non-terminal functions\n*/\nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic void anchor_token (LexState *ls) {\n  /* last token from outer function must be EOS */\n  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);\n  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {\n    TString *ts = ls->t.seminfo.ts;\n    luaX_newstring(ls, getstr(ts), ts->tsv.len);\n  }\n}\n\n\n/* semantic error */\nstatic l_noret semerror (LexState *ls, const char *msg) {\n  ls->t.token = 0;  /* remove 'near to' from final message */\n  luaX_syntaxerror(ls, msg);\n}\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nstatic void checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (v > l) errorlimit(fs, l, what);\n}\n\n\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (!testnext(ls, what)) {\n    if (where == ls->linenumber)\n      error_expected(ls, what);\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (LexState *ls, expdesc *e, TString *s) {\n  init_exp(e, VK, luaK_stringK(ls->fs, s));\n}\n\n\nstatic void checkname (LexState *ls, expdesc *e) {\n  codestring(ls, e, str_checkname(ls));\n}\n\n\nstatic int registerlocalvar (LexState *ls, TString *varname) {\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->nlocvars].varname = varname;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->nlocvars++;\n}\n\n\nstatic void new_localvar (LexState *ls, TString *name) {\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  int reg = registerlocalvar(ls, name);\n  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                  MAXVARS, \"local variables\");\n  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, MAX_INT, \"local variables\");\n  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);\n}\n\n\nstatic void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {\n  new_localvar(ls, luaX_newstring(ls, name, sz));\n}\n\n#define new_localvarliteral(ls,v) \\\n\tnew_localvarliteral_(ls, \"\" v, (sizeof(v)/sizeof(char))-1)\n\n\nstatic LocVar *getlocvar (FuncState *fs, int i) {\n  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;\n  lua_assert(idx < fs->nlocvars);\n  return &fs->f->locvars[idx];\n}\n\n\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  fs->nactvar = cast_byte(fs->nactvar + nvars);\n  for (; nvars; nvars--) {\n    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;\n  }\n}\n\n\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel)\n    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;\n}\n\n\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (luaS_eqstr(up[i].name, name)) return i;\n  }\n  return -1;  /* not found */\n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;\n  f->upvalues[fs->nups].instack = (v->k == VLOCAL);\n  f->upvalues[fs->nups].idx = cast_byte(v->u.info);\n  f->upvalues[fs->nups].name = name;\n  luaC_objbarrier(fs->ls->L, f, name);\n  return fs->nups++;\n}\n\n\nstatic int searchvar (FuncState *fs, TString *n) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    if (luaS_eqstr(n, getlocvar(fs, i)->varname))\n      return i;\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n  Mark block where variable at given level was defined\n  (to emit close instructions later).\n*/\nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level) bl = bl->previous;\n  bl->upval = 1;\n}\n\n\n/*\n  Find variable with given name 'n'. If it is an upvalue, add this\n  upvalue into all intermediate functions.\n*/\nstatic int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)  /* no more levels? */\n    return VVOID;  /* default is global */\n  else {\n    int v = searchvar(fs, n);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      init_exp(var, VLOCAL, v);  /* variable is local */\n      if (!base)\n        markupval(fs, v);  /* local will be used as an upval */\n      return VLOCAL;\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */\n          return VVOID;  /* not found; is a global */\n        /* else was LOCAL or UPVAL */\n        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n      }\n      init_exp(var, VUPVAL, idx);\n      return VUPVAL;\n    }\n  }\n}\n\n\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k == VLOCAL || var->k == VUPVAL);\n    codestring(ls, &key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int extra = nvars - nexps;\n  if (hasmultret(e->k)) {\n    extra++;  /* includes call itself */\n    if (extra < 0) extra = 0;\n    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n    if (extra > 1) luaK_reserveregs(fs, extra-1);\n  }\n  else {\n    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */\n    if (extra > 0) {\n      int reg = fs->freereg;\n      luaK_reserveregs(fs, extra);\n      luaK_nil(fs, reg, extra);\n    }\n  }\n}\n\n\nstatic void enterlevel (LexState *ls) {\n  lua_State *L = ls->L;\n  ++L->nCcalls;\n  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, \"C levels\");\n}\n\n\n#define leavelevel(ls)\t((ls)->L->nCcalls--)\n\n\nstatic void closegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  FuncState *fs = ls->fs;\n  Labellist *gl = &ls->dyd->gt;\n  Labeldesc *gt = &gl->arr[g];\n  lua_assert(luaS_eqstr(gt->name, label->name));\n  if (gt->nactvar < label->nactvar) {\n    TString *vname = getlocvar(fs, gt->nactvar)->varname;\n    const char *msg = luaO_pushfstring(ls->L,\n      \"<goto %s> at line %d jumps into the scope of local \" LUA_QS,\n      getstr(gt->name), gt->line, getstr(vname));\n    semerror(ls, msg);\n  }\n  luaK_patchlist(fs, gt->pc, label->pc);\n  /* remove goto from pending list */\n  for (i = g; i < gl->n - 1; i++)\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n/*\n** try to close a goto with existing labels; this solves backward jumps\n*/\nstatic int findlabel (LexState *ls, int g) {\n  int i;\n  BlockCnt *bl = ls->fs->bl;\n  Dyndata *dyd = ls->dyd;\n  Labeldesc *gt = &dyd->gt.arr[g];\n  /* check labels in current block for a match */\n  for (i = bl->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */\n      if (gt->nactvar > lb->nactvar &&\n          (bl->upval || dyd->label.n > bl->firstlabel))\n        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);\n      closegoto(ls, g, lb);  /* close it */\n      return 1;\n    }\n  }\n  return 0;  /* label not found; cannot close goto */\n}\n\n\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].pc = pc;\n  l->n++;\n  return n;\n}\n\n\n/*\n** check whether new label 'lb' matches any pending gotos in current\n** block; solves forward jumps\n*/\nstatic void findgotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  while (i < gl->n) {\n    if (luaS_eqstr(gl->arr[i].name, lb->name))\n      closegoto(ls, i, lb);\n    else\n      i++;\n  }\n}\n\n\n/*\n** \"export\" pending gotos to outer level, to check them against\n** outer labels; if the block being exited has upvalues, and\n** the goto exits the scope of any variable (which can be the\n** upvalue), close those variables being exited.\n*/\nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i = bl->firstgoto;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block and try to close it\n     with visible labels */\n  while (i < gl->n) {\n    Labeldesc *gt = &gl->arr[i];\n    if (gt->nactvar > bl->nactvar) {\n      if (bl->upval)\n        luaK_patchclose(fs, gt->pc, bl->nactvar);\n      gt->nactvar = bl->nactvar;\n    }\n    if (!findlabel(fs->ls, i))\n      i++;  /* move to next one */\n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == fs->nactvar);\n}\n\n\n/*\n** create a label named \"break\" to resolve break statements\n*/\nstatic void breaklabel (LexState *ls) {\n  TString *n = luaS_new(ls->L, \"break\");\n  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);\n  findgotos(ls, &ls->dyd->label.arr[l]);\n}\n\n/*\n** generates an error for an undefined 'goto'; choose appropriate\n** message when label name is a reserved word (which can only be 'break')\n*/\nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg = isreserved(gt->name)\n                    ? \"<%s> at line %d not inside a loop\"\n                    : \"no visible label \" LUA_QS \" for <goto> at line %d\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  if (bl->previous && bl->upval) {\n    /* create a 'jump to here' to close upvalues */\n    int j = luaK_jump(fs);\n    luaK_patchclose(fs, j, bl->nactvar);\n    luaK_patchtohere(fs, j);\n  }\n  if (bl->isloop)\n    breaklabel(ls);  /* close pending breaks */\n  fs->bl = bl->previous;\n  removevars(fs, bl->nactvar);\n  lua_assert(bl->nactvar == fs->nactvar);\n  fs->freereg = fs->nactvar;  /* free registers */\n  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */\n  if (bl->previous)  /* inner block? */\n    movegotosout(fs, bl);  /* update pending gotos to outer block */\n  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */\n    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */\n}\n\n\n/*\n** adds a new prototype into list of prototypes\n*/\nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep) f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction must use the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n*/\nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  lua_State *L = ls->L;\n  Proto *f;\n  fs->prev = ls->fs;  /* linked list of funcstates */\n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->lasttarget = 0;\n  fs->jpc = NO_JUMP;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->nlocvars = 0;\n  fs->nactvar = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->bl = NULL;\n  f = fs->f;\n  f->source = ls->source;\n  f->maxstacksize = 2;  /* registers 0/1 are always valid */\n  fs->h = luaH_new(L);\n  /* anchor table of constants (to avoid being collected) */\n  sethvalue2s(L, L->top, fs->h);\n  incr_top(L);\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, 0, 0);  /* final return */\n  leaveblock(fs);\n  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  f->sizecode = fs->pc;\n  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);\n  f->sizelineinfo = fs->pc;\n  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);\n  f->sizek = fs->nk;\n  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);\n  f->sizep = fs->np;\n  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);\n  f->sizelocvars = fs->nlocvars;\n  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  f->sizeupvalues = fs->nups;\n  lua_assert(fs->bl == NULL);\n  ls->fs = fs->prev;\n  /* last token read was anchored in defunct function; must re-anchor it */\n  anchor_token(ls);\n  L->top--;  /* pop table of constants */\n  luaC_checkGC(L);\n}\n\n\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\n\n/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it handled in separate.\n*/\nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\nstatic void statlist (LexState *ls) {\n  /* statlist -> { stat [`;'] } */\n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;  /* 'return' must be last statement */\n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n  /* fieldsel -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n  /* index -> '[' expr ']' */\n  luaX_next(ls);  /* skip the '[' */\n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\n\nstruct ConsControl {\n  expdesc v;  /* last list item read */\n  expdesc *t;  /* table descriptor */\n  int nh;  /* total number of `record' elements */\n  int na;  /* total number of array elements */\n  int tostore;  /* number of array elements pending to be stored */\n};\n\n\nstatic void recfield (LexState *ls, struct ConsControl *cc) {\n  /* recfield -> (NAME | `['exp1`]') = exp1 */\n  FuncState *fs = ls->fs;\n  int reg = ls->fs->freereg;\n  expdesc key, val;\n  int rkkey;\n  if (ls->t.token == TK_NAME) {\n    checklimit(fs, cc->nh, MAX_INT, \"items in a constructor\");\n    checkname(ls, &key);\n  }\n  else  /* ls->t.token == '[' */\n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  rkkey = luaK_exp2RK(fs, &key);\n  expr(ls, &val);\n  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));\n  fs->freereg = reg;  /* free registers */\n}\n\n\nstatic void closelistfield (FuncState *fs, struct ConsControl *cc) {\n  if (cc->v.k == VVOID) return;  /* there is no list item */\n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore == LFIELDS_PER_FLUSH) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */\n    cc->tostore = 0;  /* no more items pending */\n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, struct ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;  /* do not count last expression (unknown number of elements) */\n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n}\n\n\nstatic void listfield (LexState *ls, struct ConsControl *cc) {\n  /* listfield -> exp */\n  expr(ls, &cc->v);\n  checklimit(ls->fs, cc->na, MAX_INT, \"items in a constructor\");\n  cc->na++;\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, struct ConsControl *cc) {\n  /* field -> listfield | recfield */\n  switch(ls->t.token) {\n    case TK_NAME: {  /* may be 'listfield' or 'recfield' */\n      if (luaX_lookahead(ls) != '=')  /* expression? */\n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n  /* constructor -> '{' [ field { sep field } [sep] ] '}'\n     sep -> ',' | ';' */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n  struct ConsControl cc;\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VRELOCABLE, pc);\n  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */\n  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */\n  checknext(ls, '{');\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */\n  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */\n}\n\n/* }====================================================================== */\n\n\n\nstatic void parlist (LexState *ls) {\n  /* parlist -> [ param { `,' param } ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  f->is_vararg = 0;\n  if (ls->t.token != ')') {  /* is `parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {  /* param -> NAME */\n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {  /* param -> `...' */\n          luaX_next(ls);\n          f->is_vararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or \" LUA_QL(\"...\") \" expected\");\n      }\n    } while (!f->is_vararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */\n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n  /* body ->  `(' parlist `)' block END */\n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n  /* explist -> expr { `,' expr } */\n  int n = 1;  /* at least one expression */\n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f, int line) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  switch (ls->t.token) {\n    case '(': {  /* funcargs -> `(' [ explist ] `)' */\n      luaX_next(ls);\n      if (ls->t.token == ')')  /* arg list is empty? */\n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {  /* funcargs -> constructor */\n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {  /* funcargs -> STRING */\n      codestring(ls, &args, ls->t.seminfo.ts);\n      luaX_next(ls);  /* must use `seminfo' before `next' */\n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;  /* base register for call */\n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;  /* open call */\n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);  /* close last argument */\n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  fs->freereg = base+1;  /* call remove function and arguments and leaves\n                            (unless changed) one result */\n}\n\n\n\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n  /* primaryexp -> NAME | '(' expr ')' */\n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n  /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {  /* fieldsel */\n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {  /* `[' exp1 `]' */\n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {  /* `:' NAME funcargs */\n        expdesc key;\n        luaX_next(ls);\n        checkname(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v, line);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {  /* funcargs */\n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v, line);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |\n                  constructor | FUNCTION body | suffixedexp */\n  switch (ls->t.token) {\n    case TK_NUMBER: {\n      init_exp(v, VKNUM, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_STRING: {\n      codestring(ls, v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {  /* vararg */\n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->is_vararg,\n                      \"cannot use \" LUA_QL(\"...\") \" outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));\n      break;\n    }\n    case '{': {  /* constructor */\n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '/': return OPR_DIV;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\nstatic const struct {\n  lu_byte left;  /* left priority for each binary operator */\n  lu_byte right; /* right priority */\n} priority[] = {  /* ORDER OPR */\n   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */\n   {10, 9}, {5, 4},                 /* ^, .. (right associative) */\n   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */\n   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */\n   {2, 2}, {1, 1}                   /* and, or */\n};\n\n#define UNARY_PRIORITY\t8  /* priority for unary operators */\n\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where `binop' is any binary operator with a priority higher than `limit'\n*/\nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {\n    int line = ls->linenumber;\n    luaX_next(ls);\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n  /* expand while operators have priorities higher than `limit' */\n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);\n    luaK_infix(ls->fs, op, v);\n    /* read sub-expression with higher priority */\n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;  /* return first untreated operator */\n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\n\nstatic void block (LexState *ls) {\n  /* block -> statlist */\n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;  /* variable (global, local, upvalue, or indexed) */\n};\n\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (lh->v.k == VINDEXED) {  /* assigning to a table? */\n      /* table is the upvalue/local being assigned now? */\n      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.vt = VLOCAL;\n        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */\n      }\n      /* index is the local being assigned? (index cannot be upvalue) */\n      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;\n    luaK_codeABC(fs, op, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\nstatic void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax error\");\n  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */\n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (nv.v.k != VINDEXED)\n      check_conflict(ls, lh, &nv.v);\n    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,\n                    \"C levels\");\n    assignment(ls, &nv, nvars+1);\n  }\n  else {  /* assignment -> `=' explist */\n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars) {\n      adjust_assign(ls, nvars, nexps, &e);\n      if (nexps > nvars)\n        ls->fs->freereg -= nexps - nvars;  /* remove extra values */\n    }\n    else {\n      luaK_setoneret(ls->fs, &e);  /* close last expression */\n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;  /* avoid default */\n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */\n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n  /* cond -> exp */\n  expdesc v;\n  expr(ls, &v);  /* read condition */\n  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */\n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls, int pc) {\n  int line = ls->linenumber;\n  TString *label;\n  int g;\n  if (testnext(ls, TK_GOTO))\n    label = str_checkname(ls);\n  else {\n    luaX_next(ls);  /* skip break */\n    label = luaS_new(ls->L, \"break\");\n  }\n  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);\n  findlabel(ls, g);  /* close it if label already defined */\n}\n\n\n/* check for repeated labels on the same block */\nstatic void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {\n  int i;\n  for (i = fs->bl->firstlabel; i < ll->n; i++) {\n    if (luaS_eqstr(label, ll->arr[i].name)) {\n      const char *msg = luaO_pushfstring(fs->ls->L,\n                          \"label \" LUA_QS \" already defined on line %d\",\n                          getstr(label), ll->arr[i].line);\n      semerror(fs->ls, msg);\n    }\n  }\n}\n\n\n/* skip no-op statements */\nstatic void skipnoopstat (LexState *ls) {\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);\n}\n\n\nstatic void labelstat (LexState *ls, TString *label, int line) {\n  /* label -> '::' NAME '::' */\n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l;  /* index of new label being created */\n  checkrepeated(fs, ll, label);  /* check for repeated labels */\n  checknext(ls, TK_DBCOLON);  /* skip double colon */\n  /* create new entry for this label */\n  l = newlabelentry(ls, ll, label, line, fs->pc);\n  skipnoopstat(ls);  /* skip other no-op statements */\n  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */\n    /* assume that locals are already out of scope */\n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  findgotos(ls, &ll->arr[l]);\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n  /* whilestat -> WHILE cond DO block END */\n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);  /* skip WHILE */\n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n  /* repeatstat -> REPEAT block UNTIL cond */\n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);  /* loop block */\n  enterblock(fs, &bl2, 0);  /* scope block */\n  luaX_next(ls);  /* skip REPEAT */\n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);  /* read condition (inside scope block) */\n  if (bl2.upval)  /* upvalues? */\n    luaK_patchclose(fs, condexit, bl2.nactvar);\n  leaveblock(fs);  /* finish scope */\n  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n  leaveblock(fs);  /* finish loop */\n}\n\n\nstatic int exp1 (LexState *ls) {\n  expdesc e;\n  int reg;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n  reg = e.u.info;\n  return reg;\n}\n\n\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isnum) {\n  /* forbody -> DO block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  adjustlocalvars(ls, 3);  /* control variables */\n  checknext(ls, TK_DO);\n  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);\n  enterblock(fs, &bl, 0);  /* scope for declared variables */\n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);  /* end of scope for declared variables */\n  luaK_patchtohere(fs, prep);\n  if (isnum)  /* numeric for? */\n    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);\n  else {  /* generic for */\n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);\n  }\n  luaK_patchlist(fs, endfor, prep + 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n  /* fornum -> NAME = exp1,exp1[,exp1] forbody */\n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for index)\");\n  new_localvarliteral(ls, \"(for limit)\");\n  new_localvarliteral(ls, \"(for step)\");\n  new_localvar(ls, varname);\n  checknext(ls, '=');\n  exp1(ls);  /* initial value */\n  checknext(ls, ',');\n  exp1(ls);  /* limit */\n  if (testnext(ls, ','))\n    exp1(ls);  /* optional step */\n  else {  /* default step = 1 */\n    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));\n    luaK_reserveregs(fs, 1);\n  }\n  forbody(ls, base, line, 1, 1);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n  /* forlist -> NAME {,NAME} IN explist forbody */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 4;  /* gen, state, control, plus at least one declared var */\n  int line;\n  int base = fs->freereg;\n  /* create control variables */\n  new_localvarliteral(ls, \"(for generator)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for control)\");\n  /* create declared variables */\n  new_localvar(ls, indexname);\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 3, explist(ls, &e), &e);\n  luaK_checkstack(fs, 3);  /* extra space to call generator */\n  forbody(ls, base, line, nvars - 3, 0);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n  /* forstat -> FOR (fornum | forlist) END */\n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);  /* scope for loop and control variables */\n  luaX_next(ls);  /* skip `for' */\n  varname = str_checkname(ls);  /* first variable name */\n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, LUA_QL(\"=\") \" or \" LUA_QL(\"in\") \" expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);  /* loop scope (`break' jumps to this point) */\n}\n\n\nstatic void test_then_block (LexState *ls, int *escapelist) {\n  /* test_then_block -> [IF | ELSEIF] cond THEN block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;  /* instruction to skip 'then' code (if condition is false) */\n  luaX_next(ls);  /* skip IF or ELSEIF */\n  expr(ls, &v);  /* read condition */\n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {\n    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */\n    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n    gotostat(ls, v.t);  /* handle goto/break */\n    skipnoopstat(ls);  /* skip other no-op statements */\n    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */\n      leaveblock(fs);\n      return;  /* and that is it */\n    }\n    else  /* must skip over 'then' part if condition is false */\n      jf = luaK_jump(fs);\n  }\n  else {  /* regular case (not goto/break) */\n    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */\n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);  /* `then' part */\n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;  /* exit list for finished parts */\n  test_then_block(ls, &escapelist);  /* IF cond THEN block */\n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */\n  if (testnext(ls, TK_ELSE))\n    block(ls);  /* `else' part */\n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  new_localvar(ls, str_checkname(ls));  /* new local variable */\n  adjustlocalvars(ls, 1);  /* enter its scope */\n  body(ls, &b, 0, ls->linenumber);  /* function created in next register */\n  /* debug information will only see the variable after this point! */\n  getlocvar(fs, b.u.info)->startpc = fs->pc;\n}\n\n\nstatic void localstat (LexState *ls) {\n  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */\n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  adjust_assign(ls, nvars, nexps, &e);\n  adjustlocalvars(ls, nvars);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n  /* funcname -> NAME {fieldsel} [`:' NAME] */\n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n  /* funcstat -> FUNCTION funcname body */\n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */\n}\n\n\nstatic void exprstat (LexState *ls) {\n  /* stat -> func | assignment */\n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */\n    v.prev = NULL;\n    assignment(ls, &v, 1);\n  }\n  else {  /* stat -> func */\n    check_condition(ls, v.v.k == VCALL, \"syntax error\");\n    SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */\n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n  /* stat -> RETURN [explist] [';'] */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int first, nret;  /* registers with returned values */\n  if (block_follow(ls, 1) || ls->t.token == ';')\n    first = nret = 0;  /* return no values */\n  else {\n    nret = explist(ls, &e);  /* optional return values */\n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1) {  /* tail call? */\n        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);\n      }\n      first = fs->nactvar;\n      nret = LUA_MULTRET;  /* return all values */\n    }\n    else {\n      if (nret == 1)  /* only one single value? */\n        first = luaK_exp2anyreg(fs, &e);\n      else {\n        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */\n        first = fs->nactvar;  /* return all `active' values */\n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  testnext(ls, ';');  /* skip optional semicolon */\n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;  /* may be needed for error messages */\n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {  /* stat -> ';' (empty statement) */\n      luaX_next(ls);  /* skip ';' */\n      break;\n    }\n    case TK_IF: {  /* stat -> ifstat */\n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {  /* stat -> whilestat */\n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {  /* stat -> DO block END */\n      luaX_next(ls);  /* skip DO */\n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {  /* stat -> forstat */\n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {  /* stat -> repeatstat */\n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {  /* stat -> funcstat */\n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {  /* stat -> localstat */\n      luaX_next(ls);  /* skip LOCAL */\n      if (testnext(ls, TK_FUNCTION))  /* local function? */\n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {  /* stat -> label */\n      luaX_next(ls);  /* skip double colon */\n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {  /* stat -> retstat */\n      luaX_next(ls);  /* skip RETURN */\n      retstat(ls);\n      break;\n    }\n    case TK_BREAK:   /* stat -> breakstat */\n    case TK_GOTO: {  /* stat -> 'goto' NAME */\n      gotostat(ls, luaK_jump(ls->fs));\n      break;\n    }\n    default: {  /* stat -> func | assignment */\n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= ls->fs->nactvar);\n  ls->fs->freereg = ls->fs->nactvar;  /* free registers */\n  leavelevel(ls);\n}\n\n/* }====================================================================== */\n\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  expdesc v;\n  open_func(ls, fs, &bl);\n  fs->f->is_vararg = 1;  /* main function is always vararg */\n  init_exp(&v, VLOCAL, 0);  /* create and... */\n  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                      Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */\n  /* anchor closure (to avoid being collected) */\n  setclLvalue(L, L->top, cl);\n  incr_top(L);\n  funcstate.f = cl->l.p = luaF_newproto(L);\n  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */\n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n  /* all scopes should be correctly finished */\n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  return cl;  /* it's on the stack too */\n}\n\n","/*\n** $Id: ltablib.c,v 1.65.1.1 2013/04/12 18:48:47 roberto Exp $\n** Library for Table Manipulation\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stddef.h>\n\n#define ltablib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n#define aux_getn(L,n)\t(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))\n\n\n\n#if defined(LUA_COMPAT_MAXN)\nstatic int maxn (lua_State *L) {\n  lua_Number max = 0;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_pushnil(L);  /* first key */\n  while (lua_next(L, 1)) {\n    lua_pop(L, 1);  /* remove value */\n    if (lua_type(L, -1) == LUA_TNUMBER) {\n      lua_Number v = lua_tonumber(L, -1);\n      if (v > max) max = v;\n    }\n  }\n  lua_pushnumber(L, max);\n  return 1;\n}\n#endif\n\n\nstatic int tinsert (lua_State *L) {\n  int e = aux_getn(L, 1) + 1;  /* first empty element */\n  int pos;  /* where to insert new element */\n  switch (lua_gettop(L)) {\n    case 2: {  /* called with only 2 arguments */\n      pos = e;  /* insert new element at the end */\n      break;\n    }\n    case 3: {\n      int i;\n      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */\n      luaL_argcheck(L, 1 <= pos && pos <= e, 2, \"position out of bounds\");\n      for (i = e; i > pos; i--) {  /* move up elements */\n        lua_rawgeti(L, 1, i-1);\n        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */\n      }\n      break;\n    }\n    default: {\n      return luaL_error(L, \"wrong number of arguments to \" LUA_QL(\"insert\"));\n    }\n  }\n  lua_rawseti(L, 1, pos);  /* t[pos] = v */\n  return 0;\n}\n\n\nstatic int tremove (lua_State *L) {\n  int size = aux_getn(L, 1);\n  int pos = luaL_optint(L, 2, size);\n  if (pos != size)  /* validate 'pos' if given */\n    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, \"position out of bounds\");\n  lua_rawgeti(L, 1, pos);  /* result = t[pos] */\n  for ( ; pos < size; pos++) {\n    lua_rawgeti(L, 1, pos+1);\n    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */\n  }\n  lua_pushnil(L);\n  lua_rawseti(L, 1, pos);  /* t[pos] = nil */\n  return 1;\n}\n\n\nstatic void addfield (lua_State *L, luaL_Buffer *b, int i) {\n  lua_rawgeti(L, 1, i);\n  if (!lua_isstring(L, -1))\n    luaL_error(L, \"invalid value (%s) at index %d in table for \"\n                  LUA_QL(\"concat\"), luaL_typename(L, -1), i);\n  luaL_addvalue(b);\n}\n\n\nstatic int tconcat (lua_State *L) {\n  luaL_Buffer b;\n  size_t lsep;\n  int i, last;\n  const char *sep = luaL_optlstring(L, 2, \"\", &lsep);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i = luaL_optint(L, 3, 1);\n  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));\n  luaL_buffinit(L, &b);\n  for (; i < last; i++) {\n    addfield(L, &b, i);\n    luaL_addlstring(&b, sep, lsep);\n  }\n  if (i == last)  /* add last value (if interval was not empty) */\n    addfield(L, &b, i);\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\n/*\n** {======================================================\n** Pack/unpack\n** =======================================================\n*/\n\nstatic int pack (lua_State *L) {\n  int n = lua_gettop(L);  /* number of elements to pack */\n  lua_createtable(L, n, 1);  /* create result table */\n  lua_pushinteger(L, n);\n  lua_setfield(L, -2, \"n\");  /* t.n = number of elements */\n  if (n > 0) {  /* at least one element? */\n    int i;\n    lua_pushvalue(L, 1);\n    lua_rawseti(L, -2, 1);  /* insert first element */\n    lua_replace(L, 1);  /* move table into index 1 */\n    for (i = n; i >= 2; i--)  /* assign other elements */\n      lua_rawseti(L, 1, i);\n  }\n  return 1;  /* return table */\n}\n\n\nstatic int unpack (lua_State *L) {\n  int i, e, n;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i = luaL_optint(L, 2, 1);\n  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));\n  if (i > e) return 0;  /* empty range */\n  n = e - i + 1;  /* number of elements */\n  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */\n    return luaL_error(L, \"too many results to unpack\");\n  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */\n  while (i++ < e)  /* push arg[i + 1...e] */\n    lua_rawgeti(L, 1, i);\n  return n;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Quicksort\n** (based on `Algorithms in MODULA-3', Robert Sedgewick;\n**  Addison-Wesley, 1993.)\n** =======================================================\n*/\n\n\nstatic void set2 (lua_State *L, int i, int j) {\n  lua_rawseti(L, 1, i);\n  lua_rawseti(L, 1, j);\n}\n\nstatic int sort_comp (lua_State *L, int a, int b) {\n  if (!lua_isnil(L, 2)) {  /* function? */\n    int res;\n    lua_pushvalue(L, 2);\n    lua_pushvalue(L, a-1);  /* -1 to compensate function */\n    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */\n    lua_call(L, 2, 1);\n    res = lua_toboolean(L, -1);\n    lua_pop(L, 1);\n    return res;\n  }\n  else  /* a < b? */\n    return lua_compare(L, a, b, LUA_OPLT);\n}\n\nstatic void auxsort (lua_State *L, int l, int u) {\n  while (l < u) {  /* for tail recursion */\n    int i, j;\n    /* sort elements a[l], a[(l+u)/2] and a[u] */\n    lua_rawgeti(L, 1, l);\n    lua_rawgeti(L, 1, u);\n    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */\n      set2(L, l, u);  /* swap a[l] - a[u] */\n    else\n      lua_pop(L, 2);\n    if (u-l == 1) break;  /* only 2 elements */\n    i = (l+u)/2;\n    lua_rawgeti(L, 1, i);\n    lua_rawgeti(L, 1, l);\n    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */\n      set2(L, i, l);\n    else {\n      lua_pop(L, 1);  /* remove a[l] */\n      lua_rawgeti(L, 1, u);\n      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */\n        set2(L, i, u);\n      else\n        lua_pop(L, 2);\n    }\n    if (u-l == 2) break;  /* only 3 elements */\n    lua_rawgeti(L, 1, i);  /* Pivot */\n    lua_pushvalue(L, -1);\n    lua_rawgeti(L, 1, u-1);\n    set2(L, i, u-1);\n    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */\n    i = l; j = u-1;\n    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */\n      /* repeat ++i until a[i] >= P */\n      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {\n        if (i>=u) luaL_error(L, \"invalid order function for sorting\");\n        lua_pop(L, 1);  /* remove a[i] */\n      }\n      /* repeat --j until a[j] <= P */\n      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {\n        if (j<=l) luaL_error(L, \"invalid order function for sorting\");\n        lua_pop(L, 1);  /* remove a[j] */\n      }\n      if (j<i) {\n        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */\n        break;\n      }\n      set2(L, i, j);\n    }\n    lua_rawgeti(L, 1, u-1);\n    lua_rawgeti(L, 1, i);\n    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */\n    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */\n    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */\n    if (i-l < u-i) {\n      j=l; i=i-1; l=i+2;\n    }\n    else {\n      j=i+1; i=u; u=j-2;\n    }\n    auxsort(L, j, i);  /* call recursively the smaller one */\n  }  /* repeat the routine for the larger one */\n}\n\nstatic int sort (lua_State *L) {\n  int n = aux_getn(L, 1);\n  luaL_checkstack(L, 40, \"\");  /* assume array is smaller than 2^40 */\n  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */\n    luaL_checktype(L, 2, LUA_TFUNCTION);\n  lua_settop(L, 2);  /* make sure there is two arguments */\n  auxsort(L, 1, n);\n  return 0;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg tab_funcs[] = {\n  {\"concat\", tconcat},\n#if defined(LUA_COMPAT_MAXN)\n  {\"maxn\", maxn},\n#endif\n  {\"insert\", tinsert},\n  {\"pack\", pack},\n  {\"unpack\", unpack},\n  {\"remove\", tremove},\n  {\"sort\", sort},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_table (lua_State *L) {\n  luaL_newlib(L, tab_funcs);\n#if defined(LUA_COMPAT_UNPACK)\n  /* _G.unpack = table.unpack */\n  lua_getfield(L, -1, \"unpack\");\n  lua_setglobal(L, \"unpack\");\n#endif\n  return 1;\n}\n\n","/*\n** $Id: lvm.c,v 2.155.1.1 2013/04/12 18:48:47 roberto Exp $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define lvm_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n/* limit for table tag-method chains (to avoid loops) */\n#define MAXTAGLOOP\t100\n\n\nconst TValue *luaV_tonumber (const TValue *obj, TValue *n) {\n  lua_Number num;\n  if (ttisnumber(obj)) return obj;\n  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {\n    setnvalue(n, num);\n    return n;\n  }\n  else\n    return NULL;\n}\n\n\nint luaV_tostring (lua_State *L, StkId obj) {\n  if (!ttisnumber(obj))\n    return 0;\n  else {\n    char s[LUAI_MAXNUMBER2STR];\n    lua_Number n = nvalue(obj);\n    int l = lua_number2str(s, n);\n    setsvalue2s(L, obj, luaS_newlstr(L, s, l));\n    return 1;\n  }\n}\n\n\nstatic void traceexec (lua_State *L) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    Proto *p = ci_func(ci)->p;\n    int npc = pcRel(ci->u.l.savedpc, p);\n    int newline = getfuncline(p, npc);\n    if (npc == 0 ||  /* call linehook when enter a new function, */\n        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */\n        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */\n      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */\n  }\n  L->oldpc = ci->u.l.savedpc;\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    ci->func = L->top - 1;  /* protect stack below results */\n    luaD_throw(L, LUA_YIELD);\n  }\n}\n\n\nstatic void callTM (lua_State *L, const TValue *f, const TValue *p1,\n                    const TValue *p2, TValue *p3, int hasres) {\n  ptrdiff_t result = savestack(L, p3);\n  setobj2s(L, L->top++, f);  /* push function */\n  setobj2s(L, L->top++, p1);  /* 1st argument */\n  setobj2s(L, L->top++, p2);  /* 2nd argument */\n  if (!hasres)  /* no result? 'p3' is third argument */\n    setobj2s(L, L->top++, p3);  /* 3rd argument */\n  /* metamethod may yield only when called from Lua code */\n  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));\n  if (hasres) {  /* if has result, move it to its place */\n    p3 = restorestack(L, result);\n    setobjs2s(L, p3, --L->top);\n  }\n}\n\n\nvoid luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n  int loop;\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;\n    if (ttistable(t)) {  /* `t' is a table? */\n      Table *h = hvalue(t);\n      const TValue *res = luaH_get(h, key); /* do a primitive get */\n      if (!ttisnil(res) ||  /* result is not nil? */\n          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */\n        setobj2s(L, val, res);\n        return;\n      }\n      /* else will try the tag method */\n    }\n    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))\n      luaG_typeerror(L, t, \"index\");\n    if (ttisfunction(tm)) {\n      callTM(L, tm, t, key, val, 1);\n      return;\n    }\n    t = tm;  /* else repeat with 'tm' */\n  }\n  luaG_runerror(L, \"loop in gettable\");\n}\n\n\nvoid luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n  int loop;\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;\n    if (ttistable(t)) {  /* `t' is a table? */\n      Table *h = hvalue(t);\n      TValue *oldval = cast(TValue *, luaH_get(h, key));\n      /* if previous value is not nil, there must be a previous entry\n         in the table; moreover, a metamethod has no relevance */\n      if (!ttisnil(oldval) ||\n         /* previous value is nil; must check the metamethod */\n         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&\n         /* no metamethod; is there a previous entry in the table? */\n         (oldval != luaO_nilobject ||\n         /* no previous entry; must create one. (The next test is\n            always true; we only need the assignment.) */\n         (oldval = luaH_newkey(L, h, key), 1)))) {\n        /* no metamethod and (now) there is an entry with given key */\n        setobj2t(L, oldval, val);  /* assign new value to that entry */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else  /* not a table; check metamethod */\n      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))\n        luaG_typeerror(L, t, \"index\");\n    /* there is a metamethod */\n    if (ttisfunction(tm)) {\n      callTM(L, tm, t, key, val, 0);\n      return;\n    }\n    t = tm;  /* else repeat with 'tm' */\n  }\n  luaG_runerror(L, \"loop in settable\");\n}\n\n\nstatic int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,\n                       StkId res, TMS event) {\n  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */\n  if (ttisnil(tm))\n    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */\n  if (ttisnil(tm)) return 0;\n  callTM(L, tm, p1, p2, res, 1);\n  return 1;\n}\n\n\nstatic const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,\n                                  TMS event) {\n  const TValue *tm1 = fasttm(L, mt1, event);\n  const TValue *tm2;\n  if (tm1 == NULL) return NULL;  /* no metamethod */\n  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */\n  tm2 = fasttm(L, mt2, event);\n  if (tm2 == NULL) return NULL;  /* no metamethod */\n  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */\n    return tm1;\n  return NULL;\n}\n\n\nstatic int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,\n                         TMS event) {\n  if (!call_binTM(L, p1, p2, L->top, event))\n    return -1;  /* no metamethod */\n  else\n    return !l_isfalse(L->top);\n}\n\n\nstatic int l_strcmp (const TString *ls, const TString *rs) {\n  const char *l = getstr(ls);\n  size_t ll = ls->tsv.len;\n  const char *r = getstr(rs);\n  size_t lr = rs->tsv.len;\n  for (;;) {\n    int temp = strcoll(l, r);\n    if (temp != 0) return temp;\n    else {  /* strings are equal up to a `\\0' */\n      size_t len = strlen(l);  /* index of first `\\0' in both strings */\n      if (len == lr)  /* r is finished? */\n        return (len == ll) ? 0 : 1;\n      else if (len == ll)  /* l is finished? */\n        return -1;  /* l is smaller than r (because r is not finished) */\n      /* both strings longer than `len'; go on comparing (after the `\\0') */\n      len++;\n      l += len; ll -= len; r += len; lr -= len;\n    }\n  }\n}\n\n\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  int res;\n  if (ttisnumber(l) && ttisnumber(r))\n    return luai_numlt(L, nvalue(l), nvalue(r));\n  else if (ttisstring(l) && ttisstring(r))\n    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;\n  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)\n    luaG_ordererror(L, l, r);\n  return res;\n}\n\n\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  int res;\n  if (ttisnumber(l) && ttisnumber(r))\n    return luai_numle(L, nvalue(l), nvalue(r));\n  else if (ttisstring(l) && ttisstring(r))\n    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;\n  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */\n    return res;\n  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */\n    luaG_ordererror(L, l, r);\n  return !res;\n}\n\n\n/*\n** equality of Lua values. L == NULL means raw equality (no metamethods)\n*/\nint luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  lua_assert(ttisequal(t1, t2));\n  switch (ttype(t1)) {\n    case LUA_TNIL: return 1;\n    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));\n    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */\n    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_TLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_TTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      lua_assert(iscollectable(t1));\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL) return 0;  /* no TM? */\n  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */\n  return !l_isfalse(L->top);\n}\n\n\nvoid luaV_concat (lua_State *L, int total) {\n  lua_assert(total >= 2);\n  do {\n    StkId top = L->top;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {\n      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))\n        luaG_concaterror(L, top-2, top-1);\n    }\n    else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */\n      (void)tostring(L, top - 2);  /* result is first operand */\n    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = tsvalue(top-1)->len;\n      char *buffer;\n      int i;\n      /* collect total length */\n      for (i = 1; i < total && tostring(L, top-i-1); i++) {\n        size_t l = tsvalue(top-i-1)->len;\n        if (l >= (MAX_SIZET/sizeof(char)) - tl)\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      buffer = luaZ_openspace(L, &G(L)->buff, tl);\n      tl = 0;\n      n = i;\n      do {  /* concat all strings */\n        size_t l = tsvalue(top-i)->len;\n        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));\n        tl += l;\n      } while (--i > 0);\n      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));\n    }\n    total -= n-1;  /* got 'n' strings to create 1 new */\n    L->top -= n-1;  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n\n\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypenv(rb)) {\n    case LUA_TTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;  /* metamethod? break switch to call it */\n      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */\n      return;\n    }\n    case LUA_TSTRING: {\n      setnvalue(ra, cast_num(tsvalue(rb)->len));\n      return;\n    }\n    default: {  /* try metamethod */\n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (ttisnil(tm))  /* no metamethod? */\n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  callTM(L, tm, rb, rb, ra, 1);\n}\n\n\nvoid luaV_arith (lua_State *L, StkId ra, const TValue *rb,\n                 const TValue *rc, TMS op) {\n  TValue tempb, tempc;\n  const TValue *b, *c;\n  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&\n      (c = luaV_tonumber(rc, &tempc)) != NULL) {\n    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));\n    setnvalue(ra, res);\n  }\n  else if (!call_binTM(L, rb, rc, ra, op))\n    luaG_aritherror(L, rb, rc);\n}\n\n\n/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\nstatic Closure *getcached (Proto *p, UpVal **encup, StkId base) {\n  Closure *c = p->cache;\n  if (c != NULL) {  /* is there a cached closure? */\n    int nup = p->sizeupvalues;\n    Upvaldesc *uv = p->upvalues;\n    int i;\n    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;\n      if (c->l.upvals[i]->v != v)\n        return NULL;  /* wrong upvalue; cannot reuse closure */\n    }\n  }\n  return c;  /* return cached closure (or NULL if no cached closure) */\n}\n\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues. Note that the call to 'luaC_barrierproto' must come\n** before the assignment to 'p->cache', as the function needs the\n** original value of that field.\n*/\nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  Closure *ncl = luaF_newLclosure(L, nup);\n  ncl->l.p = p;\n  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->l.upvals[i] = encup[uv[i].idx];\n  }\n  luaC_barrierproto(L, p, ncl);\n  p->cache = ncl;  /* save it on cache for reuse */\n}\n\n\n/*\n** finish execution of an opcode interrupted by an yield\n*/\nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->u.l.base;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:\n    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LE: case OP_LT: case OP_EQ: {\n      int res = !l_isfalse(L->top - 1);\n      L->top--;\n      /* metamethod should not be called when operand is K */\n      lua_assert(!ISK(GETARG_B(inst)));\n      if (op == OP_LE &&  /* \"<=\" using \"<\" instead? */\n          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n        res = !res;  /* invert result */\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_A(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;  /* top when 'call_binTM' was called */\n      int b = GETARG_B(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */\n      setobj2s(L, top - 2, top);  /* put TM result in proper position */\n      if (total > 1) {  /* are there elements to concat? */\n        L->top = top - 1;  /* top is one after last element (at top-2) */\n        luaV_concat(L, total);  /* concat them (may yield again) */\n      }\n      /* move final result to final position */\n      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);\n      L->top = ci->top;  /* restore top */\n      break;\n    }\n    case OP_TFORCALL: {\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);\n      L->top = ci->top;  /* correct top */\n      break;\n    }\n    case OP_CALL: {\n      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */\n        L->top = ci->top;  /* adjust results */\n      break;\n    }\n    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n\n/*\n** some macros for common tasks in `luaV_execute'\n*/\n\n#if !defined luai_runtimecheck\n#define luai_runtimecheck(L, c)\t\t/* void */\n#endif\n\n\n#define RA(i)\t(base+GETARG_A(i))\n/* to be used after possible stack reallocation */\n#define RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))\n#define RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))\n#define RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\\n\tISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))\n#define RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\\n\tISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))\n#define KBx(i)  \\\n  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))\n\n\n/* execute a jump instruction */\n#define dojump(ci,i,e) \\\n  { int a = GETARG_A(i); \\\n    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \\\n    ci->u.l.savedpc += GETARG_sBx(i) + e; }\n\n/* for test instructions, execute the jump instruction that follows it */\n#define donextjump(ci)\t{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }\n\n\n#define Protect(x)\t{ {x;}; base = ci->u.l.base; }\n\n#define checkGC(L,c)  \\\n  Protect( luaC_condGC(L,{L->top = (c);  /* limit of live values */ \\\n                          luaC_step(L); \\\n                          L->top = ci->top;})  /* restore top */ \\\n           luai_threadyield(L); )\n\n\n#define arith_op(op,tm) { \\\n        TValue *rb = RKB(i); \\\n        TValue *rc = RKC(i); \\\n        if (ttisnumber(rb) && ttisnumber(rc)) { \\\n          lua_Number nb = nvalue(rb), nc = nvalue(rc); \\\n          setnvalue(ra, op(L, nb, nc)); \\\n        } \\\n        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }\n\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l,b)\tcase l: {b}  break;\n#define vmcasenb(l,b)\tcase l: {b}\t\t/* nb = no break */\n\nvoid luaV_execute (lua_State *L) {\n  CallInfo *ci = L->ci;\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n newframe:  /* reentry point when frame changes (call/return) */\n  lua_assert(ci == L->ci);\n  cl = clLvalue(ci->func);\n  k = cl->p->k;\n  base = ci->u.l.base;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i = *(ci->u.l.savedpc++);\n    StkId ra;\n    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&\n        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {\n      Protect(traceexec(L));\n    }\n    /* WARNING: several calls may realloc the stack and invalidate `ra' */\n    ra = RA(i);\n    lua_assert(base == ci->u.l.base);\n    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE,\n        setobjs2s(L, ra, RB(i));\n      )\n      vmcase(OP_LOADK,\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n      )\n      vmcase(OP_LOADKX,\n        TValue *rb;\n        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);\n        rb = k + GETARG_Ax(*ci->u.l.savedpc++);\n        setobj2s(L, ra, rb);\n      )\n      vmcase(OP_LOADBOOL,\n        setbvalue(ra, GETARG_B(i));\n        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */\n      )\n      vmcase(OP_LOADNIL,\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(ra++);\n        } while (b--);\n      )\n      vmcase(OP_GETUPVAL,\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n      )\n      vmcase(OP_GETTABUP,\n        int b = GETARG_B(i);\n        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));\n      )\n      vmcase(OP_GETTABLE,\n        Protect(luaV_gettable(L, RB(i), RKC(i), ra));\n      )\n      vmcase(OP_SETTABUP,\n        int a = GETARG_A(i);\n        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));\n      )\n      vmcase(OP_SETUPVAL,\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, ra);\n        luaC_barrier(L, uv, ra);\n      )\n      vmcase(OP_SETTABLE,\n        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));\n      )\n      vmcase(OP_NEWTABLE,\n        int b = GETARG_B(i);\n        int c = GETARG_C(i);\n        Table *t = luaH_new(L);\n        sethvalue(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));\n        checkGC(L, ra + 1);\n      )\n      vmcase(OP_SELF,\n        StkId rb = RB(i);\n        setobjs2s(L, ra+1, rb);\n        Protect(luaV_gettable(L, rb, RKC(i), ra));\n      )\n      vmcase(OP_ADD,\n        arith_op(luai_numadd, TM_ADD);\n      )\n      vmcase(OP_SUB,\n        arith_op(luai_numsub, TM_SUB);\n      )\n      vmcase(OP_MUL,\n        arith_op(luai_nummul, TM_MUL);\n      )\n      vmcase(OP_DIV,\n        arith_op(luai_numdiv, TM_DIV);\n      )\n      vmcase(OP_MOD,\n        arith_op(luai_nummod, TM_MOD);\n      )\n      vmcase(OP_POW,\n        arith_op(luai_numpow, TM_POW);\n      )\n      vmcase(OP_UNM,\n        TValue *rb = RB(i);\n        if (ttisnumber(rb)) {\n          lua_Number nb = nvalue(rb);\n          setnvalue(ra, luai_numunm(L, nb));\n        }\n        else {\n          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));\n        }\n      )\n      vmcase(OP_NOT,\n        TValue *rb = RB(i);\n        int res = l_isfalse(rb);  /* next assignment may change this value */\n        setbvalue(ra, res);\n      )\n      vmcase(OP_LEN,\n        Protect(luaV_objlen(L, ra, RB(i)));\n      )\n      vmcase(OP_CONCAT,\n        int b = GETARG_B(i);\n        int c = GETARG_C(i);\n        StkId rb;\n        L->top = base + c + 1;  /* mark the end of concat operands */\n        Protect(luaV_concat(L, c - b + 1));\n        ra = RA(i);  /* 'luav_concat' may invoke TMs and move the stack */\n        rb = b + base;\n        setobjs2s(L, ra, rb);\n        checkGC(L, (ra >= rb ? ra + 1 : rb));\n        L->top = ci->top;  /* restore top */\n      )\n      vmcase(OP_JMP,\n        dojump(ci, i, 0);\n      )\n      vmcase(OP_EQ,\n        TValue *rb = RKB(i);\n        TValue *rc = RKC(i);\n        Protect(\n          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_LT,\n        Protect(\n          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_LE,\n        Protect(\n          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_TEST,\n        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))\n            ci->u.l.savedpc++;\n          else\n          donextjump(ci);\n      )\n      vmcase(OP_TESTSET,\n        TValue *rb = RB(i);\n        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))\n          ci->u.l.savedpc++;\n        else {\n          setobjs2s(L, ra, rb);\n          donextjump(ci);\n        }\n      )\n      vmcase(OP_CALL,\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0) L->top = ra+b;  /* else previous instruction set top */\n        if (luaD_precall(L, ra, nresults)) {  /* C function? */\n          if (nresults >= 0) L->top = ci->top;  /* adjust results */\n          base = ci->u.l.base;\n        }\n        else {  /* Lua function */\n          ci = L->ci;\n          ci->callstatus |= CIST_REENTRY;\n          goto newframe;  /* restart luaV_execute over new Lua function */\n        }\n      )\n      vmcase(OP_TAILCALL,\n        int b = GETARG_B(i);\n        if (b != 0) L->top = ra+b;  /* else previous instruction set top */\n        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);\n        if (luaD_precall(L, ra, LUA_MULTRET))  /* C function? */\n          base = ci->u.l.base;\n        else {\n          /* tail call: put called frame (n) in place of caller one (o) */\n          CallInfo *nci = L->ci;  /* called frame */\n          CallInfo *oci = nci->previous;  /* caller frame */\n          StkId nfunc = nci->func;  /* called function */\n          StkId ofunc = oci->func;  /* caller function */\n          /* last stack slot filled by 'precall' */\n          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;\n          int aux;\n          /* close all upvalues from previous call */\n          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);\n          /* move new frame into old one */\n          for (aux = 0; nfunc + aux < lim; aux++)\n            setobjs2s(L, ofunc + aux, nfunc + aux);\n          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */\n          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */\n          oci->u.l.savedpc = nci->u.l.savedpc;\n          oci->callstatus |= CIST_TAIL;  /* function was tail called */\n          ci = L->ci = oci;  /* remove new frame */\n          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);\n          goto newframe;  /* restart luaV_execute over new Lua function */\n        }\n      )\n      vmcasenb(OP_RETURN,\n        int b = GETARG_B(i);\n        if (b != 0) L->top = ra+b-1;\n        if (cl->p->sizep > 0) luaF_close(L, base);\n        b = luaD_poscall(L, ra);\n        if (!(ci->callstatus & CIST_REENTRY))  /* 'ci' still the called one */\n          return;  /* external invocation: return */\n        else {  /* invocation via reentry: continue execution */\n          ci = L->ci;\n          if (b) L->top = ci->top;\n          lua_assert(isLua(ci));\n          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);\n          goto newframe;  /* restart luaV_execute over new Lua function */\n        }\n      )\n      vmcase(OP_FORLOOP,\n        lua_Number step = nvalue(ra+2);\n        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */\n        lua_Number limit = nvalue(ra+1);\n        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)\n                                   : luai_numle(L, limit, idx)) {\n          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */\n          setnvalue(ra, idx);  /* update internal index... */\n          setnvalue(ra+3, idx);  /* ...and external index */\n        }\n      )\n      vmcase(OP_FORPREP,\n        const TValue *init = ra;\n        const TValue *plimit = ra+1;\n        const TValue *pstep = ra+2;\n        if (!tonumber(init, ra))\n          luaG_runerror(L, LUA_QL(\"for\") \" initial value must be a number\");\n        else if (!tonumber(plimit, ra+1))\n          luaG_runerror(L, LUA_QL(\"for\") \" limit must be a number\");\n        else if (!tonumber(pstep, ra+2))\n          luaG_runerror(L, LUA_QL(\"for\") \" step must be a number\");\n        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));\n        ci->u.l.savedpc += GETARG_sBx(i);\n      )\n      vmcasenb(OP_TFORCALL,\n        StkId cb = ra + 3;  /* call base */\n        setobjs2s(L, cb+2, ra+2);\n        setobjs2s(L, cb+1, ra+1);\n        setobjs2s(L, cb, ra);\n        L->top = cb + 3;  /* func. + 2 args (state and index) */\n        Protect(luaD_call(L, cb, GETARG_C(i), 1));\n        L->top = ci->top;\n        i = *(ci->u.l.savedpc++);  /* go to next instruction */\n        ra = RA(i);\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);\n        goto l_tforloop;\n      )\n      vmcase(OP_TFORLOOP,\n        l_tforloop:\n        if (!ttisnil(ra + 1)) {  /* continue loop? */\n          setobjs2s(L, ra, ra + 1);  /* save control variable */\n           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */\n        }\n      )\n      vmcase(OP_SETLIST,\n        int n = GETARG_B(i);\n        int c = GETARG_C(i);\n        int last;\n        Table *h;\n        if (n == 0) n = cast_int(L->top - ra) - 1;\n        if (c == 0) {\n          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);\n          c = GETARG_Ax(*ci->u.l.savedpc++);\n        }\n        luai_runtimecheck(L, ttistable(ra));\n        h = hvalue(ra);\n        last = ((c-1)*LFIELDS_PER_FLUSH) + n;\n        if (last > h->sizearray)  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* pre-allocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = ra+n;\n          luaH_setint(L, h, last--, val);\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        L->top = ci->top;  /* correct top (in case of previous open call) */\n      )\n      vmcase(OP_CLOSURE,\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */\n        if (ncl == NULL)  /* no match? */\n          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */\n        else\n          setclLvalue(L, ra, ncl);  /* push cashed closure */\n        checkGC(L, ra + 1);\n      )\n      vmcase(OP_VARARG,\n        int b = GETARG_B(i) - 1;\n        int j;\n        int n = cast_int(base - ci->func) - cl->p->numparams - 1;\n        if (b < 0) {  /* B == 0? */\n          b = n;  /* get all var. arguments */\n          Protect(luaD_checkstack(L, n));\n          ra = RA(i);  /* previous call may change the stack */\n          L->top = ra + n;\n        }\n        for (j = 0; j < b; j++) {\n          if (j < n) {\n            setobjs2s(L, ra + j, base - n + j);\n          }\n          else {\n            setnilvalue(ra + j);\n          }\n        }\n      )\n      vmcase(OP_EXTRAARG,\n        lua_assert(0);\n      )\n    }\n  }\n}\n\n","/*\n** $Id: ldebug.c,v 2.90.1.3 2013/05/16 16:04:15 roberto Exp $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_TCCL)\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\nstatic int currentline (CallInfo *ci) {\n  return getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** this function can be called asynchronous (e.g. during a signal)\n*/\nLUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  return 1;\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  int nparams = clLvalue(ci->func)->p->numparams;\n  if (n >= ci->u.l.base - ci->func - nparams)\n    return NULL;  /* no such vararg */\n  else {\n    *pos = ci->func + nparams + n;\n    return \"(*vararg)\";  /* generic name for any vararg */\n  }\n}\n\n\nstatic const char *findlocal (lua_State *L, CallInfo *ci, int n,\n                              StkId *pos) {\n  const char *name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  }\n  else\n    base = ci->func + 1;\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\";  /* generic name for any valid slot */\n    else\n      return NULL;  /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(L->top - 1))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = 0;  /* to avoid warnings */\n    name = findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobj2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = 0;  /* to avoid warnings */\n  const char *name = findlocal(L, ar->i_ci, n, &pos);\n  lua_lock(L);\n  if (name)\n    setobjs2s(L, pos, L->top - 1);\n  L->top--;  /* pop value */\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    Proto *p = cl->l.p;\n    ar->source = p->source ? getstr(p->source) : \"=?\";\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(L->top);\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    int *lineinfo = f->l.p->lineinfo;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue(L, L->top, t);  /* push it on stack */\n    api_incr_top(L);\n    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */\n    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */\n      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */\n  }\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        /* calling function is a known Lua function? */\n        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))\n          ar->namewhat = getfuncname(L, ci->previous, &ar->name);\n        else\n          ar->namewhat = NULL;\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  StkId func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = L->top - 1;\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = ci->func;\n    lua_assert(ttisfunction(ci->func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobjs2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\nstatic const char *getobjname (Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n/*\n** find a \"name\" for the RK value 'c'\n*/\nstatic void kname (Proto *p, int pc, int c, const char **name) {\n  if (ISK(c)) {  /* is 'c' a constant? */\n    TValue *kvalue = &p->k[INDEXK(c)];\n    if (ttisstring(kvalue)) {  /* literal constant? */\n      *name = svalue(kvalue);  /* it is its own name */\n      return;\n    }\n    /* else no reasonable name found */\n  }\n  else {  /* 'c' is a register */\n    const char *what = getobjname(p, pc, c, name); /* search for 'c' */\n    if (what && *what == 'c') {  /* found a constant name? */\n      return;  /* 'name' already filled */\n    }\n    /* else no reasonable name found */\n  }\n  *name = \"?\";  /* no reasonable name found */\n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** try to find last instruction before 'lastpc' that modified register 'reg'\n*/\nstatic int findsetreg (Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    switch (op) {\n      case OP_LOADNIL: {\n        int b = GETARG_B(i);\n        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */\n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_TFORCALL: {\n        if (reg >= a + 2)  /* affect all regs above its base */\n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {\n        if (reg >= a)  /* affect all registers above base */\n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_JMP: {\n        int b = GETARG_sBx(i);\n        int dest = pc + 1 + b;\n        /* jump is forward and do not skip `lastpc'? */\n        if (pc < dest && dest <= lastpc) {\n          if (dest > jmptarget)\n            jmptarget = dest;  /* update 'jmptarget' */\n        }\n        break;\n      }\n      case OP_TEST: {\n        if (reg == a)  /* jumped code can change 'a' */\n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      default:\n        if (testAMode(op) && reg == a)  /* any instruction that set A */\n          setreg = filterpc(pc, jmptarget);\n        break;\n    }\n  }\n  return setreg;\n}\n\n\nstatic const char *getobjname (Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETTABUP:\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        int t = GETARG_B(i);  /* table index */\n        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */\n                         ? luaF_getlocalname(p, t + 1, pc)\n                         : upvalname(p, t);\n        kname(p, pc, k, name);\n        return (vn && strcmp(vn, LUA_ENV) == 0) ? \"global\" : \"field\";\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, pc, k, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  TMS tm;\n  Proto *p = ci_func(ci)->p;  /* calling function */\n  int pc = currentpc(ci);  /* calling instruction index */\n  Instruction i = p->code[pc];  /* calling instruction */\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:  /* get function name */\n      return getobjname(p, pc, GETARG_A(i), name);\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* all other instructions can call only through metamethods */\n    case OP_SELF:\n    case OP_GETTABUP:\n    case OP_GETTABLE: tm = TM_INDEX; break;\n    case OP_SETTABUP:\n    case OP_SETTABLE: tm = TM_NEWINDEX; break;\n    case OP_EQ: tm = TM_EQ; break;\n    case OP_ADD: tm = TM_ADD; break;\n    case OP_SUB: tm = TM_SUB; break;\n    case OP_MUL: tm = TM_MUL; break;\n    case OP_DIV: tm = TM_DIV; break;\n    case OP_MOD: tm = TM_MOD; break;\n    case OP_POW: tm = TM_POW; break;\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_LT: tm = TM_LT; break;\n    case OP_LE: tm = TM_LE; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    default:\n      return NULL;  /* else no useful name can be found */\n  }\n  *name = getstr(G(L)->tmname[tm]);\n  return \"metamethod\";\n}\n\n/* }====================================================== */\n\n\n\n/*\n** only ANSI way to check whether a pointer points to an array\n** (used only for error messages, so efficiency is not a big concern)\n*/\nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId p;\n  for (p = ci->u.l.base; p < ci->top; p++)\n    if (o == p) return 1;\n  return 0;\n}\n\n\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;\n  const char *t = objtypename(o);\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind && isinstack(ci, o))  /* no? try a register */\n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(o - ci->u.l.base), &name);\n  }\n  if (kind)\n    luaG_runerror(L, \"attempt to %s %s \" LUA_QS \" (a %s value)\",\n                op, kind, name, t);\n  else\n    luaG_runerror(L, \"attempt to %s a %s value\", op, t);\n}\n\n\nl_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {\n  TValue temp;\n  if (luaV_tonumber(p1, &temp) == NULL)\n    p2 = p1;  /* first operand is wrong */\n  luaG_typeerror(L, p2, \"perform arithmetic on\");\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = objtypename(p1);\n  const char *t2 = objtypename(p2);\n  if (t1 == t2)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\nstatic void addinfo (lua_State *L, const char *msg) {\n  CallInfo *ci = L->ci;\n  if (isLua(ci)) {  /* is Lua code? */\n    char buff[LUA_IDSIZE];  /* add file:line information */\n    int line = currentline(ci);\n    TString *src = ci_func(ci)->p->source;\n    if (src)\n      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);\n    else {  /* no source available; use \"?\" instead */\n      buff[0] = '?'; buff[1] = '\\0';\n    }\n    luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n  }\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);\n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;\n    luaD_call(L, L->top - 2, 1, 0);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  va_list argp;\n  va_start(argp, fmt);\n  addinfo(L, luaO_pushvfstring(L, fmt, argp));\n  va_end(argp);\n  luaG_errormsg(L);\n}\n\n","/*\n** $Id: lstate.c,v 2.99.1.2 2013/11/08 17:45:31 roberto Exp $\n** Global State\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stddef.h>\n#include <string.h>\n\n#define lstate_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n#if !defined(LUAI_GCPAUSE)\n#define LUAI_GCPAUSE\t200  /* 200% */\n#endif\n\n#if !defined(LUAI_GCMAJOR)\n#define LUAI_GCMAJOR\t200  /* 200% */\n#endif\n\n#if !defined(LUAI_GCMUL)\n#define LUAI_GCMUL\t200 /* GC runs 'twice the speed' of memory allocation */\n#endif\n\n\n#define MEMERRMSG\t\"not enough memory\"\n\n\n/*\n** a macro to help the creation of a unique random seed when a state is\n** created; the seed is used to randomize hashes.\n*/\n#if !defined(luai_makeseed)\n#include <time.h>\n#define luai_makeseed()\t\tcast(unsigned int, time(NULL))\n#endif\n\n\n\n/*\n** thread state + extra space\n*/\ntypedef struct LX {\n#if defined(LUAI_EXTRASPACE)\n  char buff[LUAI_EXTRASPACE];\n#endif\n  lua_State l;\n} LX;\n\n\n/*\n** Main thread combines a thread state and the global state\n*/\ntypedef struct LG {\n  LX l;\n  global_State g;\n} LG;\n\n\n\n#define fromstate(L)\t(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))\n\n\n/*\n** Compute an initial seed as random as possible. In ANSI, rely on\n** Address Space Layout Randomization (if present) to increase\n** randomness..\n*/\n#define addbuff(b,p,e) \\\n  { size_t t = cast(size_t, e); \\\n    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }\n\nstatic unsigned int makeseed (lua_State *L) {\n  char buff[4 * sizeof(size_t)];\n  unsigned int h = luai_makeseed();\n  int p = 0;\n  addbuff(buff, p, L);  /* heap variable */\n  addbuff(buff, p, &h);  /* local variable */\n  addbuff(buff, p, luaO_nilobject);  /* global variable */\n  addbuff(buff, p, &lua_newstate);  /* public function */\n  lua_assert(p == sizeof(buff));\n  return luaS_hash(buff, p, h);\n}\n\n\n/*\n** set GCdebt to a new value keeping the value (totalbytes + GCdebt)\n** invariant\n*/\nvoid luaE_setdebt (global_State *g, l_mem debt) {\n  g->totalbytes -= (debt - g->GCdebt);\n  g->GCdebt = debt;\n}\n\n\nCallInfo *luaE_extendCI (lua_State *L) {\n  CallInfo *ci = luaM_new(L, CallInfo);\n  lua_assert(L->ci->next == NULL);\n  L->ci->next = ci;\n  ci->previous = L->ci;\n  ci->next = NULL;\n  return ci;\n}\n\n\nvoid luaE_freeCI (lua_State *L) {\n  CallInfo *ci = L->ci;\n  CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    luaM_free(L, ci);\n  }\n}\n\n\nstatic void stack_init (lua_State *L1, lua_State *L) {\n  int i; CallInfo *ci;\n  /* initialize stack array */\n  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);\n  L1->stacksize = BASIC_STACK_SIZE;\n  for (i = 0; i < BASIC_STACK_SIZE; i++)\n    setnilvalue(L1->stack + i);  /* erase new stack */\n  L1->top = L1->stack;\n  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;\n  /* initialize first ci */\n  ci = &L1->base_ci;\n  ci->next = ci->previous = NULL;\n  ci->callstatus = 0;\n  ci->func = L1->top;\n  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */\n  ci->top = L1->top + LUA_MINSTACK;\n  L1->ci = ci;\n}\n\n\nstatic void freestack (lua_State *L) {\n  if (L->stack == NULL)\n    return;  /* stack not completely built yet */\n  L->ci = &L->base_ci;  /* free the entire 'ci' list */\n  luaE_freeCI(L);\n  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */\n}\n\n\n/*\n** Create registry table and its predefined values\n*/\nstatic void init_registry (lua_State *L, global_State *g) {\n  TValue mt;\n  /* create registry */\n  Table *registry = luaH_new(L);\n  sethvalue(L, &g->l_registry, registry);\n  luaH_resize(L, registry, LUA_RIDX_LAST, 0);\n  /* registry[LUA_RIDX_MAINTHREAD] = L */\n  setthvalue(L, &mt, L);\n  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);\n  /* registry[LUA_RIDX_GLOBALS] = table of globals */\n  sethvalue(L, &mt, luaH_new(L));\n  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);\n}\n\n\n/*\n** open parts of the state that may cause memory-allocation errors\n*/\nstatic void f_luaopen (lua_State *L, void *ud) {\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);  /* init stack */\n  init_registry(L, g);\n  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */\n  luaT_init(L);\n  luaX_init(L);\n  /* pre-create memory-error message */\n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaS_fix(g->memerrmsg);  /* it should never be collected */\n  g->gcrunning = 1;  /* allow gc */\n  g->version = lua_version(NULL);\n  luai_userstateopen(L);\n}\n\n\n/*\n** preinitialize a state with consistent values without allocating\n** any memory (to avoid errors)\n*/\nstatic void preinit_state (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->stacksize = 0;\n  L->errorJmp = NULL;\n  L->nCcalls = 0;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->nny = 1;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n}\n\n\nstatic void close_state (lua_State *L) {\n  global_State *g = G(L);\n  luaF_close(L, L->stack);  /* close all upvalues for this thread */\n  luaC_freeallobjects(L);  /* collect all objects */\n  if (g->version)  /* closing a fully built state? */\n    luai_userstateclose(L);\n  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);\n  luaZ_freebuffer(L, &g->buff);\n  freestack(L);\n  lua_assert(gettotalbytes(g) == sizeof(LG));\n  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */\n}\n\n\nLUA_API lua_State *lua_newthread (lua_State *L) {\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;\n  setthvalue(L, L->top, L1);\n  api_incr_top(L);\n  preinit_state(L1, G(L));\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  resethookcount(L1);\n  luai_userstatethread(L, L1);\n  stack_init(L1, L);  /* init stack */\n  lua_unlock(L);\n  return L1;\n}\n\n\nvoid luaE_freethread (lua_State *L, lua_State *L1) {\n  LX *l = fromstate(L1);\n  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */\n  lua_assert(L1->openupval == NULL);\n  luai_userstatefree(L, L1);\n  freestack(L1);\n  luaM_free(L, l);\n}\n\n\nLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {\n  int i;\n  lua_State *L;\n  global_State *g;\n  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->next = NULL;\n  L->tt = LUA_TTHREAD;\n  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);\n  L->marked = luaC_white(g);\n  g->gckind = KGC_NORMAL;\n  preinit_state(L, g);\n  g->frealloc = f;\n  g->ud = ud;\n  g->mainthread = L;\n  g->seed = makeseed(L);\n  g->uvhead.u.l.prev = &g->uvhead;\n  g->uvhead.u.l.next = &g->uvhead;\n  g->gcrunning = 0;  /* no GC while building state */\n  g->GCestimate = 0;\n  g->strt.size = 0;\n  g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  setnilvalue(&g->l_registry);\n  luaZ_initbuffer(L, &g->buff);\n  g->panic = NULL;\n  g->version = NULL;\n  g->gcstate = GCSpause;\n  g->allgc = NULL;\n  g->finobj = NULL;\n  g->tobefnz = NULL;\n  g->sweepgc = g->sweepfin = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->totalbytes = sizeof(LG);\n  g->GCdebt = 0;\n  g->gcpause = LUAI_GCPAUSE;\n  g->gcmajorinc = LUAI_GCMAJOR;\n  g->gcstepmul = LUAI_GCMUL;\n  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;\n  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {\n    /* memory allocation error: free partial state */\n    close_state(L);\n    L = NULL;\n  }\n  return L;\n}\n\n\nLUA_API void lua_close (lua_State *L) {\n  L = G(L)->mainthread;  /* only the main thread can be closed */\n  lua_lock(L);\n  close_state(L);\n}\n\n\n","/*\n** $Id: ltm.c,v 2.14.1.1 2013/04/12 18:48:47 roberto Exp $\n** Tag methods\n** See Copyright Notice in lua.h\n*/\n\n\n#include <string.h>\n\n#define ltm_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\nstatic const char udatatypename[] = \"userdata\";\n\nLUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {\n  \"no value\",\n  \"nil\", \"boolean\", udatatypename, \"number\",\n  \"string\", \"table\", \"function\", udatatypename, \"thread\",\n  \"proto\", \"upval\"  /* these last two cases are used for tests only */\n};\n\n\nvoid luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  /* ORDER TM */\n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__div\", \"__mod\",\n    \"__pow\", \"__unm\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaS_fix(G(L)->tmname[i]);  /* never collect these names */\n  }\n}\n\n\n/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\nconst TValue *luaT_gettm (Table *events, TMS event, TString *ename) {\n  const TValue *tm = luaH_getstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (ttisnil(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}\n\n\nconst TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {\n  Table *mt;\n  switch (ttypenv(o)) {\n    case LUA_TTABLE:\n      mt = hvalue(o)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(o)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttypenv(o)];\n  }\n  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);\n}\n\n","/*\n** $Id: lzio.c,v 1.35.1.1 2013/04/12 18:48:47 roberto Exp $\n** Buffered streams\n** See Copyright Notice in lua.h\n*/\n\n\n#include <string.h>\n\n#define lzio_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"llimits.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\nint luaZ_fill (ZIO *z) {\n  size_t size;\n  lua_State *L = z->L;\n  const char *buff;\n  lua_unlock(L);\n  buff = z->reader(L, z->data, &size);\n  lua_lock(L);\n  if (buff == NULL || size == 0)\n    return EOZ;\n  z->n = size - 1;  /* discount char being returned */\n  z->p = buff;\n  return cast_uchar(*(z->p++));\n}\n\n\nvoid luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {\n  z->L = L;\n  z->reader = reader;\n  z->data = data;\n  z->n = 0;\n  z->p = NULL;\n}\n\n\n/* --------------------------------------------------------------- read --- */\nsize_t luaZ_read (ZIO *z, void *b, size_t n) {\n  while (n) {\n    size_t m;\n    if (z->n == 0) {  /* no bytes in buffer? */\n      if (luaZ_fill(z) == EOZ)  /* try to read more */\n        return n;  /* no more input; return number of missing bytes */\n      else {\n        z->n++;  /* luaZ_fill consumed first byte; put it back */\n        z->p--;\n      }\n    }\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}\n\n/* ------------------------------------------------------------------------ */\nchar *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {\n  if (n > buff->buffsize) {\n    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;\n    luaZ_resizebuffer(L, buff, n);\n  }\n  return buff->buffer;\n}\n\n\n","/*\n** $Id: lcode.c,v 2.62.1.1 2013/04/12 18:48:47 roberto Exp $\n** Code generator for Lua\n** See Copyright Notice in lua.h\n*/\n\n\n#include <stdlib.h>\n\n#define lcode_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n#define hasjumps(e)\t((e)->t != (e)->f)\n\n\nstatic int isnumeral(expdesc *e) {\n  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);\n}\n\n\nvoid luaK_nil (FuncState *fs, int from, int n) {\n  Instruction *previous;\n  int l = from + n - 1;  /* last register to set nil */\n  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */\n    previous = &fs->f->code[fs->pc-1];\n    if (GET_OPCODE(*previous) == OP_LOADNIL) {\n      int pfrom = GETARG_A(*previous);\n      int pl = pfrom + GETARG_B(*previous);\n      if ((pfrom <= from && from <= pl + 1) ||\n          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */\n        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */\n        if (pl > l) l = pl;  /* l = max(l, pl) */\n        SETARG_A(*previous, from);\n        SETARG_B(*previous, l - from);\n        return;\n      }\n    }  /* else go through */\n  }\n  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */\n}\n\n\nint luaK_jump (FuncState *fs) {\n  int jpc = fs->jpc;  /* save list of jumps to here */\n  int j;\n  fs->jpc = NO_JUMP;\n  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);\n  luaK_concat(fs, &j, jpc);  /* keep them on hold */\n  return j;\n}\n\n\nvoid luaK_ret (FuncState *fs, int first, int nret) {\n  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);\n}\n\n\nstatic int condjump (FuncState *fs, OpCode op, int A, int B, int C) {\n  luaK_codeABC(fs, op, A, B, C);\n  return luaK_jump(fs);\n}\n\n\nstatic void fixjump (FuncState *fs, int pc, int dest) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest-(pc+1);\n  lua_assert(dest != NO_JUMP);\n  if (abs(offset) > MAXARG_sBx)\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_sBx(*jmp, offset);\n}\n\n\n/*\n** returns current `pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\nint luaK_getlabel (FuncState *fs) {\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}\n\n\nstatic int getjump (FuncState *fs, int pc) {\n  int offset = GETARG_sBx(fs->f->code[pc]);\n  if (offset == NO_JUMP)  /* point to itself represents end of list */\n    return NO_JUMP;  /* end of list */\n  else\n    return (pc+1)+offset;  /* turn offset into absolute position */\n}\n\n\nstatic Instruction *getjumpcontrol (FuncState *fs, int pc) {\n  Instruction *pi = &fs->f->code[pc];\n  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))\n    return pi-1;\n  else\n    return pi;\n}\n\n\n/*\n** check whether list has any jump that do not produce a value\n** (or produce an inverted value)\n*/\nstatic int need_value (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}\n\n\nstatic int patchtestreg (FuncState *fs, int node, int reg) {\n  Instruction *i = getjumpcontrol(fs, node);\n  if (GET_OPCODE(*i) != OP_TESTSET)\n    return 0;  /* cannot patch other instructions */\n  if (reg != NO_REG && reg != GETARG_B(*i))\n    SETARG_A(*i, reg);\n  else  /* no register to put value or register already has the value */\n    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));\n\n  return 1;\n}\n\n\nstatic void removevalues (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list))\n      patchtestreg(fs, list, NO_REG);\n}\n\n\nstatic void patchlistaux (FuncState *fs, int list, int vtarget, int reg,\n                          int dtarget) {\n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    if (patchtestreg(fs, list, reg))\n      fixjump(fs, list, vtarget);\n    else\n      fixjump(fs, list, dtarget);  /* jump to default target */\n    list = next;\n  }\n}\n\n\nstatic void dischargejpc (FuncState *fs) {\n  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);\n  fs->jpc = NO_JUMP;\n}\n\n\nvoid luaK_patchlist (FuncState *fs, int list, int target) {\n  if (target == fs->pc)\n    luaK_patchtohere(fs, list);\n  else {\n    lua_assert(target < fs->pc);\n    patchlistaux(fs, list, target, NO_REG, target);\n  }\n}\n\n\nLUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {\n  level++;  /* argument is +1 to reserve 0 as non-op */\n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&\n                (GETARG_A(fs->f->code[list]) == 0 ||\n                 GETARG_A(fs->f->code[list]) >= level));\n    SETARG_A(fs->f->code[list], level);\n    list = next;\n  }\n}\n\n\nvoid luaK_patchtohere (FuncState *fs, int list) {\n  luaK_getlabel(fs);\n  luaK_concat(fs, &fs->jpc, list);\n}\n\n\nvoid luaK_concat (FuncState *fs, int *l1, int l2) {\n  if (l2 == NO_JUMP) return;\n  else if (*l1 == NO_JUMP)\n    *l1 = l2;\n  else {\n    int list = *l1;\n    int next;\n    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */\n      list = next;\n    fixjump(fs, list, l2);\n  }\n}\n\n\nstatic int luaK_code (FuncState *fs, Instruction i) {\n  Proto *f = fs->f;\n  dischargejpc(fs);  /* `pc' will change */\n  /* put new instruction in code array */\n  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,\n                  MAX_INT, \"opcodes\");\n  f->code[fs->pc] = i;\n  /* save corresponding line information */\n  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,\n                  MAX_INT, \"opcodes\");\n  f->lineinfo[fs->pc] = fs->ls->lastline;\n  return fs->pc++;\n}\n\n\nint luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {\n  lua_assert(getOpMode(o) == iABC);\n  lua_assert(getBMode(o) != OpArgN || b == 0);\n  lua_assert(getCMode(o) != OpArgN || c == 0);\n  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);\n  return luaK_code(fs, CREATE_ABC(o, a, b, c));\n}\n\n\nint luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {\n  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);\n  lua_assert(getCMode(o) == OpArgN);\n  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, a, bc));\n}\n\n\nstatic int codeextraarg (FuncState *fs, int a) {\n  lua_assert(a <= MAXARG_Ax);\n  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));\n}\n\n\nint luaK_codek (FuncState *fs, int reg, int k) {\n  if (k <= MAXARG_Bx)\n    return luaK_codeABx(fs, OP_LOADK, reg, k);\n  else {\n    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);\n    codeextraarg(fs, k);\n    return p;\n  }\n}\n\n\nvoid luaK_checkstack (FuncState *fs, int n) {\n  int newstack = fs->freereg + n;\n  if (newstack > fs->f->maxstacksize) {\n    if (newstack >= MAXSTACK)\n      luaX_syntaxerror(fs->ls, \"function or expression too complex\");\n    fs->f->maxstacksize = cast_byte(newstack);\n  }\n}\n\n\nvoid luaK_reserveregs (FuncState *fs, int n) {\n  luaK_checkstack(fs, n);\n  fs->freereg += n;\n}\n\n\nstatic void freereg (FuncState *fs, int reg) {\n  if (!ISK(reg) && reg >= fs->nactvar) {\n    fs->freereg--;\n    lua_assert(reg == fs->freereg);\n  }\n}\n\n\nstatic void freeexp (FuncState *fs, expdesc *e) {\n  if (e->k == VNONRELOC)\n    freereg(fs, e->u.info);\n}\n\n\nstatic int addk (FuncState *fs, TValue *key, TValue *v) {\n  lua_State *L = fs->ls->L;\n  TValue *idx = luaH_set(L, fs->h, key);\n  Proto *f = fs->f;\n  int k, oldsize;\n  if (ttisnumber(idx)) {\n    lua_Number n = nvalue(idx);\n    lua_number2int(k, n);\n    if (luaV_rawequalobj(&f->k[k], v))\n      return k;\n    /* else may be a collision (e.g., between 0.0 and \"\\0\\0\\0\\0\\0\\0\\0\\0\");\n       go through and create a new entry for this value */\n  }\n  /* constant not found; create a new entry */\n  oldsize = f->sizek;\n  k = fs->nk;\n  /* numerical value does not need GC barrier;\n     table has no metatable, so it does not need to invalidate cache */\n  setnvalue(idx, cast_num(k));\n  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, \"constants\");\n  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);\n  setobj(L, &f->k[k], v);\n  fs->nk++;\n  luaC_barrier(L, f, v);\n  return k;\n}\n\n\nint luaK_stringK (FuncState *fs, TString *s) {\n  TValue o;\n  setsvalue(fs->ls->L, &o, s);\n  return addk(fs, &o, &o);\n}\n\n\nint luaK_numberK (FuncState *fs, lua_Number r) {\n  int n;\n  lua_State *L = fs->ls->L;\n  TValue o;\n  setnvalue(&o, r);\n  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */\n    /* use raw representation as key to avoid numeric problems */\n    setsvalue(L, L->top++, luaS_newlstr(L, (char *)&r, sizeof(r)));\n    n = addk(fs, L->top - 1, &o);\n    L->top--;\n  }\n  else\n    n = addk(fs, &o, &o);  /* regular case */\n  return n;\n}\n\n\nstatic int boolK (FuncState *fs, int b) {\n  TValue o;\n  setbvalue(&o, b);\n  return addk(fs, &o, &o);\n}\n\n\nstatic int nilK (FuncState *fs) {\n  TValue k, v;\n  setnilvalue(&v);\n  /* cannot use nil as key; instead use table itself to represent nil */\n  sethvalue(fs->ls->L, &k, fs->h);\n  return addk(fs, &k, &v);\n}\n\n\nvoid luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {\n  if (e->k == VCALL) {  /* expression is an open function call? */\n    SETARG_C(getcode(fs, e), nresults+1);\n  }\n  else if (e->k == VVARARG) {\n    SETARG_B(getcode(fs, e), nresults+1);\n    SETARG_A(getcode(fs, e), fs->freereg);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\nvoid luaK_setoneret (FuncState *fs, expdesc *e) {\n  if (e->k == VCALL) {  /* expression is an open function call? */\n    e->k = VNONRELOC;\n    e->u.info = GETARG_A(getcode(fs, e));\n  }\n  else if (e->k == VVARARG) {\n    SETARG_B(getcode(fs, e), 2);\n    e->k = VRELOCABLE;  /* can relocate its simple result */\n  }\n}\n\n\nvoid luaK_dischargevars (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VLOCAL: {\n      e->k = VNONRELOC;\n      break;\n    }\n    case VUPVAL: {\n      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);\n      e->k = VRELOCABLE;\n      break;\n    }\n    case VINDEXED: {\n      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */\n      freereg(fs, e->u.ind.idx);\n      if (e->u.ind.vt == VLOCAL) {  /* 't' is in a register? */\n        freereg(fs, e->u.ind.t);\n        op = OP_GETTABLE;\n      }\n      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOCABLE;\n      break;\n    }\n    case VVARARG:\n    case VCALL: {\n      luaK_setoneret(fs, e);\n      break;\n    }\n    default: break;  /* there is one value available (somewhere) */\n  }\n}\n\n\nstatic int code_label (FuncState *fs, int A, int b, int jump) {\n  luaK_getlabel(fs);  /* those instructions may be jump targets */\n  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);\n}\n\n\nstatic void discharge2reg (FuncState *fs, expdesc *e, int reg) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: {\n      luaK_nil(fs, reg, 1);\n      break;\n    }\n    case VFALSE: case VTRUE: {\n      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);\n      break;\n    }\n    case VK: {\n      luaK_codek(fs, reg, e->u.info);\n      break;\n    }\n    case VKNUM: {\n      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));\n      break;\n    }\n    case VRELOCABLE: {\n      Instruction *pc = &getcode(fs, e);\n      SETARG_A(*pc, reg);\n      break;\n    }\n    case VNONRELOC: {\n      if (reg != e->u.info)\n        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);\n      break;\n    }\n    default: {\n      lua_assert(e->k == VVOID || e->k == VJMP);\n      return;  /* nothing to do... */\n    }\n  }\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\nstatic void discharge2anyreg (FuncState *fs, expdesc *e) {\n  if (e->k != VNONRELOC) {\n    luaK_reserveregs(fs, 1);\n    discharge2reg(fs, e, fs->freereg-1);\n  }\n}\n\n\nstatic void exp2reg (FuncState *fs, expdesc *e, int reg) {\n  discharge2reg(fs, e, reg);\n  if (e->k == VJMP)\n    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */\n  if (hasjumps(e)) {\n    int final;  /* position after whole expression */\n    int p_f = NO_JUMP;  /* position of an eventual LOAD false */\n    int p_t = NO_JUMP;  /* position of an eventual LOAD true */\n    if (need_value(fs, e->t) || need_value(fs, e->f)) {\n      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);\n      p_f = code_label(fs, reg, 0, 1);\n      p_t = code_label(fs, reg, 1, 0);\n      luaK_patchtohere(fs, fj);\n    }\n    final = luaK_getlabel(fs);\n    patchlistaux(fs, e->f, final, reg, p_f);\n    patchlistaux(fs, e->t, final, reg, p_t);\n  }\n  e->f = e->t = NO_JUMP;\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\nvoid luaK_exp2nextreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  freeexp(fs, e);\n  luaK_reserveregs(fs, 1);\n  exp2reg(fs, e, fs->freereg - 1);\n}\n\n\nint luaK_exp2anyreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  if (e->k == VNONRELOC) {\n    if (!hasjumps(e)) return e->u.info;  /* exp is already in a register */\n    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */\n      exp2reg(fs, e, e->u.info);  /* put value on it */\n      return e->u.info;\n    }\n  }\n  luaK_exp2nextreg(fs, e);  /* default */\n  return e->u.info;\n}\n\n\nvoid luaK_exp2anyregup (FuncState *fs, expdesc *e) {\n  if (e->k != VUPVAL || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n}\n\n\nvoid luaK_exp2val (FuncState *fs, expdesc *e) {\n  if (hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n  else\n    luaK_dischargevars(fs, e);\n}\n\n\nint luaK_exp2RK (FuncState *fs, expdesc *e) {\n  luaK_exp2val(fs, e);\n  switch (e->k) {\n    case VTRUE:\n    case VFALSE:\n    case VNIL: {\n      if (fs->nk <= MAXINDEXRK) {  /* constant fits in RK operand? */\n        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));\n        e->k = VK;\n        return RKASK(e->u.info);\n      }\n      else break;\n    }\n    case VKNUM: {\n      e->u.info = luaK_numberK(fs, e->u.nval);\n      e->k = VK;\n      /* go through */\n    }\n    case VK: {\n      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */\n        return RKASK(e->u.info);\n      else break;\n    }\n    default: break;\n  }\n  /* not a constant in the right range: put it in a register */\n  return luaK_exp2anyreg(fs, e);\n}\n\n\nvoid luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {\n  switch (var->k) {\n    case VLOCAL: {\n      freeexp(fs, ex);\n      exp2reg(fs, ex, var->u.info);\n      return;\n    }\n    case VUPVAL: {\n      int e = luaK_exp2anyreg(fs, ex);\n      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);\n      break;\n    }\n    case VINDEXED: {\n      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;\n      int e = luaK_exp2RK(fs, ex);\n      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);\n      break;\n    }\n    default: {\n      lua_assert(0);  /* invalid var kind to store */\n      break;\n    }\n  }\n  freeexp(fs, ex);\n}\n\n\nvoid luaK_self (FuncState *fs, expdesc *e, expdesc *key) {\n  int ereg;\n  luaK_exp2anyreg(fs, e);\n  ereg = e->u.info;  /* register where 'e' was placed */\n  freeexp(fs, e);\n  e->u.info = fs->freereg;  /* base register for op_self */\n  e->k = VNONRELOC;\n  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */\n  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));\n  freeexp(fs, key);\n}\n\n\nstatic void invertjump (FuncState *fs, expdesc *e) {\n  Instruction *pc = getjumpcontrol(fs, e->u.info);\n  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&\n                                           GET_OPCODE(*pc) != OP_TEST);\n  SETARG_A(*pc, !(GETARG_A(*pc)));\n}\n\n\nstatic int jumponcond (FuncState *fs, expdesc *e, int cond) {\n  if (e->k == VRELOCABLE) {\n    Instruction ie = getcode(fs, e);\n    if (GET_OPCODE(ie) == OP_NOT) {\n      fs->pc--;  /* remove previous OP_NOT */\n      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);\n    }\n    /* else go through */\n  }\n  discharge2anyreg(fs, e);\n  freeexp(fs, e);\n  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);\n}\n\n\nvoid luaK_goiftrue (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of last jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      invertjump(fs, e);\n      pc = e->u.info;\n      break;\n    }\n    case VK: case VKNUM: case VTRUE: {\n      pc = NO_JUMP;  /* always true; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 0);\n      break;\n    }\n  }\n  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */\n  luaK_patchtohere(fs, e->t);\n  e->t = NO_JUMP;\n}\n\n\nvoid luaK_goiffalse (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of last jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      pc = e->u.info;\n      break;\n    }\n    case VNIL: case VFALSE: {\n      pc = NO_JUMP;  /* always false; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 1);\n      break;\n    }\n  }\n  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */\n  luaK_patchtohere(fs, e->f);\n  e->f = NO_JUMP;\n}\n\n\nstatic void codenot (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: case VFALSE: {\n      e->k = VTRUE;\n      break;\n    }\n    case VK: case VKNUM: case VTRUE: {\n      e->k = VFALSE;\n      break;\n    }\n    case VJMP: {\n      invertjump(fs, e);\n      break;\n    }\n    case VRELOCABLE:\n    case VNONRELOC: {\n      discharge2anyreg(fs, e);\n      freeexp(fs, e);\n      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);\n      e->k = VRELOCABLE;\n      break;\n    }\n    default: {\n      lua_assert(0);  /* cannot happen */\n      break;\n    }\n  }\n  /* interchange true and false lists */\n  { int temp = e->f; e->f = e->t; e->t = temp; }\n  removevalues(fs, e->f);\n  removevalues(fs, e->t);\n}\n\n\nvoid luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {\n  lua_assert(!hasjumps(t));\n  t->u.ind.t = t->u.info;\n  t->u.ind.idx = luaK_exp2RK(fs, k);\n  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL\n                                 : check_exp(vkisinreg(t->k), VLOCAL);\n  t->k = VINDEXED;\n}\n\n\nstatic int constfolding (OpCode op, expdesc *e1, expdesc *e2) {\n  lua_Number r;\n  if (!isnumeral(e1) || !isnumeral(e2)) return 0;\n  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)\n    return 0;  /* do not attempt to divide by 0 */\n  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);\n  e1->u.nval = r;\n  return 1;\n}\n\n\nstatic void codearith (FuncState *fs, OpCode op,\n                       expdesc *e1, expdesc *e2, int line) {\n  if (constfolding(op, e1, e2))\n    return;\n  else {\n    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;\n    int o1 = luaK_exp2RK(fs, e1);\n    if (o1 > o2) {\n      freeexp(fs, e1);\n      freeexp(fs, e2);\n    }\n    else {\n      freeexp(fs, e2);\n      freeexp(fs, e1);\n    }\n    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);\n    e1->k = VRELOCABLE;\n    luaK_fixline(fs, line);\n  }\n}\n\n\nstatic void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,\n                                                          expdesc *e2) {\n  int o1 = luaK_exp2RK(fs, e1);\n  int o2 = luaK_exp2RK(fs, e2);\n  freeexp(fs, e2);\n  freeexp(fs, e1);\n  if (cond == 0 && op != OP_EQ) {\n    int temp;  /* exchange args to replace by `<' or `<=' */\n    temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */\n    cond = 1;\n  }\n  e1->u.info = condjump(fs, op, cond, o1, o2);\n  e1->k = VJMP;\n}\n\n\nvoid luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {\n  expdesc e2;\n  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;\n  switch (op) {\n    case OPR_MINUS: {\n      if (isnumeral(e))  /* minus constant? */\n        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */\n      else {\n        luaK_exp2anyreg(fs, e);\n        codearith(fs, OP_UNM, e, &e2, line);\n      }\n      break;\n    }\n    case OPR_NOT: codenot(fs, e); break;\n    case OPR_LEN: {\n      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */\n      codearith(fs, OP_LEN, e, &e2, line);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\nvoid luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {\n  switch (op) {\n    case OPR_AND: {\n      luaK_goiftrue(fs, v);\n      break;\n    }\n    case OPR_OR: {\n      luaK_goiffalse(fs, v);\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */\n      break;\n    }\n    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n    case OPR_MOD: case OPR_POW: {\n      if (!isnumeral(v)) luaK_exp2RK(fs, v);\n      break;\n    }\n    default: {\n      luaK_exp2RK(fs, v);\n      break;\n    }\n  }\n}\n\n\nvoid luaK_posfix (FuncState *fs, BinOpr op,\n                  expdesc *e1, expdesc *e2, int line) {\n  switch (op) {\n    case OPR_AND: {\n      lua_assert(e1->t == NO_JUMP);  /* list must be closed */\n      luaK_dischargevars(fs, e2);\n      luaK_concat(fs, &e2->f, e1->f);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_OR: {\n      lua_assert(e1->f == NO_JUMP);  /* list must be closed */\n      luaK_dischargevars(fs, e2);\n      luaK_concat(fs, &e2->t, e1->t);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2val(fs, e2);\n      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {\n        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);\n        freeexp(fs, e1);\n        SETARG_B(getcode(fs, e2), e1->u.info);\n        e1->k = VRELOCABLE; e1->u.info = e2->u.info;\n      }\n      else {\n        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */\n        codearith(fs, OP_CONCAT, e1, e2, line);\n      }\n      break;\n    }\n    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n    case OPR_MOD: case OPR_POW: {\n      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);\n      break;\n    }\n    case OPR_EQ: case OPR_LT: case OPR_LE: {\n      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);\n      break;\n    }\n    case OPR_NE: case OPR_GT: case OPR_GE: {\n      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\nvoid luaK_fixline (FuncState *fs, int line) {\n  fs->f->lineinfo[fs->pc - 1] = line;\n}\n\n\nvoid luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {\n  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;\n  int b = (tostore == LUA_MULTRET) ? 0 : tostore;\n  lua_assert(tostore != 0);\n  if (c <= MAXARG_C)\n    luaK_codeABC(fs, OP_SETLIST, base, b, c);\n  else if (c <= MAXARG_Ax) {\n    luaK_codeABC(fs, OP_SETLIST, base, b, 0);\n    codeextraarg(fs, c);\n  }\n  else\n    luaX_syntaxerror(fs->ls, \"constructor too long\");\n  fs->freereg = base + 1;  /* free registers with list values */\n}\n\n","/*\n** $Id: ldo.c,v 2.108.1.3 2013/11/08 18:22:50 roberto Exp $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy variable */\n\n#elif defined(LUA_USE_ULONGJMP)\n/* in Unix, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\n/* default handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\n\n#endif\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nstatic void seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    default: {\n      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    L->status = cast_byte(errcode);  /* mark it as dead */\n    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (G(L)->panic) {  /* panic function? */\n        lua_unlock(L);\n        G(L)->panic(L);  /* call it (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  unsigned short oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\nstatic void correctstack (lua_State *L, TValue *oldstack) {\n  CallInfo *ci;\n  GCObject *up;\n  L->top = (L->top - oldstack) + L->stack;\n  for (up = L->openupval; up != NULL; up = up->gch.next)\n    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + L->stack;\n    ci->func = (ci->func - oldstack) + L->stack;\n    if (isLua(ci))\n      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;\n  }\n}\n\n\n/* some space for error handling */\n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\nvoid luaD_reallocstack (lua_State *L, int newsize) {\n  TValue *oldstack = L->stack;\n  int lim = L->stacksize;\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);\n  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);\n  for (; lim < newsize; lim++)\n    setnilvalue(L->stack + lim); /* erase new segment */\n  L->stacksize = newsize;\n  L->stack_last = L->stack + newsize - EXTRA_STACK;\n  correctstack(L, oldstack);\n}\n\n\nvoid luaD_growstack (lua_State *L, int n) {\n  int size = L->stacksize;\n  if (size > LUAI_MAXSTACK)  /* error after extra size? */\n    luaD_throw(L, LUA_ERRERR);\n  else {\n    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;\n    int newsize = 2 * size;\n    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;\n    if (newsize < needed) newsize = needed;\n    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */\n      luaD_reallocstack(L, ERRORSTACKSIZE);\n      luaG_runerror(L, \"stack overflow\");\n    }\n    else\n      luaD_reallocstack(L, newsize);\n  }\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    lua_assert(ci->top <= L->stack_last);\n    if (lim < ci->top) lim = ci->top;\n  }\n  return cast_int(lim - L->stack) + 1;  /* part of stack in use */\n}\n\n\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;\n  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */\n      goodsize >= L->stacksize)  /* would grow instead of shrink? */\n    condmovestack(L);  /* don't change stack (change only for debugging) */\n  else\n    luaD_reallocstack(L, goodsize);  /* shrink it */\n}\n\n\nvoid luaD_hook (lua_State *L, int event, int line) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);\n    ptrdiff_t ci_top = savestack(L, ci->top);\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    ci->top = L->top + LUA_MINSTACK;\n    lua_assert(ci->top <= L->stack_last);\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= CIST_HOOKED;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~CIST_HOOKED;\n  }\n}\n\n\nstatic void callhook (lua_State *L, CallInfo *ci) {\n  int hook = LUA_HOOKCALL;\n  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n  if (isLua(ci->previous) &&\n      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {\n    ci->callstatus |= CIST_TAIL;\n    hook = LUA_HOOKTAILCALL;\n  }\n  luaD_hook(L, hook, -1);\n  ci->u.l.savedpc--;  /* correct 'pc' */\n}\n\n\nstatic StkId adjust_varargs (lua_State *L, Proto *p, int actual) {\n  int i;\n  int nfixargs = p->numparams;\n  StkId base, fixed;\n  lua_assert(actual >= nfixargs);\n  /* move fixed parameters to final position */\n  luaD_checkstack(L, p->maxstacksize);  /* check again for new 'base' */\n  fixed = L->top - actual;  /* first fixed argument */\n  base = L->top;  /* final position of first argument */\n  for (i=0; i<nfixargs; i++) {\n    setobjs2s(L, L->top++, fixed + i);\n    setnilvalue(fixed + i);\n  }\n  return base;\n}\n\n\nstatic StkId tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);\n  StkId p;\n  ptrdiff_t funcr = savestack(L, func);\n  if (!ttisfunction(tm))\n    luaG_typeerror(L, func, \"call\");\n  /* Open a hole inside the stack at `func' */\n  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);\n  incr_top(L);\n  func = restorestack(L, funcr);  /* previous call may change stack */\n  setobj2s(L, func, tm);  /* tag method is the new function to be called */\n  return func;\n}\n\n\n\n#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))\n\n\n/*\n** returns true if function has been executed (C function)\n*/\nint luaD_precall (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n  CallInfo *ci;\n  int n;  /* number of arguments (Lua) or returns (C) */\n  ptrdiff_t funcr = savestack(L, func);\n  switch (ttype(func)) {\n    case LUA_TLCF:  /* light C function */\n      f = fvalue(func);\n      goto Cfunc;\n    case LUA_TCCL: {  /* C closure */\n      f = clCvalue(func)->f;\n     Cfunc:\n      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n      ci = next_ci(L);  /* now 'enter' new function */\n      ci->nresults = nresults;\n      ci->func = restorestack(L, funcr);\n      ci->top = L->top + LUA_MINSTACK;\n      lua_assert(ci->top <= L->stack_last);\n      ci->callstatus = 0;\n      luaC_checkGC(L);  /* stack grow uses memory */\n      if (L->hookmask & LUA_MASKCALL)\n        luaD_hook(L, LUA_HOOKCALL, -1);\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, L->top - n);\n      return 1;\n    }\n    case LUA_TLCL: {  /* Lua function: prepare its call */\n      StkId base;\n      Proto *p = clLvalue(func)->p;\n      n = cast_int(L->top - func) - 1;  /* number of real arguments */\n      luaD_checkstack(L, p->maxstacksize);\n      for (; n < p->numparams; n++)\n        setnilvalue(L->top++);  /* complete missing arguments */\n      if (!p->is_vararg) {\n        func = restorestack(L, funcr);\n        base = func + 1;\n      }\n      else {\n        base = adjust_varargs(L, p, n);\n        func = restorestack(L, funcr);  /* previous call can change stack */\n      }\n      ci = next_ci(L);  /* now 'enter' new function */\n      ci->nresults = nresults;\n      ci->func = func;\n      ci->u.l.base = base;\n      ci->top = base + p->maxstacksize;\n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = CIST_LUA;\n      L->top = ci->top;\n      luaC_checkGC(L);  /* stack grow uses memory */\n      if (L->hookmask & LUA_MASKCALL)\n        callhook(L, ci);\n      return 0;\n    }\n    default: {  /* not a function */\n      func = tryfuncTM(L, func);  /* retry with 'function' tag method */\n      return luaD_precall(L, func, nresults);  /* now it must be a function */\n    }\n  }\n}\n\n\nint luaD_poscall (lua_State *L, StkId firstResult) {\n  StkId res;\n  int wanted, i;\n  CallInfo *ci = L->ci;\n  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {\n    if (L->hookmask & LUA_MASKRET) {\n      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */\n      luaD_hook(L, LUA_HOOKRET, -1);\n      firstResult = restorestack(L, fr);\n    }\n    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */\n  }\n  res = ci->func;  /* res == final position of 1st result */\n  wanted = ci->nresults;\n  L->ci = ci = ci->previous;  /* back to caller */\n  /* move results to correct place */\n  for (i = wanted; i != 0 && firstResult < L->top; i--)\n    setobjs2s(L, res++, firstResult++);\n  while (i-- > 0)\n    setnilvalue(res++);\n  L->top = res;\n  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */\n}\n\n\n/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {\n  if (++L->nCcalls >= LUAI_MAXCCALLS) {\n    if (L->nCcalls == LUAI_MAXCCALLS)\n      luaG_runerror(L, \"C stack overflow\");\n    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))\n      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n  }\n  if (!allowyield) L->nny++;\n  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */\n    luaV_execute(L);  /* call it */\n  if (!allowyield) L->nny--;\n  L->nCcalls--;\n}\n\n\nstatic void finishCcall (lua_State *L) {\n  CallInfo *ci = L->ci;\n  int n;\n  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */\n  lua_assert(L->nny == 0);\n  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */\n    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */\n    L->errfunc = ci->u.c.old_errfunc;\n  }\n  /* finish 'lua_callk'/'lua_pcall' */\n  adjustresults(L, ci->nresults);\n  /* call continuation function */\n  if (!(ci->callstatus & CIST_STAT))  /* no call status? */\n    ci->u.c.status = LUA_YIELD;  /* 'default' status */\n  lua_assert(ci->u.c.status != LUA_OK);\n  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;\n  lua_unlock(L);\n  n = (*ci->u.c.k)(L);\n  lua_lock(L);\n  api_checknelems(L, n);\n  /* finish 'luaD_precall' */\n  luaD_poscall(L, L->top - n);\n}\n\n\nstatic void unroll (lua_State *L, void *ud) {\n  UNUSED(ud);\n  for (;;) {\n    if (L->ci == &L->base_ci)  /* stack is empty? */\n      return;  /* coroutine finished normally */\n    if (!isLua(L->ci))  /* C function? */\n      finishCcall(L);\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** check whether thread has a suspended protected call\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\nstatic int recover (lua_State *L, int status) {\n  StkId oldtop;\n  CallInfo *ci = findpcall(L);\n  if (ci == NULL) return 0;  /* no recovery point */\n  /* \"finish\" luaD_pcall */\n  oldtop = restorestack(L, ci->extra);\n  luaF_close(L, oldtop);\n  seterrorobj(L, status, oldtop);\n  L->ci = ci;\n  L->allowhook = ci->u.c.old_allowhook;\n  L->nny = 0;  /* should be zero to be yieldable */\n  luaD_shrinkstack(L);\n  L->errfunc = ci->u.c.old_errfunc;\n  ci->callstatus |= CIST_STAT;  /* call has error status */\n  ci->u.c.status = status;  /* (here it is) */\n  return 1;  /* continue running the coroutine */\n}\n\n\n/*\n** signal an error in the call to 'resume', not in the execution of the\n** coroutine itself. (Such errors should not be handled by any coroutine\n** error handler and should not kill the coroutine.)\n*/\nstatic l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {\n  L->top = firstArg;  /* remove args from the stack */\n  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  luaD_throw(L, -1);  /* jump back to 'lua_resume' */\n}\n\n\n/*\n** do the work for 'lua_resume' in protected mode\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int nCcalls = L->nCcalls;\n  StkId firstArg = cast(StkId, ud);\n  CallInfo *ci = L->ci;\n  if (nCcalls >= LUAI_MAXCCALLS)\n    resume_error(L, \"C stack overflow\", firstArg);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (ci != &L->base_ci)  /* not in base level? */\n      resume_error(L, \"cannot resume non-suspended coroutine\", firstArg);\n    /* coroutine is in base level; start running it */\n    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */\n      luaV_execute(L);  /* call it */\n  }\n  else if (L->status != LUA_YIELD)\n    resume_error(L, \"cannot resume dead coroutine\", firstArg);\n  else {  /* resuming from previous yield */\n    L->status = LUA_OK;\n    ci->func = restorestack(L, ci->extra);\n    if (isLua(ci))  /* yielded inside a hook? */\n      luaV_execute(L);  /* just continue running Lua code */\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation? */\n        int n;\n        ci->u.c.status = LUA_YIELD;  /* 'default' status */\n        ci->callstatus |= CIST_YIELDED;\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L);  /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n        firstArg = L->top - n;  /* yield results come from continuation */\n      }\n      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */\n    }\n    unroll(L, NULL);\n  }\n  lua_assert(nCcalls == L->nCcalls);\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {\n  int status;\n  int oldnny = L->nny;  /* save 'nny' */\n  lua_lock(L);\n  luai_userstateresume(L, nargs);\n  L->nCcalls = (from) ? from->nCcalls + 1 : 1;\n  L->nny = 0;  /* allow yields */\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, L->top - nargs);\n  if (status == -1)  /* error calling 'lua_resume'? */\n    status = LUA_ERRRUN;\n  else {  /* yield or regular error */\n    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */\n      if (recover(L, status))  /* recover point? */\n        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */\n      else {  /* unrecoverable error */\n        L->status = cast_byte(status);  /* mark thread as `dead' */\n        seterrorobj(L, status, L->top);\n        L->ci->top = L->top;\n        break;\n      }\n    }\n    lua_assert(status == L->status);\n  }\n  L->nny = oldnny;  /* restore 'nny' */\n  L->nCcalls--;\n  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {\n  CallInfo *ci = L->ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  api_checknelems(L, nresults);\n  if (L->nny > 0) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->extra = savestack(L, ci->func);  /* save current 'func' */\n  if (isLua(ci)) {  /* inside a hook? */\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    ci->func = L->top - nresults - 1;  /* protect stack below results */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  unsigned short old_nny = L->nny;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (status != LUA_OK) {  /* an error occurred? */\n    StkId oldtop = restorestack(L, old_top);\n    luaF_close(L, oldtop);  /* close possible pending closures */\n    seterrorobj(L, status, oldtop);\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    L->nny = old_nny;\n    luaD_shrinkstack(L);\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to `f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is \" LUA_QS \")\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  int i;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    checkmode(L, p->mode, \"binary\");\n    cl = luaU_undump(L, p->z, &p->buff, p->name);\n  }\n  else {\n    checkmode(L, p->mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);\n  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */\n    UpVal *up = luaF_newupval(L);\n    cl->l.upvals[i] = up;\n    luaC_objbarrier(L, cl, up);\n  }\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  L->nny++;  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  L->nny--;\n  return status;\n}\n\n\n","/*\n** $Id: lobject.c,v 2.58.1.1 2013/04/12 18:48:47 roberto Exp $\n** Some generic functions over Lua objects\n** See Copyright Notice in lua.h\n*/\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define lobject_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"lvm.h\"\n\n\n\nLUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};\n\n\n/*\n** converts an integer to a \"floating point byte\", represented as\n** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if\n** eeeee != 0 and (xxx) otherwise.\n*/\nint luaO_int2fb (unsigned int x) {\n  int e = 0;  /* exponent */\n  if (x < 8) return x;\n  while (x >= 0x10) {\n    x = (x+1) >> 1;\n    e++;\n  }\n  return ((e+1) << 3) | (cast_int(x) - 8);\n}\n\n\n/* converts back */\nint luaO_fb2int (int x) {\n  int e = (x >> 3) & 0x1f;\n  if (e == 0) return x;\n  else return ((x & 7) + 8) << (e - 1);\n}\n\n\nint luaO_ceillog2 (unsigned int x) {\n  static const lu_byte log_2[256] = {\n    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8\n  };\n  int l = 0;\n  x--;\n  while (x >= 256) { l += 8; x >>= 8; }\n  return l + log_2[x];\n}\n\n\nlua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {\n  switch (op) {\n    case LUA_OPADD: return luai_numadd(NULL, v1, v2);\n    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);\n    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);\n    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);\n    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);\n    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);\n    case LUA_OPUNM: return luai_numunm(NULL, v1);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nint luaO_hexavalue (int c) {\n  if (lisdigit(c)) return c - '0';\n  else return ltolower(c) - 'a' + 10;\n}\n\n\n#if !defined(lua_strx2number)\n\n#include <math.h>\n\n\nstatic int isneg (const char **s) {\n  if (**s == '-') { (*s)++; return 1; }\n  else if (**s == '+') (*s)++;\n  return 0;\n}\n\n\nstatic lua_Number readhexa (const char **s, lua_Number r, int *count) {\n  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */\n    r = (r * cast_num(16.0)) + cast_num(luaO_hexavalue(cast_uchar(**s)));\n    (*count)++;\n  }\n  return r;\n}\n\n\n/*\n** convert an hexadecimal numeric string to a number, following\n** C99 specification for 'strtod'\n*/\nstatic lua_Number lua_strx2number (const char *s, char **endptr) {\n  lua_Number r = 0.0;\n  int e = 0, i = 0;\n  int neg = 0;  /* 1 if number is negative */\n  *endptr = cast(char *, s);  /* nothing is valid yet */\n  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */\n  neg = isneg(&s);  /* check signal */\n  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */\n    return 0.0;  /* invalid format (no '0x') */\n  s += 2;  /* skip '0x' */\n  r = readhexa(&s, r, &i);  /* read integer part */\n  if (*s == '.') {\n    s++;  /* skip dot */\n    r = readhexa(&s, r, &e);  /* read fractional part */\n  }\n  if (i == 0 && e == 0)\n    return 0.0;  /* invalid format (no digit) */\n  e *= -4;  /* each fractional digit divides value by 2^-4 */\n  *endptr = cast(char *, s);  /* valid up to here */\n  if (*s == 'p' || *s == 'P') {  /* exponent part? */\n    int exp1 = 0;\n    int neg1;\n    s++;  /* skip 'p' */\n    neg1 = isneg(&s);  /* signal */\n    if (!lisdigit(cast_uchar(*s)))\n      goto ret;  /* must have at least one digit */\n    while (lisdigit(cast_uchar(*s)))  /* read exponent */\n      exp1 = exp1 * 10 + *(s++) - '0';\n    if (neg1) exp1 = -exp1;\n    e += exp1;\n  }\n  *endptr = cast(char *, s);  /* valid up to here */\n ret:\n  if (neg) r = -r;\n  return l_mathop(ldexp)(r, e);\n}\n\n#endif\n\n\nint luaO_str2d (const char *s, size_t len, lua_Number *result) {\n  char *endptr;\n  if (strpbrk(s, \"nN\"))  /* reject 'inf' and 'nan' */\n    return 0;\n  else if (strpbrk(s, \"xX\"))  /* hexa? */\n    *result = lua_strx2number(s, &endptr);\n  else\n    *result = lua_str2number(s, &endptr);\n  if (endptr == s) return 0;  /* nothing recognized */\n  while (lisspace(cast_uchar(*endptr))) endptr++;\n  return (endptr == s + len);  /* OK if no trailing characters */\n}\n\n\n\nstatic void pushstr (lua_State *L, const char *str, size_t l) {\n  setsvalue2s(L, L->top++, luaS_newlstr(L, str, l));\n}\n\n\n/* this function handles only `%d', `%c', %f, %p, and `%s' formats */\nconst char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {\n  int n = 0;\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    luaD_checkstack(L, 2);  /* fmt + item */\n    pushstr(L, fmt, e - fmt);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s, strlen(s));\n        break;\n      }\n      case 'c': {\n        char buff;\n        buff = cast(char, va_arg(argp, int));\n        pushstr(L, &buff, 1);\n        break;\n      }\n      case 'd': {\n        setnvalue(L->top++, cast_num(va_arg(argp, int)));\n        break;\n      }\n      case 'f': {\n        setnvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */\n        int l = sprintf(buff, \"%p\", va_arg(argp, void *));\n        pushstr(L, buff, l);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\", 1);\n        break;\n      }\n      default: {\n        luaG_runerror(L,\n            \"invalid option \" LUA_QL(\"%%%c\") \" to \" LUA_QL(\"lua_pushfstring\"),\n            *(e + 1));\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  luaD_checkstack(L, 1);\n  pushstr(L, fmt, strlen(fmt));\n  if (n > 0) luaV_concat(L, n + 1);\n  return svalue(L->top - 1);\n}\n\n\nconst char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *msg;\n  va_list argp;\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  return msg;\n}\n\n\n/* number of chars of a literal string without the ending \\0 */\n#define LL(x)\t(sizeof(x)/sizeof(char) - 1)\n\n#define RETS\t\"...\"\n#define PRE\t\"[string \\\"\"\n#define POS\t\"\\\"]\"\n\n#define addstr(a,b,l)\t( memcpy(a,b,(l) * sizeof(char)), a += (l) )\n\nvoid luaO_chunkid (char *out, const char *source, size_t bufflen) {\n  size_t l = strlen(source);\n  if (*source == '=') {  /* 'literal' source */\n    if (l <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, l * sizeof(char));\n    else {  /* truncate it */\n      addstr(out, source + 1, bufflen - 1);\n      *out = '\\0';\n    }\n  }\n  else if (*source == '@') {  /* file name */\n    if (l <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, l * sizeof(char));\n    else {  /* add '...' before rest of name */\n      addstr(out, RETS, LL(RETS));\n      bufflen -= LL(RETS);\n      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));\n    }\n  }\n  else {  /* string; format as [string \"source\"] */\n    const char *nl = strchr(source, '\\n');  /* find first new line (if any) */\n    addstr(out, PRE, LL(PRE));  /* add prefix */\n    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\\0' */\n    if (l < bufflen && nl == NULL) {  /* small one-line source? */\n      addstr(out, source, l);  /* keep it */\n    }\n    else {\n      if (nl != NULL) l = nl - source;  /* stop at first newline */\n      if (l > bufflen) l = bufflen;\n      addstr(out, source, l);\n      addstr(out, RETS, LL(RETS));\n    }\n    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));\n  }\n}\n\n","/*\n** $Id: lstring.c,v 2.26.1.1 2013/04/12 18:48:47 roberto Exp $\n** String table (keeps all strings handled by Lua)\n** See Copyright Notice in lua.h\n*/\n\n\n#include <string.h>\n\n#define lstring_c\n#define LUA_CORE\n\n#include \"lua.h\"\n\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n\n\n/*\n** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to\n** compute its hash\n*/\n#if !defined(LUAI_HASHLIMIT)\n#define LUAI_HASHLIMIT\t\t5\n#endif\n\n\n/*\n** equality for long strings\n*/\nint luaS_eqlngstr (TString *a, TString *b) {\n  size_t len = a->tsv.len;\n  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);\n  return (a == b) ||  /* same instance or... */\n    ((len == b->tsv.len) &&  /* equal length and ... */\n     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */\n}\n\n\n/*\n** equality for strings\n*/\nint luaS_eqstr (TString *a, TString *b) {\n  return (a->tsv.tt == b->tsv.tt) &&\n         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));\n}\n\n\nunsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {\n  unsigned int h = seed ^ cast(unsigned int, l);\n  size_t l1;\n  size_t step = (l >> LUAI_HASHLIMIT) + 1;\n  for (l1 = l; l1 >= step; l1 -= step)\n    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));\n  return h;\n}\n\n\n/*\n** resizes the string table\n*/\nvoid luaS_resize (lua_State *L, int newsize) {\n  int i;\n  stringtable *tb = &G(L)->strt;\n  /* cannot resize while GC is traversing strings */\n  luaC_runtilstate(L, ~bitmask(GCSsweepstring));\n  if (newsize > tb->size) {\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);\n    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;\n  }\n  /* rehash */\n  for (i=0; i<tb->size; i++) {\n    GCObject *p = tb->hash[i];\n    tb->hash[i] = NULL;\n    while (p) {  /* for each node in the list */\n      GCObject *next = gch(p)->next;  /* save next */\n      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */\n      gch(p)->next = tb->hash[h];  /* chain it */\n      tb->hash[h] = p;\n      resetoldbit(p);  /* see MOVE OLD rule */\n      p = next;\n    }\n  }\n  if (newsize < tb->size) {\n    /* shrinking slice must be empty */\n    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);\n  }\n  tb->size = newsize;\n}\n\n\n/*\n** creates a new string object\n*/\nstatic TString *createstrobj (lua_State *L, const char *str, size_t l,\n                              int tag, unsigned int h, GCObject **list) {\n  TString *ts;\n  size_t totalsize;  /* total size of TString object */\n  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));\n  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;\n  ts->tsv.len = l;\n  ts->tsv.hash = h;\n  ts->tsv.extra = 0;\n  memcpy(ts+1, str, l*sizeof(char));\n  ((char *)(ts+1))[l] = '\\0';  /* ending 0 */\n  return ts;\n}\n\n\n/*\n** creates a new short string, inserting it into string table\n*/\nstatic TString *newshrstr (lua_State *L, const char *str, size_t l,\n                                       unsigned int h) {\n  GCObject **list;  /* (pointer to) list where it will be inserted */\n  stringtable *tb = &G(L)->strt;\n  TString *s;\n  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)\n    luaS_resize(L, tb->size*2);  /* too crowded */\n  list = &tb->hash[lmod(h, tb->size)];\n  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);\n  tb->nuse++;\n  return s;\n}\n\n\n/*\n** checks whether short string exists and reuses it or creates a new one\n*/\nstatic TString *internshrstr (lua_State *L, const char *str, size_t l) {\n  GCObject *o;\n  global_State *g = G(L);\n  unsigned int h = luaS_hash(str, l, g->seed);\n  for (o = g->strt.hash[lmod(h, g->strt.size)];\n       o != NULL;\n       o = gch(o)->next) {\n    TString *ts = rawgco2ts(o);\n    if (h == ts->tsv.hash &&\n        l == ts->tsv.len &&\n        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {\n      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */\n        changewhite(o);  /* resurrect it */\n      return ts;\n    }\n  }\n  return newshrstr(L, str, l, h);  /* not found; create a new string */\n}\n\n\n/*\n** new string (with explicit length)\n*/\nTString *luaS_newlstr (lua_State *L, const char *str, size_t l) {\n  if (l <= LUAI_MAXSHORTLEN)  /* short string? */\n    return internshrstr(L, str, l);\n  else {\n    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))\n      luaM_toobig(L);\n    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);\n  }\n}\n\n\n/*\n** new zero-terminated string\n*/\nTString *luaS_new (lua_State *L, const char *str) {\n  return luaS_newlstr(L, str, strlen(str));\n}\n\n\nUdata *luaS_newudata (lua_State *L, size_t s, Table *e) {\n  Udata *u;\n  if (s > MAX_SIZET - sizeof(Udata))\n    luaM_toobig(L);\n  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;\n  u->uv.len = s;\n  u->uv.metatable = NULL;\n  u->uv.env = e;\n  return u;\n}\n\n"]}